<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[2018年工作总结：一半是学业，一半是事业]]></title>
    <url>%2F2019%2F01%2F29%2F2018%E5%B9%B4%E5%B7%A5%E4%BD%9C%E6%80%BB%E7%BB%93%EF%BC%9A%E4%B8%80%E5%8D%8A%E6%98%AF%E5%AD%A6%E4%B8%9A%EF%BC%8C%E4%B8%80%E5%8D%8A%E6%98%AF%E4%BA%8B%E4%B8%9A%2F</url>
    <content type="text"><![CDATA[2018年，一半是学业，为顺利毕业，写论文、改论文、答辩；一半是事业，四处奔走，只为一小片立锥之地。 2018年计划完成情况：工作|论文|入职|培训2018上半年学业计划：工作|论文 完成硕士论文，顺利毕业； 谋得1份工作，找到立锥之地； 发表1篇核心论文，为研究生画上句号； 阅读50本书籍，力争成为一专多能的“T”型人才； 练习英语听力，输入决定输出，国际化趋势不可逆转。2018下半年工作计划：入职|培训 顺利入职中海油服，快速融入工作环境，完成从高校学生到公司员工的角色转变； 快速学习固井专业知识和实验操作，为顺利通过考核，早日转正做准备。 2018年完成主要工作：总结|实验|学习|反思工作总结：入职培训|产品研发|技术推介 毕业论文：顺利完成硕士论文及答辩，并发表1篇中文核心论文。 入职油服：加入中海油服油化研究院固井研究所，快速完成角色转变。 安全培训：顺利完成军训、五小证培训及QHSE培训，为实验技能培训做准备。 投标验标：学习固井知识及实验操作技能，参与缅甸投标与验标工作，实现快速成长。 技术推介：前往湛江作业基地推广：胶乳、树脂、早强剂、低密度混合材等技术体系。 产品研发：参与胶乳、纯树脂、树脂水泥、水溶性树脂、铝粉防气窜剂、水泥松散剂、悬浮稳定剂的研发工作 其他工作：参与多联UCA与微环隙仪的改进、固井手册的修订等工作。 固井实验：稠化|强度|流变|UCA 稠化：107组 模块：79联 流变：30组 失水：12组 UCA：30组 非常规： 树脂流动性：10组 悬浮稳定剂：6组 树脂胶结：4组 膨胀实验：6组 水泥松散剂：5组 铝粉防气窜剂：6组 学习交流：阅读|培训|交流|写作 阅读：书籍|行研|标准|文献 专业书籍：《油井注水泥理论与应用》《油气大数据分析利用》《数字油田》等； 行业研究报告：《2018年BP世界能源展望&amp;世界能源统计年鉴》等； 固井专业资料：固井手册、国标、行标，树脂及树脂水泥文献等。 交流学习：培训|讲座|会议 安全培训：军训，五小证培训，JSA培训，在线安全培训等。 技能培训：稠化仪，失水仪，UCA，新型测窜仪，膨胀仪等。 技术讲座：固井技术培训(3次)，蔡司显微技术；功率声波等。 会议讨论：彭雷总讲党课，高质量生产大讨论，西南石油程老师交流会，中国国际涂料展等。 写作：论文|笔记 硕士论文：耐温抗盐聚合物溶液流变性在油藏中的动态分布 发表论文：部分水解聚丙烯酰胺溶液在孔喉模型中机械降解的主控因素 科研笔记： 论文写作注意事项 聚合物溶液配制流程 常规岩心驱油实验方案 岩心驱替实验流程及注意事项 MCGS组态工程安装及注意事项 哈克流变仪粘度测量步骤及注意事项 关于读研：硕士生真的是廉价劳动力吗？ 宣传报道： 历练使人强大 专属你的青海湖旅游攻略 自我反思：认知|工作|规划|学习 认知：知行合一，方得始终 不忘初心，方得始终。不能走着走着，就丧失了目标。 知行合一是关键。知道却做不到，做不到知行合一，即便知道，用处也不大。 做胜于不做，完成胜于完美。没必要将大量时间花费在无关紧要的小问题上面，每件事都试图尽善尽美，殊不知时间有限，事有轻重缓急，还需区别对待，分清主次。 工作：人生走过的每一步都算数 做时间的朋友。无论做什么，时间都是自己的，一旦消逝，就不复回了。 踏踏实实工作。放平心态，切不可眼高手低，藐视一切。工作以后，没有性别，没有学历，同一起跑线，谁适应快，谁走得最稳。 在实验中舞出我人生。实验操作是个熟练活儿，如卖油翁所言：无他，唯手熟尔。实验前充分调研，理清思路；实验后及时总结，把握方向，纳入自己的知识体系，只做实验只会成为实验员。 规划：未来有多近，在于你想的有多远 缺少大局观，经常陷入细枝末节，而忽视整体，颠倒主次。 只顾眼前，缺少长远规划。目标不坚定，贪多嚼不烂。目标不明确，总是被带跑偏。选择做，就撇开其他，尽力做。 心细而不够胆大，穷却没能独善其身。瞻前顾后，犹犹豫豫。认为正确并经过确认的事情，尽快做，不拖延，不迁就，快刀斩乱麻。 学习：少说多做，行胜于言 独学而无友，则孤陋而寡闻。沟通是一种乐趣，多与外界沟通分享。 学而不思则罔，思而不学则殆。学以致用。知行合一。 找准路子，多尝试。天下武功，唯快不破。 2019年初步工作计划：科研|定岗|出海 科学研究：站在前辈的肩膀上，登高望远 谨记前辈指导，多读文献，追踪前沿； 多做实验，快速试错，及时调整研究方向； 至少撰写1篇会议论文、核心论文、或专利； 转正定岗：让自己配得上所定的岗位 不断学习固井专业知识，用理论指导实践； 辅助新产品研发及作业基地推广，实践是检验真理的唯一标准； 配合投标验标，锻炼应变能力。查理芒格说，想要得到一样东西，最好的办法是让自己配得上它。 出海出国：知己知彼，方能百战不殆 去海上平台锻炼，了解现场施工流程，把握海上施工的需求和痛点； 出国技术支持，拓展国际视野，适应标准更高、要求更严的国际环境。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2018年终总结：活得更明白，成为更好的自己]]></title>
    <url>%2F2019%2F01%2F14%2F2018%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93%EF%BC%9A%E6%B4%BB%E5%BE%97%E6%9B%B4%E6%98%8E%E7%99%BD%EF%BC%8C%E6%88%90%E4%B8%BA%E6%9B%B4%E5%A5%BD%E7%9A%84%E8%87%AA%E5%B7%B1%2F</url>
    <content type="text"><![CDATA[岁末年初，回望过去，总结2018，继往开来，展望2019，愿新年里顺顺利利！记录每一天，让自己活得明明白白，成为更好的自己。 请相信时间的力量，不论是对谁，所有事到最后都会是好事。如果还不是，那它还没到最后。（约翰·列侬） 2018年目标实现情况2018上半年目标 完成硕士论文，顺利毕业 谋得1份工作 发表1篇中文核心论文 搭建个人博客 阅读50本书籍 着重练习英语听力 使用Python完成数据分析 2018下半年目标 顺利入职中海油服 学习大数据，为转行做准备 入职前熟悉固井知识 2018年完成主要事项工作学习：油服|论文|博客|Java 中海油服：顺利入职中海油服油化研究院固井研究所，尽快完成角色转变：学习固井知识及实验操作，为明确研究方向做准备。 论文：顺利完成硕士论文：耐温抗盐聚合物溶液流变性在油藏中的动态分布。并发表1篇科技论文：部分水解聚丙烯酰胺溶液在孔喉模型中机械降解的主控因素。4月初投稿，5月初录用，9月初见刊；版面费1200，稿费400。 博客：搭建个人博客：Xu’s Blog，目前已发布49篇博文：编程学习笔记(38篇)、科研攻略(6篇)、随笔(5篇)。 Java：耗时4.5月(134天)，断断续续学完JavaSE、JavaWEB、SSM(3/13)。 强身健体：游泳|跑步|羽毛球 游泳：22次 跑步：3次 羽毛球：1次 阅读交流：石油|编程|机器学习阅读：图书|报告|专栏 书籍专栏：《数字油田》《油气大数据分析利用》《3D打印：从想象到现实》（部分）《通往财富自由之路》 行业研究报告：《2018年BP世界能源展望&amp;世界能源统计年鉴》，《跨境电商报告》，《“分水岭”大时代》 固井专业资料：《油井注水泥理论与应用》，固井手册，固井行标、国标，聚合物降解、树脂文献等 交流学习：讲座|培训|会议 培训讲座：功率声波；蔡司显微技术；固井技术培训(3次) 技能培训：稠化仪，失水仪，UCA，新型测窜仪，膨胀仪 安全培训：五小证，JSA培训，在线安全学习及考试 交流会议：彭总讲党课，高质量生产大讨论，西南石油程小伟老师交流会，中国国际涂料展 大数据小组：刘帅，许洋，刘凯 自学编程：Java|Python|机器学习 Java：断断续续学完JavaSE、JavaWEB、SSM(3/13)。 Python：《老王Python》项目篇，自建博客（简） 数据分析：优达学城《描述统计学入门》 机器学习：coursera:机器学习-吴恩达 深度学习：《深度学习工程师》(2weeks) MATLAB：MATLAB 入门|初级 写作：论文|博客|笔记 论文：硕士论文：耐温抗盐聚合物溶液流变性在油藏中的动态分布；发表论文：部分水解聚丙烯酰胺溶液在孔喉模型中机械降解的主控因素。 个人博客：Xu’s Blog，搭建个人博客，并发布49篇博文：编程学习笔记(38篇)、科研攻略(6篇)、随笔(5篇)。 人工智能： 机器学习：学完吴恩达机器学习18周内容，并整理成笔记：Machine Learning-Coursera。 科研笔记：在『PRESS.one』发布4篇科研笔记，并根据小论文撰写过程整理：科技论文写作注意事项 调研：开餐馆需要注意的几个关键问题；农村发展该何去何从？ 回答知乎问题：硕士生真的是廉价劳动力吗？ 自我反思：工作|认知|规划认知：知行合一，方得始终 不忘初心，方得始终。不能走着走着，就丧失了目标。 知行合一是关键。知道却做不到，做不到知行合一，即便知道，用处也不大。 做胜于不做，完成胜于完美，没必要将大量时间花费在无关紧要的小问题上面。每件事都试图尽善尽美，殊不知时间有限，事有轻重缓急，还需区别对待，分清主次。 工作：人生走过的每一步都算数 据说下个月起，降薪20%，不知真假。如果降薪，更应该考虑转行。 不怕苦，不怕累，只怕很卖力干活，工资依旧那么一点点，年轻还是要多折腾。 踏踏实实对待工作，放平心态，切不可眼高手低，藐视一切。工作以后，没有性别，没有学历，同一起跑线，谁适应快，谁走得最稳。即便以后转行，当前工作也应认真对待。每一份经历，都应有所收获。 有些问题在不同工作中是存在共性的，比如加班，培训体系不完善，带你的师傅水平不到位，或师傅过度参与，新人操作不够熟练，老师傅不放心自己上手，缺乏锻炼机会。 在实验中舞出我人生。实验操作是个熟练活儿，如卖油翁所言：无他，唯手熟尔。试验之后，总结梳理，纳入自己的知识体系，只做实验只会成为实验员。 战战兢兢，如履薄冰。有人的地方就有江湖，表面上看似风平浪静，实则暗流涌动。公司关系复杂，少说多做，小心谨慎为好。巩固已有关系，寻找潜在志同道合之人。 规划：未来有多近，在于你想的有多远 无论做什么，时间都是自己的，一旦消逝，就不复回了。 缺少大局观，经常陷入细枝末节，而忽视整体，颠倒主次。 只顾眼前，缺少总结，缺少长远规划，连自己没想清楚，如何让别人追随。 目标不坚定，贪多嚼不烂。既然选择了远方，便只顾风雨兼程。选择做，就撇开其他，尽力做。 目标不明确，总是被带跑偏。放假前魂不守舍，上班后仿佛在梦游。 心细而不够胆大，穷却没能独善其身。瞻前顾后，犹犹豫豫。认为正确并经过确认的事情，直接做，不拖延，不迁就他人，快刀斩乱麻。迁就退让不是问题的最终解决办法，却容易沦为路径依赖。 缺乏职业规划。高考报志愿，本着优先考虑学校，其次考虑专业的原则，被石油大学环境科学专业录取，大二又转到石油工程，转专业理由，石油工程专业好找工作。高考报志愿及大学转专业，根本不懂什么行业发展前景，只看学校，忽略了专业，现在看来专业非常关键。读研纯粹是因为有保研机会，随大流而读研，仍然是没有考虑学校和专业问题，以及职业发展规划。 舍得：少说多做，行胜于言 人的一切痛苦，本质上都源于对自己的无能的愤怒。 以开放心态，适应新环境。不可盛气凌人，不可咄咄逼人。 少计较得失，多总结反思，脚踏实地做事。不能跟人发脾气，怼谁都不应该。 有些人经常站着说话不腰疼，身在其中，却浑然不知，习惯就好，不必计较。 以自我为中心，忽视他人。跟人聊天时，更多关注自己的事，对于他人的事情有些漫不经心。 做不到严于律己，宽以待人，反而总对近亲的人有很高的要求。 不要承诺得太多，以免担子太重。更怕自己承诺没兑现，而对方又很较真。 主动改变自身行为习惯以适应环境的改变。适时退让，关键时刻坚守本心。 迁就他人，还是听从内心，难以平衡。道不同不相为谋。不是一路人，不进一家门。 少说多做，行胜于言。说话应注意分寸，熟人亦是如此，避免无意中惹恼他人。 独学而无友，则孤陋而寡闻。沟通是一种乐趣，多与外界沟通分享。 小妹：因材施教，多多引导 教育问题是一个大大的难题。关于小妹的教育问题，我确实有些盲目，不顾父母亲的反对，只希望尽可能为她创造好的教育条件，满足她的要求。却忽视了个体的差异，没有根据实际条件，量体裁衣，因材施教。 无法改变过去的选择和决定，不抱怨，着眼改变。无悔于小妹的上学安排，算作是对教育问题的一种探索。 教育引导小妹，不能总是斥责，小妹年少无知，跟她发脾气大多是无用，多一些包容，想办法帮助其改变现状。 关于送礼物的事，父亲和我都给小妹浇了一盆冷水。小妹还小，需要引导。 小妹的上学问题是一块心病，每每提及，无名火生上心头，怒不可遏。 学习方法：找准路子，多尝试 学习一个新技术，先去看官方文档（如果有的话），然后再去找其他人的教程。官方文档应是最专业的，个人教程主要针对个人情况。另外，很多时候没必要重复造车轮子，在别人的基础上补充完善即可。 遇到问题，直接看代码，效率高，但是没有动脑思考；自己考虑，效率低，但开动脑筋。 先看完所有教学视频，再做练习，这样看似效率高，实则效果差，而且连续看视频会犯困。建议看视频与写代码交替进行。 集中精力快速学，尽情投入开心玩。中午不睡，下午崩溃。天气冷，也不能躺床上看书学习，非常容易犯困。如果学习中途发困，或是通过短时间聊天、刷一刷朋友圈、微博、快手、抖音等转移注意力，消解困意；或者困了就洗漱早睡，死扛学习效率太低，还是需要重头再学。 学习大数据的新鲜期已过，开始感觉有些乏味，这应该是完整学习周期的正常反应。 常常为了节省一点点时间赶得很紧，常常却又松松垮垮浪费大块时间，孰重孰轻？ 固井实验：稠化|模块|失水|UCA 稠化：107组=54+23+13+12+5 模块：79联=33+26+8+12 流变：30组=8+1+7+2+12 失水：12组=2+4+5+1 UCA：30组=28+1+1 非常规: 树脂流动性：10组 悬浮稳定剂：6组 树脂胶结：4组 膨胀实验：4组 水泥松散剂：2组 Al粉防气窜剂：2组 观影记录：电影|视剧|纪录片 57部电影，94集电视剧，21集纪录片，10集综艺，2场直播 电影 批判现实：《盲山》《天注定》《驴得水》《天下无贼》《茶馆》《霸王别姬》《我不是药神》《追龙》《聚焦》《协商》《奸臣》《辩护人》《全民目击》《legal high》《十二公民》《荒蛮故事》《三块广告牌》《监守自盗》《我的个神啊》 战争题材：《至暗时刻》《敦刻尔克》《比利林恩中场战事》《窃听风暴》《红海行动》《无问西东》 剧情：《人工智能》《记忆大师》《决胜21点》《天才枪手》《无双》《影》《悟空传》《巴霍巴利王》《爱丽丝梦游仙境》《寻梦环游记》《倩女幽魂1》《泰坦尼克号》《理智与情感》《天使爱美丽》 好莱坞：《海王》《死侍2》《的士速递5》《复联3》《死侍》《黑豹》《头号玩家》 喜剧：《来电狂响》《李茶的姑妈》《西虹市首富》《唐人街探案1》《前任攻略3》《摆渡人》《帕丁顿熊1》 电视剧： 国产剧：《白鹿原》 英美剧：《黑镜》《绿箭侠》《我们这一天》 纪录片： 关于中国：《中国通史》《创新中国》《中国工厂》《零零后》《我们如何生活》《我是黑客》 关于国际：《造物小百科》《世界新能源霸权争夺战》 综艺： 《暴走大事件》《暴走看啥片》《万能图书馆》《吐槽大会》 直播： 《时间的朋友2018》《锤子发布会》 APP盘点：B站|支付宝|百度网盘|网易云音乐 2018年各月小结12月小结：湛江技术推介|数据处理|SSM 湛江作业基地技术推介：胶乳、树脂、早强剂、低密度混合材 研究院室内实验：筛选2.4sg胶乳水泥浆用乳化剂；发气型防气窜剂；多联UCA数据处理 Java三大框架：Javaweb收尾，SSM伊始，断断续续，仅学完5天内容 11月小结：胶乳|多联UCA|JavaWEB 评价优选胶乳及乳化剂：完善胶乳水泥浆体系，为湛江作业基地技术推介做准备 多联UCA评价早强剂F-Sed，纯树脂及树脂水泥，水溶性树脂，水泥松散剂，悬浮稳定剂 JavaWEB：学完Javaweb前11天内容，并发布31篇学习笔记：Xu’s Blog|博文列表 10月小结：室内实验|JavaSE|搭建博客 室内实验： 验标：打下手，做失水实验，加班至22:40 投标：被借调辅助实验，加班至23:00 树脂水泥，膨胀实验 JavaSE：学习最后3天新内容；复习JavaSE学习内容 搭建博客|Xu’s Blog：孔宁推荐，自己搭建，并根据搭建过程撰写博客搭建教程，并成功帮迪姐搭建博客。 9月小结：实验操作|固井手册|JavaSE 固井实验操作：跟方老大学习实验操作； 固井专业知识：固井手册，行业标准，稠化仪、失水仪、养护及抗压强度； JavaSE：学完JavaSE的10天内容 8月小结：五小证|QHSE|JavaSE 五小证培训：硫化氢防护，海上消防、求生、跳水，直升机水下逃生 事业部QHSE培训，学习实验操作，固井专业知识 JavaSE：学完JavaSE前8天内容 7月小结：军训|五小证|读书学习 军训：停止间转法，齐步和跑步的行进与立定，军体拳 五小证培训：直升机水下逃生，救生艇，应急急救 读书学习：《深度学习工程师》(2周)|《通往财富自由之路》|《油气大数据分析利用》 6月小结：小妹|农活|机器学习 辅导绪珍学习，准备入职材料 帮父母分担农活：晒麦，卖麦，花生地浇水，麦地里套的花生追肥 机器学习：学完吴恩达机器学习后10周内容，并整理成笔记：Machine Learning-Coursera 5月小结：小妹|答辩|机器学习 回家辅导妹妹学习 毕业答辩，修改发表小论文 机器学习：coursera:机器学习-吴恩达|week4-week9 4月小结：论文|编程|迪姐 论文：小论文修改投稿，硕士论文修改 编程：学习老王Python和吴恩达机器学习 迪姐：迪姐给我买衣服，去兰州看迪姐，陪迪姐面试 3月小结：大论文|小论文|迪姐 小论文初稿； 硕士毕业论文初稿； 迪姐送生日礼物、来校看望。 2月小结：走亲访友|小论文|编程 走亲访友：陪父母、走亲戚、看老师、同学聚会、家庭聚会 小论文：毕业论文实验收尾及跟导师讨论小论文提纲 编程：自建个人博客（简版），学习统计学 1月小结：总结|大论文|小论文 总结2017年，开启2018年：2017年终总结：回望过去，继往开来； 着手硕士论文初稿：完成第2章框架，第3章主体内容，开启第4章； 准备小论文提纲：与导师交流修改。 2019年上半年计划 婚姻：春节见家长 科研：至少写1项专利或1篇中文核心； 定岗：推动新产品研发推广，学习固井知识，为转正定岗T13做准备； 出海：去海上平台锻炼，了解现场施工流程，掌握平台现场施工关键点 大数据：学完教程，完成项目，学习笔记发博客； 转行：顺应智能化浪潮，转行大数据 阅读：每天半小时，力争不间断|微信，得到； 口语：每天半小时，实现简单交流|流利说；]]></content>
      <categories>
        <category>随笔</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Spring MVC 快速入门(二)]]></title>
    <url>%2F2018%2F12%2F28%2FSpring-MVC-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8-%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[该部分主要内容： Spring MVC整合mybatis； Spring MVC参数绑定方式。 将Spring MVC和MyBatis进行整合，控制层采用Spring MVC，持久层使用MyBatis实现。 工程搭建需求：实现商品查询列表，从mysql数据库查询商品信息。 整合思路 导入jar包：springmvc（包括spring）、mybatis、jsp等。 Dao层：引入mybatis，并修改其配置文件。 Service层：建立接口包及其实现类包。 控制层：引入的springmvc框架，建立controller包，配制springmvc.xml及web.xml文件 代码实现Dao层接口：Mapper.java123public interface ProductMapper &#123; List&lt;Product&gt; productList();&#125; 映射文件：Mapper.xml12345&lt;mapper namespace="com.cosl.sm.dao.ProductMapper"&gt; &lt;select id="productList" resultMap="BaseResultMap"&gt; select * from product &lt;/select&gt;&lt;/mapper&gt; Service层service接口及其实现类12345678910111213//接口public interface ProductService &#123; public List&lt;Product&gt; productList();&#125;//实现类public class ProductServiceImpl implements ProductService &#123; public List&lt;Product&gt; productList() &#123; SqlSession session = MybatisUtil.factory.openSession(); ProductMapper productMapper = session.getMapper(ProductMapper.class); return productMapper.productList(); &#125;&#125; Controller层采用注解开发Controller类12345678910@Controllerpublic class ProductController &#123; @RequestMapping("/productList.shtml") public String productList(HttpServletRequest request) &#123; ProductService ps = new ProductServiceImpl(); List&lt;Product&gt; productList = ps.productList(); request.setAttribute("list", productList); return "products"; &#125;&#125; 配置文件SpringMVC及MyBatis的配置文件如下图所示，配置内容与前文基本相同。 Spring MVC参数绑定方式]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring MVC 快速入门(一)]]></title>
    <url>%2F2018%2F12%2F27%2FSpringMVC%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[Spring MVC 是一个封装sevlet层的框架。有了这个框架，写JAVAEE程序时，就不再需要自己去写sevlet，springmvc提供了一个总的sevlet：dispatcherServlet，只需要写普通的类和方法即可。 Spring Web MVC和Struts2都属于表现层的框架，它是Spring框架的一部分，我们可以从Spring的整体结构中看得出来： SpringMVC入门程序开发环境 Jdk：jdk1.8 Eclipse：Neon.3 Release (4.6.3)，2017 Tomcat：apache-tomcat-8.0 开发步骤 创建Dynamic Web Project 导入jar包 创建index.jsp，在body标签内写一段话即可。 123&lt;body&gt;springmvc web project&lt;/body&gt; 创建Controller，普通java类 12345678public class FirstController implements Controller &#123; @Override public ModelAndView handleRequest(HttpServletRequest arg0, HttpServletResponse arg1) throws Exception &#123; ModelAndView view = new ModelAndView(); view.setViewName("/index.jsp"); return view; &#125;&#125; 创建springmvc.xml，新建config源文件夹，并该目录创建springmvc1.xml。 12345678910111213141516171819&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xmlns:mvc="http://www.springframework.org/schema/mvc" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd"&gt; &lt;bean name="/first.shtml" class="controller.FirstController"&gt;&lt;/bean&gt; &lt;/beans&gt; 配置前端控制器 123456789101112131415&lt;servlet&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;!-- 类名查找：Web App Libraries/spring-webmvc/ org.springframework.web.servlet/ DispatcherServlet.class --&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc1.xml&lt;/param-value&gt; &lt;/init-param&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;*.shtml&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 入门程序处理流程 Springmvc架构SpringMVC处理流程SpringMVC简化处理流程： SpringMVC完整处理流程： 组件说明以下组件通常使用框架提供实现： DispatcherServlet：前端控制器用户请求到达前端控制器，它就相当于mvc模式中的c，dispatcherServlet是整个流程控制的中心，由它调用其它组件处理用户的请求，dispatcherServlet的存在降低了组件之间的耦合性。 HandlerMapping：处理器映射器HandlerMapping负责根据用户请求找到Handler即处理器，springmvc提供了不同的映射器实现不同的映射方式，例如：配置文件方式，实现接口方式，注解方式等。 Handler：处理器Handler 是继DispatcherServlet前端控制器的后端控制器，在DispatcherServlet的控制下Handler对具体的用户请求进行处理。 由于Handler涉及到具体的用户业务请求，所以一般情况需要程序员根据业务需求开发Handler。 HandlAdapter：处理器适配器通过HandlerAdapter对处理器进行执行，这是适配器模式的应用，通过扩展适配器可以对更多类型的处理器进行执行。 View Resolver：视图解析器View Resolver负责将处理结果生成View视图，View Resolver首先根据逻辑视图名解析成物理视图名即具体的页面地址，再生成View视图对象，最后对View进行渲染将处理结果通过页面展示给用户。 View：视图springmvc框架提供了很多的View视图类型的支持，包括：jstlView、freemarkerView、pdfView等。我们最常用的视图就是jsp。 一般情况下需要通过页面标签或页面模版技术将模型数据通过页面展示给用户，需要由程序员根据业务需求开发具体的页面。 在springmvc的各个组件中，处理器映射器、处理器适配器、视图解析器称为springmvc的三大组件。需要用户开发的组件有handler、view。 非注解开发上述入门程序配置了dispatchServlet和Controller，其余采用的是默认配置。根据SpringMVC完整处理流程可知，需要配置部分为：总控制器dispatchServlet、处理器Handler、处理器映射器handlerMapping、处理器适配器handlerAdapter、视图解析器viewResolver。 下面采用非注解开发方式，在springmvc.xml中，对其他进行配置：处理器映射器、处理器适配器、视图解析器。 12345678910111213141516171819&lt;!-- 非注解开发 --&gt;&lt;!-- 默认配置：Web App Libraries/spring-webmvc/ org.springframework.web.servlet/ DispatcherServlet.properties --&gt;&lt;!-- 非注解处理器映射器 --&gt;&lt;bean class="org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping"&gt;&lt;/bean&gt;&lt;!-- 非注解处理器适配器 --&gt;&lt;bean class="org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter"&gt;&lt;/bean&gt;&lt;!-- 非注解控制器 --&gt;&lt;bean name="/first.shtml" class="controller.FirstController"&gt;&lt;/bean&gt;&lt;!-- 非注解视图解析器 --&gt;&lt;bean class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt;&lt;/bean&gt; 注解开发非注解开发方式并不常用，用的比较多的是注解开发。 创建Controller 12345678@Controllerpublic class SecondController &#123; @RequestMapping("/second.shtml") public String second(HttpServletRequest request, HttpServletResponse response) &#123; request.setAttribute("str", "这是注解开发的 "); return "/index.jsp"; &#125;&#125; 创建springmvc.xml，配置处理器映射器、处理器适配器、控制器。 123456789&lt;!-- 注解开发 --&gt;&lt;!-- 注解驱动包含了注解的处理器映射器和处理器适配器的配置 --&gt;&lt;mvc:annotation-driven&gt;&lt;/mvc:annotation-driven&gt;&lt;!-- 组件扫描会扫描指定路径下的含有controller注解的类 --&gt;&lt;context:component-scan base-package="controller"&gt;&lt;/context:component-scan&gt;&lt;!-- 视图解析器 --&gt;&lt;bean class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt;&lt;/bean&gt; 其他配置文件同上，只需做相应的修改。]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyBatis快速入门(三)]]></title>
    <url>%2F2018%2F12%2F24%2FMyBatis%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8-%E7%AC%AC3%E9%83%A8%E5%88%86%2F</url>
    <content type="text"><![CDATA[MyBatis快速入门的第三部分内容： 输入映射和输出映射：parameterType，resultMap； 动态sql：if,where,foreach,sql,include； 关联查询：一对一，一对多； Mybatis的逆向工程。 输入映射和输出映射Mapper.xml映射文件中定义了操作数据库的sql，每个sql是一个statement，映射文件是mybatis的核心。 parameterType(输入类型)传递简单类型简单类型如：int,string,double,float,date等。 传递pojo对象Mybatis使用ognl表达式解析对象字段的值，#{}或者${}括号中的值为pojo属性名称。 传递pojo包装对象开发中通过pojo传递查询条件，查询条件是综合的查询条件，不仅包括用户查询条件还包括其它的查询条件（比如将用户购买商品信息也作为查询条件），这时可以使用包装对象传递输入参数。即Pojo类中包含pojo。 需求：根据用户名查询用户信息，查询条件放到QueryVo的user属性中。 pojo包装对象: QueryVo 1234567891011public class QueryVo &#123; private User user; public User getUser() &#123; return user; &#125; public void setUser(User user) &#123; this.user = user; &#125;&#125; 映射文件：UserDao 1234567&lt;!-- 使用包装类型查询用户 使用ognl从对象中取属性值，如果是包装对象可以使用.操作符来取内容部的属性--&gt;&lt;mapper namespace="com.cosl.mybatis.dao.UserDao"&gt; &lt;select id="findUserByQueryVo" parameterType="queryvo" resultType="user"&gt; select * from user where name like "%$&#123;user.name&#125;%" &lt;/select&gt;&lt;/mapper&gt; 接口 123public interface UserDao &#123; public List&lt;User&gt; findUserByQueryVo(QueryVo queryvo);&#125; service层 123456789101112131415//接口public interface UserService &#123; public List&lt;User&gt; findUserByQueryVo(QueryVo queryvo);&#125;//实现类public class UserServiceImpl implements UserService&#123; public List&lt;User&gt; findUserByQueryVo(QueryVo queryvo) &#123; SqlSession session = MybatisUtil.factory.openSession(); UserDao userDao = session.getMapper(UserDao.class); List&lt;User&gt; list = userDao.findUserByQueryVo(queryvo); return list; &#125;&#125; 测试类 12345678910111213public class UserDaoTest &#123; public static void main(String[] args) &#123; UserService us = new UserServiceImpl(); QueryVo queryvo = new QueryVo(); User user = new User(); user.setName("张"); queryvo.setUser(user); List&lt;User&gt; list = us.findUserByQueryVo(queryvo); for (User user2 : list) &#123; System.out.println(user2); &#125; &#125;&#125; resultType(输出类型)输出简单类型输出简单类型必须查询出来的结果集有一条记录，最终将第一个字段的值转换为输出类型。使用session的selectOne可查询单条记录。 Mapper.xml文件 123456&lt;mapper namespace="com.cosl.mybatis.dao.UserDao"&gt; &lt;!-- 计算用户数量 --&gt; &lt;select id="countUserNumber" resultType="int"&gt; select count(1) from user &lt;/select&gt;&lt;/mapper&gt; 接口 123public interface UserDao &#123; public int countUserNumber();&#125; service层 12345678910111213//接口public interface UserService &#123; public int countUserNumber();&#125;//实现类public class UserServiceImpl implements UserService&#123; public int countUserNumber() &#123; SqlSession session = MybatisUtil.factory.openSession(); UserDao userDao = session.getMapper(UserDao.class); int count = userDao.countUserNumber(); return count; &#125;&#125; 测试类 123456@Testpublic void testCountUserNumber()&#123; UserService us = new UserServiceImpl(); int count = us.countUserNumber(); System.out.println(count);&#125; 输出pojo对象及列表参见之前内容。 resultMapresultType可以指定pojo将查询结果映射为pojo，但需要pojo的属性名和sql查询的列名一致方可映射成功。 如果sql查询字段名和pojo的属性名不一致，可以通过resultMap将字段名和属性名作一个对应关系 ，resultMap实质上还需要将查询结果映射到pojo对象中。 resultMap可以实现将查询结果映射为复杂类型的pojo，比如在查询结果映射对象中包括pojo和list实现一对一查询和一对多查询。 orders表及orders对象字段user_name如下，注意字段user_name，存在下划线。 orders对象，属性userName是与orders表中的user_name字段对应，但是两者并不一致，所以采用resultType无法进行结果映射，解决办法有两种：1. sql语句中采用别名；2. 使用resultMap。1234567public class Orders &#123; private int id; private double money; private String address; private int uid; private String userName;&#125; sql语句中采用别名123&lt;select id="findOrderList" resultType="orders"&gt; select id,money,address,uid,user_name userName from orders&lt;/select&gt; resultMap使用 映射文件: OrdersDao.xml 123456789&lt;mapper namespace="com.cosl.mybatis.dao.OrdersDao"&gt; &lt;resultMap type="orders" id="ordersResultMap"&gt; &lt;id property="id" column="id" /&gt; &lt;result property="userName" column="user_name"/&gt; &lt;/resultMap&gt; &lt;select id="findOrderList" resultMap="ordersResultMap"&gt; select * from orders &lt;/select&gt;&lt;/mapper&gt; 接口 123public interface OrdersDao &#123; public List&lt;Orders&gt; findOrderList();&#125; service层 123456789101112131415//接口public interface OrdersService &#123; public List&lt;Orders&gt; findOrderList();&#125;//实现类public class OrdersServiceImpl implements OrdersService &#123; public List&lt;Orders&gt; findOrderList() &#123; SqlSession session = MybatisUtil.factory.openSession(); OrdersDao ordersDao = session.getMapper(OrdersDao.class); List&lt;Orders&gt; list = ordersDao.findOrderList(); return list; &#125;&#125; 测试类 12345678@Testpublic void testfindOrderList() &#123; OrdersService ordersService = new OrdersServiceImpl(); List&lt;Orders&gt; list = ordersService.findOrderList(); for (Orders orders : list) &#123; System.out.println(orders); &#125;&#125; 动态sql通过mybatis提供的各种标签方法实现动态拼接sql。 if注意进行空字符串校验。1234567891011121314&lt;!-- 根据id或name查找用户列表 --&gt;&lt;select id="findUserList" parameterType="user" resultType="user"&gt; select * from user &lt;!-- 不明白，先这样用 --&gt; where 1=1 &lt;if test="uid!=null and uid!=''"&gt; and uid=#&#123;uid&#125; &lt;/if&gt; &lt;if test="name!=null and name!=''"&gt; and name like "%$&#123;name&#125;%" &lt;/if&gt; &lt;/select&gt; where上边的sql也可以改为如下，其中标签会自动处理多余的and。12345678910111213&lt;!-- 根据id或name查找用户列表 --&gt;&lt;select id="findUserList" parameterType="user" resultType="user"&gt; select * from user &lt;where&gt; &lt;if test="uid!=null and uid!=''"&gt; and uid=#&#123;uid&#125; &lt;/if&gt; &lt;if test="name!=null and name!=''"&gt; and name like "%$&#123;name&#125;%" &lt;/if&gt; &lt;/where&gt;&lt;/select&gt; foreach向sql传递数组或List，mybatis使用foreach解析，代码如下： 需求传入多个id及用户名查询用户信息，可以同用下边两个sql实现：12SELECT * FROM user WHERE name LIKE '%张%' AND (id =5 OR id =7 OR id=9);SELECT * FROM user WHERE name LIKE '%张%' AND id IN (5,7,9); 定义QueryVo对象在pojo中定义int数组ids存储多个用户id，并添加getter/setter方法。1234public class QueryVo &#123; private User user; private int[] ids;&#125; 映射文件1234567891011121314151617&lt;!-- 根据id或name查找用户列表 --&gt;&lt;select id="findUserList2" parameterType="queryvo" resultType="user"&gt; select * from user &lt;where&gt; &lt;if test="ids!=null"&gt; and uid in &lt;foreach collection="ids" item="id" open="(" separator="," close=")"&gt; #&#123;id&#125; &lt;/foreach&gt; &lt;/if&gt; &lt;if test="user.name!=null and user.name!=''"&gt; and name like "%$&#123;user.name&#125;%" &lt;/if&gt; &lt;/where&gt;&lt;/select&gt; 测试类1234567891011121314@Testpublic void testFindUserList2()&#123; UserService us = new UserServiceImpl(); QueryVo queryvo = new QueryVo(); User user = new User(); user.setName("张"); queryvo.setUser(user); int[] ids = &#123;5,7,9&#125;; queryvo.setIds(ids); List&lt;User&gt; list = us.findUserList2(queryvo); for (User user2 : list) &#123; System.out.println(user2); &#125;&#125; sql和inculde借助sql和include标签，将Sql中可重复使用的部分用sql标签提取出来，然后用include标签引用，从而达到sql重用的目的。 1234567891011121314151617181920212223&lt;!--用sql标签将where条件抽取出来--&gt;&lt;sql id="queryUserByIdAndName"&gt; &lt;where&gt; &lt;if test="ids!=null"&gt; and uid in &lt;foreach collection="ids" item="id" open="(" separator="," close=")"&gt; #&#123;id&#125; &lt;/foreach&gt; &lt;/if&gt; &lt;if test="user.name!=null and user.name!=''"&gt; and name like "%$&#123;user.name&#125;%" &lt;/if&gt; &lt;/where&gt; &lt;/sql&gt; &lt;!-- 根据id或name查找用户列表 --&gt; &lt;select id="findUserList2" parameterType="queryvo" resultType="user"&gt; select * from user &lt;!-- 引用sql片段 --&gt; &lt;include refid="queryUserByIdAndName"&gt;&lt;/include&gt; &lt;/select&gt; 注意：如果引用其它映射文件mapper.xml的sql片段，则在引用时需要加上namespace，如下：1&lt;include refid="namespace.引用的sql片段"/&gt; 关联查询订单与用户是一对一查询，用户与订单则是一对多查询。因为一个订单信息只会是一个人下的订单，所以从查询订单信息出发关联查询用户信息为一对一查询。如果从用户信息出发查询用户下的订单信息则为一对多查询，因为一个用户可以下多个订单。 一对一查询需求：查询所有订单信息，关联查询下单用户信息。通常有两种方法： 使用resultType，定义订单信息po类，此po类中包括了订单信息和用户信息。此方法相对而言，较为简单。 使用resultMap，定义专门的resultMap用于映射一对一查询结果。下面进行重点介绍。 orders类在Orders类中加入user属性，user属性中用于存储关联查询的用户信息，因为订单关联查询用户是一对一关系，所以这里使用单个User对象存储关联查询的用户信息。1234567public class Orders &#123; private int id; private double money; private String address; private User user; private String userName;&#125; 映射文件：OrdersDao.xml使用association完成关联查询，将关联查询信息映射到pojo对象中。 association：表示进行关联查询单条记录; property：表示关联查询的结果存储在Orders的user属性； javaType：表示关联查询的结果类型。123456789101112131415161718&lt;resultMap id="ordersMap" type="orders"&gt; &lt;result property="id" column="id" /&gt; &lt;result property="money" column="money" /&gt; &lt;result property="address" column="address" /&gt; &lt;result property="userName" column="user_name" /&gt; &lt;!-- 用association标签把orders中的user属性与user一对一关联起来 --&gt; &lt;association property="user" javaType="user"&gt; &lt;result property="uid" column="uid" /&gt; &lt;result property="name" column="name" /&gt; &lt;result property="money" column="money" /&gt; &lt;/association&gt;&lt;/resultMap&gt;&lt;select id="findOrderAndUser" resultMap="ordersMap"&gt; select * from orders,user where orders.uid=user.uid&lt;/select&gt; 接口及测试类12345678910111213//接口public interface OrdersDao &#123; public List&lt;Orders&gt; findOrderAndUser();&#125;//测试类@Testpublic void testFindOrderAndUser() &#123; OrdersService ordersService = new OrdersServiceImpl(); List&lt;Orders&gt; list = ordersService.findOrderAndUser(); for (Orders orders : list) &#123; System.out.println(orders); &#125;&#125; 一对多查询需求：查询所有用户信息及用户关联的订单信息。用户信息和订单信息为一对多关系。 User类123456public class User &#123; private int uid; private String name; private double money; private List&lt;Orders&gt; orderList;&#125; 映射文件：UserDao.xml collection部分定义了用户关联的订单信息。表示关联查询结果集。 property：关联查询的结果集存储在User对象的上orderList属性。 ofType：指定关联查询的结果集中的对象类型即orderList中的对象类型orders。123456789101112131415161718&lt;!-- 查询用户信息，一对多关联查询订单信息 --&gt;&lt;select id="findUserAndOrders" resultMap="userMap"&gt; SELECT * FROM user,orders WHERE user.uid=orders.uid&lt;/select&gt;&lt;resultMap type="user" id="userMap"&gt; &lt;result property="uid" column="uid" /&gt; &lt;result property="name" column="name" /&gt; &lt;result property="money" column="money" /&gt; &lt;!-- 使用collection标签实现一对多关联查询，将多个订单信息映射给一个用户--&gt; &lt;collection property="orderList" ofType="orders"&gt; &lt;result property="id" column="id" /&gt; &lt;result property="money" column="money" /&gt; &lt;result property="address" column="address" /&gt; &lt;result property="userName" column="user_name" /&gt; &lt;/collection&gt;&lt;/resultMap&gt; 接口、service层及测试类12345678910111213141516171819//接口public List&lt;User&gt; findUserAndOrders();//service实现类public List&lt;User&gt; findUserAndOrders() &#123; SqlSession session = MybatisUtil.factory.openSession(); UserDao userDao = session.getMapper(UserDao.class); return userDao.findUserAndOrders();&#125;//测试类@Testpublic void testFindUserAndOrders()&#123; UserService us = new UserServiceImpl(); List&lt;User&gt; list = us.findUserAndOrders(); for (User user : list) &#123; System.out.println(user); &#125;&#125; Mybatis的逆向工程只需修改生成器配置文件generatorConfig.xml中的以下信息即可： 数据库连接的信息：驱动类、连接地址、用户名、密码。 targetProject:生成model javabean类的位置。 targetProject:mapper映射文件生成的位置。 targetPackage：mapper接口生成的位置。 指定需要生成相应的代码的表名。]]></content>
      <categories>
        <category>JavaEE</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyBatis快速入门(二)]]></title>
    <url>%2F2018%2F12%2F23%2FMyBatis%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8-%E7%AC%AC2%E9%83%A8%E5%88%86%2F</url>
    <content type="text"><![CDATA[MyBatis快速入门的第二部分内容： SqlMapConfig.xml配置文件：包括定义别名，引入映射文件等。 Dao开发方法：原始Dao开发方式和Mapper动态代理开发方式。 SqlMapConfig.xml配置文件主要配置内容SqlMapConfig.xml中的主要配置的内容及顺序如下： properties（属性） settings（全局配置参数） typeAliases（类型别名） environments（环境集合属性对象） environment（环境子属性对象） transactionManager（事务管理） dataSource（数据源） mappers（映射器） SqlMapConfig.xml引用如下：123456789101112131415161718&lt;!-- 根标签 配置 --&gt;&lt;configuration&gt; &lt;properties resource="jdbc.properties"&gt;&lt;/properties&gt; &lt;!-- 环境(数据源信息) --&gt; &lt;environments default="development"&gt; &lt;environment id="development"&gt; &lt;!-- 使用jdbc事务管理，事务控制由mybatis --&gt; &lt;transactionManager type="JDBC"&gt;&lt;/transactionManager&gt; &lt;!-- 数据库连接池，由mybatis管理 --&gt; &lt;dataSource type="POOLED"&gt; &lt;property name="driver" value="$&#123;jdbc.DriverClassName&#125;" /&gt; &lt;property name="url" value="$&#123;jdbc.url&#125;" /&gt; &lt;property name="username" value="$&#123;jdbc.username&#125;" /&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;" /&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt;&lt;/configuration&gt; properties（属性）SqlMapConfig.xml引用java属性文件(properties)中的配置信息如下，MyBatis 将按照下面的顺序来加载属性： 首先，读取在 properties 元素体内定义的属性。 然后，读取properties 元素中resource或 url 加载的属性，它会覆盖已读取的同名属性。 其中，在src下的config源码文件夹中定义jdbc.properties文件，内容如下：1234jdbc.DriverClassName=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://127.0.0.1:3306/mydb?characterEncoding=utf8jdbc.username=rootjdbc.password=zsx typeAliases（类型别名）mybatis支持的别名mybatis支持的常用别名如下：别名 | 映射的类型—|—string | Stringbyte | Bytelong | Longshort | Shortint | Integerinteger | Integerdouble | Doublefloat | Floatboolean | Booleandate | Datedecimal | BigDecimalbigdecimal | BigDecimalmap | Map 自定义别名在SqlMapConfig.xml中配置如下：12345678&lt;!-- 定义别名 --&gt;&lt;typeAliases&gt; &lt;!-- 定义单个别名 --&gt; &lt;typeAlias alias="product" type="com.cosl.mybatis.model.Product" /&gt; &lt;!-- 批量定义别名，扫描整个包下面的类，别名为类名，不区分大小写 --&gt; &lt;package name="com.cosl.mybatis.model" /&gt;&lt;/typeAliases&gt;&lt;environments default="development"&gt; mappers（映射器）Mapper配置的2种方法： 使用相对于类路径的资源，如： 当工程越来越大，各种Mapper接口和Mapper.xml越来越多，用第1种方式加载的话，需要写很多行。此时可以采用另一种更加方便的办法来加载sql映射文件——自动扫包，具体做法如下。需要注意的是：此种方法要求mapper接口名称和mapper映射文件名称相同，且放在同一个目录中。 12345678&lt;/environments&gt;&lt;!-- 引入的sql的映射文件的路径 --&gt;&lt;mappers&gt; &lt;!-- 引入单个映射文件 --&gt; &lt;mapper resource="product.xml" /&gt; &lt;!-- 批量引入映射文件 --&gt; &lt;package name="com.cosl.mybatis.dao"/&gt;&lt;/mappers&gt; Dao开发方法使用Mybatis开发Dao，通常有两个方法，即原始Dao开发方法和Mapper接口开发方法。 需求 根据用户id查询一个用户信息 根据用户名称模糊查询用户信息列表 添加用户信息 SqlSession的使用范围SqlSession中封装了对数据库的操作，如：增删改查等。通过SqlSessionFactory创建SqlSession，而SqlSessionFactory是通过SqlSessionFactoryBuilder进行创建。 SqlSessionFactoryBuilderSqlSessionFactoryBuilder用于创建SqlSessionFactory，SqlSessionFactory一旦创建完成就不需要SqlSessionFactoryBuilder了，因为SqlSession是通过SqlSessionFactory生产，所以可以将SqlSessionFactoryBuilder当成一个工具类使用，最佳使用范围是方法范围即方法体内局部变量。 SqlSessionFactorySqlSessionFactory是一个接口，接口中定义了openSession的不同重载方法，SqlSessionFactory的最佳使用范围是整个应用运行期间，一旦创建后可以重复使用，通常以单例模式管理SqlSessionFactory。 SqlSessionSqlSession是一个面向用户的接口，sqlSession中定义了数据库操作方法。每个线程都应该有它自己的SqlSession实例。SqlSession的实例不能共享使用，它也是线程不安全的。因此最佳的范围是请求或方法范围。绝对不能将SqlSession实例的引用放在一个类的静态字段或实例字段中。打开一个 SqlSession，使用完毕就要关闭它。通常把这个关闭操作放到 finally 块中以确保每次都能执行关闭。如下：123456SqlSession session = sqlSessionFactory.openSession();try &#123; // do work&#125; finally &#123; session.close();&#125; 原始Dao开发方式原始Dao开发方法需要程序员编写Dao接口和Dao实现类。 映射文件 123456789101112131415161718&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE mapperPUBLIC "-//mybatis.org//DTD Mapper 3.0//EN""http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="product"&gt; &lt;select id="findProductById" parameterType="int" resultType="model.Product"&gt; select * from product where id = #&#123;id&#125; &lt;/select&gt; &lt;select id="findProductByName" parameterType="string" resultType="model.Product"&gt; select * from product where name like "%$&#123;value&#125;%" &lt;/select&gt; &lt;insert id="insertProduct" parameterType="model.Product"&gt; insert into product (name,price) values (#&#123;name&#125;,#&#123;price&#125;) &lt;/insert&gt;&lt;/mapper&gt; Dao接口及其实现类 1234567891011121314151617181920//接口public interface ProductDao &#123; public Product findProductById(int id); public List&lt;Product&gt; findProductByName(String name);&#125;//实现类public class ProductDaoImpl implements ProductDao &#123; public Product findProductById(int id) &#123; SqlSession session = MybatisUtil.factory.openSession(); Product product = session.selectOne("product.findProductById", id); return product; &#125; public List&lt;Product&gt; findProductByName(String name) &#123; SqlSession session = MybatisUtil.factory.openSession(); List&lt;Product&gt; list = session.selectList("product.findProductByName", name); return list; &#125;&#125; 工具类MybatisUtil 123456789101112131415public class MybatisUtil &#123; // 声明一个静态的会话工厂变量，可通过类名直接调用 public static SqlSessionFactory factory; // 静态代码块加载mybatis核心配置文件 static &#123; try &#123; // 加载mybatis的核心配置文件SqlMapConfig.xml InputStream in = Resources.getResourceAsStream("SqlMapConfig.xml"); // 给静态的会话工厂变量赋值 factory = new SqlSessionFactoryBuilder().build(in); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; Dao测试创建一个JUnit的测试类，对Dao进行测试。 1234567891011121314151617public class ProductDaoTest &#123; @Test public void test1() &#123; ProductDao pd = new ProductDaoImpl(); Product product = pd.findProductById(15); System.out.println(product); &#125; @Test public void test2() &#123; ProductDao pd = new ProductDaoImpl(); List&lt;Product&gt; list = pd.findProductByName("phone"); for (Product product : list) &#123; System.out.println(product); &#125; &#125;&#125; 原始Dao开发中存在的问题 Dao方法体存在重复代码：通过SqlSessionFactory创建SqlSession，调用SqlSession的数据库操作方法。 调用sqlSession的数据库操作方法需要指定statement的id，存在硬编码，不利于开发维护。 Mapper动态代理方式开发规范Mapper接口开发方法只需要程序员编写Mapper接口（相当于Dao接口），由Mybatis框架根据接口定义，创建接口的动态代理对象，代理对象的方法体同上边Dao接口实现类方法。Mapper接口开发需要遵循以下规范： Mapper.xml文件中的namespace与mapper接口的类路径相同。 Mapper接口方法名和Mapper.xml中定义的每个sql的id相同 Mapper接口方法的输入参数类型和mapper.xml中定义的每个sql 的parameterType的类型相同 Mapper接口方法的输出参数类型和mapper.xml中定义的每个sql的resultType的类型相同 Mapper.xml(映射文件)定义mapper映射文件Mapper.xml，需要修改namespace的值为Mapper接口路径。将Mapper.xml放在跟mapper接口的相同目录下。123456789101112131415161718&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE mapperPUBLIC "-//mybatis.org//DTD Mapper 3.0//EN""http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="com.cosl.mybatis.dao.ProductDao"&gt; &lt;select id="findProductById" parameterType="int" resultType="product"&gt; select * from product where id=#&#123;id&#125; &lt;/select&gt; &lt;select id="findProductByName" parameterType="string" resultType="product"&gt; select * from product where name like "%$&#123;value&#125;%" &lt;/select&gt; &lt;insert id="insertProduct" parameterType="product"&gt; insert into product (name,price,pnum) values (#&#123;name&#125;,#&#123;price&#125;,#&#123;pnum&#125;) &lt;/insert&gt;&lt;/mapper&gt; Mapper.java(接口文件)12345public interface ProductDao &#123; public Product findProductById(int id); public List&lt;Product&gt; findProductByName(String name); public void insertProduct(Product product);&#125; 接口定义有如下特点： Mapper接口方法名和Mapper.xml中定义的statement的id相同。 Mapper接口方法的输入参数类型和mapper.xml中statement的parameterType的类型相同 Mapper接口方法的输出参数类型和mapper.xml中statement的resultType的类型相同 加载Mapper.xml文件修改SqlMapConfig.xml文件：1234567&lt;!-- 引入的sql的映射文件的路径 --&gt;&lt;mappers&gt; &lt;!-- 引入单个映射文件 --&gt; &lt;!-- &lt;mapper resource="product.xml" /&gt; --&gt; &lt;!-- 批量引入映射文件 --&gt; &lt;package name="com.cosl.mybatis.dao"/&gt;&lt;/mappers&gt; service层1234567891011121314151617181920212223242526272829//接口public interface ProductService &#123; public Product findProductById(int id); public List&lt;Product&gt; findProductByName(String name); public void insertProduct(Product product);&#125;//实现类public class ProductServiceImpl implements ProductService &#123; public Product findProductById(int id) &#123; SqlSession session = MybatisUtil.factory.openSession(); ProductDao productDao = session.getMapper(ProductDao.class); return productDao.findProductById(id); &#125; public List&lt;Product&gt; findProductByName(String name) &#123; SqlSession session = MybatisUtil.factory.openSession(); ProductDao productDao = session.getMapper(ProductDao.class); return productDao.findProductByName(name); &#125; public void insertProduct(Product product) &#123; SqlSession session = MybatisUtil.factory.openSession(); ProductDao productDao = session.getMapper(ProductDao.class); productDao.insertProduct(product); session.commit(); &#125;&#125; 测试123456789101112131415161718192021222324252627public class ProductDaoTest &#123; @Test public void testFindProductById()&#123; ProductService ps = new ProductServiceImpl(); Product product = ps.findProductById(15); System.out.println(product); &#125; @Test public void testFindProductByName()&#123; ProductService ps = new ProductServiceImpl(); List&lt;Product&gt; list = ps.findProductByName("phone"); for (Product product : list) &#123; System.out.println(product); &#125; &#125; @Test public void testInsertProduct()&#123; ProductService ps = new ProductServiceImpl(); Product product = new Product(); product.setName("honor"); product.setPrice(1399.00); product.setPnum(12); ps.insertProduct(product); &#125;&#125; 小结 关于selectOne和selectList：动态代理对象调用selectOne()或selectList()是由mapper接口方法的返回值决定，如果返回list则调用selectList方法，如果返回单个对象则调用selectOne方法。 关于namespace：mybatis官方推荐使用mapper动态代理方法开发mapper接口，程序员不用编写mapper接口实现类，使用mapper代理方法时，输入参数可以使用pojo包装对象或map对象，保证dao的通用性。]]></content>
      <categories>
        <category>JavaEE</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[历练使人强大]]></title>
    <url>%2F2018%2F12%2F15%2F%E5%8E%86%E7%BB%83%E4%BD%BF%E4%BA%BA%E5%BC%BA%E5%A4%A7%2F</url>
    <content type="text"><![CDATA[有人说，七年是一辈子。七年前，我听着石油工业之歌《我为祖国献石油》进入中国石油大学（北京）就读本科。七年后的今天，我入职中海油服，石油工业之歌那嘹亮的歌声犹在耳边回响，“我为祖国献石油，哪里有石油，哪里就是我的家……”，她描绘出石油人不一样的工作场景，唱出了一代又一代石油人的心声。 作为刚刚入职中海油服油化研究院的新员工，我们是机动人员，扮演着不同的角色。我们如同一块砖，哪里需要，往哪里搬；既可以敲门，亦可以用来盖房、铺路。 我们扮演着学生的角色，顺利完成为期两周的安全培训，系统学习QHSE2.0体系，为实现“人员零伤害、环境零损害、财产零损失、质量零缺陷”的目标奠定基础。 别人的征程是星辰大海，我的征程是固井试验。告别了安全培训，又踏上实验技能培训的征程，以学徒身份，在方工的耐心指导下，一步步学习固井试验操作技能。从称量、搅拌、配浆到上稠化仪；从测密度、测流变到测量稠化时间和沉降稳定性；从在旁边看到亲自上手操作；从蹒跚学步到独立操作。由于硕士期间学习的是提高采收率与采油化学方向，所以面对固井这个陌生的面孔，内心还是有些慌乱。专业知识欠缺，研究方向不确定，都是面临的问题，所以接下来要走的路还很长，需要学习的东西还很多。 作为刚刚入职的新员工，院长特意安排我们旁听了油化事业部2018年中工作会议，希望我们借助这次机会对研究院的工作有一个宏观上的认识。另外，有幸作为新员工代表上台谈谈入职以来的感受，尽管明知自己上台会非常紧张，准备也并不充分，但还是希望能够抓住这样的机会锻炼自己，加速成长，所以在大家的相互推让下，我选择了走上前去，只因为这是一次很好的锻炼机会。 总有一种力量让人泪流满面，总有一种精神令人荡气回肠。工作之余，有幸作为观众参加屈长龙同志先进事迹宣讲报告会，屈长龙是中国LNG事业的先驱者，他不辞辛劳，不分昼夜，为我国LNG事业的发展鞠躬尽瘁，奉献终生。他是时代的楷模，是海油人的榜样，如同黑暗中的灯塔，照亮我们的前程。 还扮演过固井学组的会务成员角色，给近百位参会人员打电话确认是否收到会议通知邮件。也是“我是党员我带头”活动的参与者，和大家一起打扫库房，清理货架。 历练使人强大，珍惜每一次机会，积极参与，向内修炼，向外建设。天道酬勤，唯有努力和奋斗从来未曾被辜负。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[MyBatis快速入门(一)]]></title>
    <url>%2F2018%2F12%2F11%2FMyBatis%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8-%E7%AC%AC1%E9%83%A8%E5%88%86%2F</url>
    <content type="text"><![CDATA[JAVAEE开发的三大框架：ssm、ssh（前几年常用）。 Spring MVC：用来封装servlet编程的一个框架（struts2）； Spring：体系整合框架，其他框架的粘合剂； Mybatis：封装jdbc访问代码的一个框架（hibernate），ORM对象关系映射 框架及其优点：框架（Framework）是整个或部分系统的可重用设计，表现为一组抽象构件及构件实例间交互的方法; 另一种定义认为，框架是可被应用开发者定制的应用骨架。是用框架可以提高程序复用性和系统的可扩充性，以缩短大型应用软件系统的开发周期，提高开发质量。框架的优点表现在： 灵活可配置：将程序中写死的代码（硬编码）可以写到配置文件中。 代码复用性高：将程序中反复要写的代码（套路代码）进行抽取封装，提高代码的复用性。 简化开发：框架将底层复杂的细节进行了封装，并提供了方便调用的API，使得开发人员将工作的重点转移到实际业务中，大大提高了项目的开发效率。 MyBatis框架 MyBatis 本是apache的一个开源项目iBatis, 2010年这个项目由apache software foundation 迁移到了google code，并且改名为MyBatis 。2013年11月迁移到Github。 MyBatis是一个优秀的持久层(DAO)框架，它对jdbc的操作数据库的过程进行封装，使开发者只需要关注 SQL 本身，而不需要花费精力去处理例如注册驱动、创建connection、创建statement、手动设置参数、结果集检索等jdbc繁杂的过程代码。 Mybatis通过xml或注解的方式将要执行的各种statement（statement、preparedStatemnt、CallableStatement）配置起来，并通过java对象和statement中的sql进行映射生成最终执行的sql语句，最后由mybatis框架执行sql并将结果映射成java对象并返回。 回顾JDBC编程jdbc编程步骤： 注册驱动； 创建并获取数据库链接； 创建jdbc statement对象； 设置sql语句及其参数(使用preparedStatement)； 通过statement执行sql并获取结果； 对sql执行结果进行解析处理； 释放资源(resultSet、preparedstatement、connection)。 jdbc存在的问题 数据库连接创建、释放频繁造成系统资源浪费从而影响系统性能，如果使用数据库连接池可解决此问题。 Sql语句在代码中硬编码，造成代码不易维护，实际应用sql变化的可能较大，sql变动需要改变java代码。 使用preparedStatement向占位符号传参数存在硬编码，因为sql语句的where条件不一定，可能多也可能少，修改sql还要修改代码，系统不易维护。对结果集解析存在硬编码（查询列名），sql变化导致解析代码变化，系统不易维护，如果能将数据库记录封装成pojo对象解析比较方便。 MyBatis架构MyBatis架构如下图所示： mybatis配置：SqlMapConfig.xml，此文件作为mybatis的全局配置文件，配置了mybatis的运行环境等信息。mapper.xml文件即sql映射文件，文件中配置了操作数据库的sql语句。此文件需要在SqlMapConfig.xml中加载。 通过mybatis环境等配置信息构造SqlSessionFactory即会话工厂（单例） 由会话工厂创建sqlSession即会话，操作数据库需要通过sqlSession进行。 mybatis底层自定义了Executor执行器接口操作数据库，Executor接口有两个实现：一个是基本执行器、一个是缓存执行器。 Mapped Statement也是mybatis一个底层封装对象，它包装了mybatis配置信息及sql映射信息等。mapper.xml文件中一个sql对应一个Mapped Statement对象，sql的id即是Mapped statement的id。 Mapped Statement对sql执行输入参数进行定义，包括HashMap、基本类型、pojo，Executor通过Mapped Statement在执行sql前将输入的java对象映射至sql中，输入参数映射就是jdbc编程中对preparedStatement设置参数。 Mapped Statement对sql执行输出结果进行定义，包括HashMap、基本类型、pojo，Executor通过Mapped Statement在执行sql后将输出结果映射至java对象中，输出结果映射过程相当于jdbc编程中对结果的解析处理过程。 MyBatis入门程序mybaits的代码由github.com管理，下载链接：mybatis-3。 工程搭建流程 创建java工程：使用eclipse创建java工程，jdk使用1.8。 加入jar包：在src下新建普通文件夹lib，并加入mybatis核心包、依赖包、数据驱动包。 log4j.properties&lt;可选&gt;：加log4j的配置文件是为了调试观察方便，mybatis默认使用log4j作为输出日志信息。在工程的src下创建源码文件夹config，并新建log4j.properties文件，内容如下： 123456# Global logging configurationlog4j.rootLogger=DEBUG, stdout# Console output...log4j.appender.stdout=org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.layout=org.apache.log4j.PatternLayoutlog4j.appender.stdout.layout.ConversionPattern=%5p [%t] - %m%n 创建SqlMapConfig.xml，它是mybatis核心配置文件，文件的配置内容为数据源、事务管理。代码如下： 1234567891011121314151617181920212223242526&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE configurationPUBLIC "-//mybatis.org//DTD Config 3.0//EN""http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;!-- 根标签 配置 --&gt;&lt;configuration&gt; &lt;properties resource="jdbc.properties"&gt;&lt;/properties&gt; &lt;!-- 环境(数据源信息) --&gt; &lt;environments default="development"&gt; &lt;environment id="development"&gt; &lt;!-- 使用jdbc事务管理，事务由mybatis控制 --&gt; &lt;transactionManager type="JDBC"&gt;&lt;/transactionManager&gt; &lt;!-- 数据库连接池，由mybatis管理 --&gt; &lt;dataSource type="POOLED"&gt; &lt;property name="driver" value="$&#123;jdbc.DriverClassName&#125;" /&gt; &lt;property name="url" value="$&#123;jdbc.url&#125;" /&gt; &lt;property name="username" value="$&#123;jdbc.username&#125;" /&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;" /&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!-- 引入的sql的映射文件的路径 --&gt; &lt;mappers&gt; &lt;mapper resource="product.xml" /&gt; &lt;/mappers&gt;&lt;/configuration&gt; 其中，DTD约束的本地文件加载配置流程如下： 在eclipse中，Window/Preferences/XML Catalog/Add Location：mybatis-3-config.dtd文件的路径 Key：-//mybatis.org//DTD Config 3.0//EN Product类：Product类作为mybatis进行sql映射使用，Product类通常与数据库表对应，Product.java如下： 12345678910public class Product &#123; private int id; private String name; private String description; private double price; private int pnum; private String category; get/set/toString...&#125; sql映射文件：在src下的config目录中创建sql映射文件Product.xml，代码如下： 123456789101112131415161718192021222324252627282930&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE mapperPUBLIC "-//mybatis.org//DTD Mapper 3.0//EN""http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;!-- namespace代表的是该mapper文件的唯一标示 --&gt;&lt;mapper namespace="product"&gt; &lt;!-- mybatis进行输入映射使用parameterType指定参数的类型，resultType指定结果映射类型 #&#123;&#125;代表着一个占位符，如果是简单类型(int|string|float|double|date)的参数,可用id、value等来标示变量名 --&gt; &lt;select id="findProductById" parameterType="int" resultType="model.Product"&gt; select * from product where id = #&#123;id&#125; &lt;/select&gt; &lt;!-- 如果sql需要进行字符串拼接，则用$&#123;&#125;代表字符串拼接，#&#123;&#125;代表占位符?--&gt; &lt;select id="findProductByName" parameterType="java.lang.String" resultType="model.Product"&gt; select * from product where name like "%$&#123;value&#125;%" &lt;/select&gt; &lt;!-- mybatis进行输入参数映射时，能且只能传进一个参数 --&gt; &lt;update id="updateProduct" parameterType="model.Product"&gt; update product set name=#&#123;name&#125; where name="miphone" &lt;/update&gt; &lt;insert id="insertProduct" parameterType="model.Product"&gt; insert into product (name,price) values (#&#123;name&#125;,#&#123;price&#125;) &lt;/insert&gt; &lt;delete id="deleteProduct" parameterType="int"&gt; delete from product where id = #&#123;id&#125; &lt;/delete&gt;&lt;/mapper&gt; 其中，namespace为命名空间，用于隔离sql语句，后面会讲另一层非常重要的作用。 在核心配置文件中加载sql映射文件：mybatis框架需要加载映射文件，将Product.xml添加在SqlMapConfig.xml，代码如下： 1234&lt;!-- 引入的sql的映射文件的路径 --&gt;&lt;mappers&gt; &lt;mapper resource="product.xml" /&gt;&lt;/mappers&gt; 需求及其代码实现 需求： 根据id查询商品信息 根据名称模糊查询商品信息列表 添加商品 更新商品 删除商品 实现代码： 123456789101112131415161718192021222324252627282930313233343536373839// 1：加载mybatis的核心配置文件SqlMapConfig.xmlInputStream in = Resources.getResourceAsStream("SqlMapConfig.xml");// 2:创建会话工厂sqlSessionFactory(理解成连接池)SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(in);// 3:获取会话(相当于connection连接)SqlSession session = sqlSessionFactory.openSession();// 4:操作数据库// 4.1 根据id查询商品// Product product = session.selectOne("product.findProductById", 15);// 4.2 根据名称模糊查询商品// List&lt;Product&gt; list = session.selectList("product.findProductByName","phone");//注意：mybatis的事务是非自动提交的，所以需要修改数据库中数据的增删改//必须手动提交事务，否则数据修改不成功。/*// 4.3 更新商品名称 * Product p = new Product(); p.setName("xiaomi"); * session.update("product.updateProduct", p); *//*// 4.4 插入商品 * Product p = new Product(); * p.setName("oppo"); * p.setPrice(2399); * session.insert("product.insertProduct", p); */// 4.5 删除商品session.delete("product.deleteProduct", 16);// 增删改需手动提交事务，查询无需修改数据库则不需要提交事务session.commit();// 5：输出结果// System.out.println(list);// 6:释放资源session.close(); 小结{}和${} #{} 表示一个占位符号，通过#{}可以实现preparedStatement向占位符中设置值，自动进行java类型和jdbc类型转换，#{}可以有效防止sql注入。 #{}可以接收简单类型值或pojo属性值。 如果parameterType传输单个简单类型值，#{}括号中可以是value或其它名称。 ${} 表示拼接sql串，通过${}可以将parameterType 传入的内容拼接在sql中且不进行jdbc类型转换， ${}可以接收简单类型值或pojo属性值，如果parameterType传输单个简单类型值，${}括号中只能是value。 parameterType和resultType parameterType：指定输入参数类型，mybatis通过ognl从输入对象中获取参数值拼接在sql中。 resultType：指定输出结果类型，mybatis将sql查询结果的一行记录映射为resultType指定类型的对象。 selectOne和selectList selectOne查询一条记录，如果使用selectOne查询多条记录则抛出异常。 selectList可以查询一条或多条记录。]]></content>
      <categories>
        <category>JavaEE</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL多表操作]]></title>
    <url>%2F2018%2F12%2F09%2FMySQL%E5%A4%9A%E8%A1%A8%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[交叉连接交叉连接(cross join)，又称笛卡尔连接(cartesian join)或叉乘(Product)，它是所有类型内连接的基础。它把表看作是行记录的集合，交叉连接即返回这两个集合的笛卡尔积。这其实等价于内连接的连接条件始终为”真”，或连接条件不存在。 笛卡尔积引用自数学，在数学中，两个集合X和Y的笛卡尔积（Cartesian product），又称直积。假设集合X={a,b}，集合Y={0,1,2}，则两个集合的笛卡尔积为{(a,0),(a,1),(a,2),(b,0),(b,1),(b,2)}。可以扩展到多个集合的情况。 12--交叉连接SELECT * FROM user CROSS JOIN orders 内连接inner join on通过on后面的条件，将两张表中的数据过滤。12--inner join onSELECT * FROM user INNER JOIN orders ON user.uid=orders.uid inner join using：通过指定两张表中比较的字段来进行等式消除迪卡尔积12--inner join usingSELECT * FROM user INNER JOIN orders USING(uid) 在inner join on和inner join using中，可以将inner省略，因为join默认就是内连接(inner join)，省略inner后的查询语句如下，效果与有inner是一样的。123--省略innerSELECT * FROM user JOIN orders ON user.uid=orders.uid;SELECT * FROM user JOIN orders USING(uid); 隐式内连接在实际开发中，使用最多的一种内连接叫做隐式内连接，其实就是将inner join省略，也不在使用on进行条件过滤，而是直接使用where进行过滤，查询语句如下，结果与inner join on一样。12--隐式内连接SELECT * FROM user,orders WHERE user.uid=orders.uid; 小结 cross join 只是将两个表连接起来，产生笛卡尔积。 natural join 使用表中主外键关联来消除迪卡尔积。 inner join using 可省略inner，在using后直接书写比较的字段名称，注意要加括号。 inner join on 可省略inner,在on后面直接书写比较条件，通过条件来消除迪卡尔积。 隐式内连接，在开发应用比较多，可以省略inner join，表与表之间用逗号分开，通过where条件来消除迪卡尔积。 外链接内连接只是将两个或多个表中有关联的数据集查询出来，而没有关联的数据（只有一个表中有，而另外一个表中没有的数据）则无法查询出来。如果在开发中需要将所有用户及其订单查询出来，如果用户没有订单，也要查询出用户信息。那么，使用内连接显然是做不到的，这时就需要使用外连接。 外连接并不要求连接的两表的每一条记录在对方表中都一条匹配的记录。连接表保留所有记录，甚至某条记录没有匹配的记录也要保留.，外连接可依据连接表保留左表、右表或全部表的行而进一步分为左外连接、右外连接和全连接。注意：mysql只支持左外连接与右外连接，而不支持全连接。 左外连接：left outer join on 注意 outer 可以省略 右外连接：right outer join on 注意 outer可以省略 执行下面sql语句查询结果如下:1SELECT * FROM user LEFT OUTER JOIN orders ON user.uid=orders.uid; 可以看出，即便mike和marry没有订单，其orders表中的数据以null显示出来。 上述sql语句使用的是左外连接，也就是说以user表为准，保留user表中所有数据，右表orders中没有关联的数据，以null关联显示出来。右外连接也是同理，执行下面sql语句查询结果如下:1SELECT * FROM orders RIGHT OUTER JOIN user ON orders.uid=user.uid]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[JavaWeb小结]]></title>
    <url>%2F2018%2F12%2F02%2FJavaWeb%E5%B0%8F%E7%BB%93%2F</url>
    <content type="text"><![CDATA[HTML：HTML快速入门 HTML的定义及作用 HTML的基本标签及其属性 form表单，Get和Post请求的区别 元素的概念理解 布局标签（能看懂） 相对路径与绝对路径、内部资源和外部资源 CSS：CSS快速入门 Css的定义及作用 Css的选择器 Css和HTML结合的三种方式，即CSS引入方式 Css的 常用样式 Css+div 基本布局 Javascript：JavaScript快速入门 Js的定义、作用及特点 Js和html结合的两种方式：外部使用与内部使用 Js的数据类型：原始数据类型和引用数据类型 Js的常用对象：Date、RegExp等 Js的流程控制：if，for Js的方法声明、参数、返回值、调用 常用事件及其与方法的结合方式(重要) Dom对象的常用方法 表单校验(重要) 二级级联(重要) jQuery：jQuery快速入门|AJAX快速入门|动态代理 什么是JQuery JQuery的页面加载 JQuery的常用选择器 JQuery的效果 JQuery的事件及事件绑定(重要) JQuery的文档操作 JQuery的遍历 全局加载函数 页面加载函数 JQuery的Ajax(重要) Jquery元素的对象(重要) Bootstrap：Bootstrap快速入门 容器 栅格系统 会用，能看懂 数据库：MySQL数据库 数据库的增删改查(重要) 表的增删改查(重要) 表数据的增删改查(重要) 多表基本操作(重要) JDBC：JDBC快速入门|数据库连接池|C3p0及事务 Jdbc定义及作用 Jdbc的开发步骤（重要） 配置文件配置jdbc的参数 读取配置文件 数据库连接池及其优点、原理 Dbcp数据库连接池的基本使用 C3p0数据库连接池的基本使用 阿帕奇的dbUtils的基本使用 阿帕奇的beanUtils的基本使用 事务的作用及其基本特性 Jdbc简单操作事务 事务不考虑隔离级别出现的问题 【注意依赖的jar包】 Tomcat：Tomcat 什么是服务器，及常见的服务器 tomcat的目录结构（未掌握） Tomcat和eclipse结合，基本配置 使用Tomcat创建项目，发布项目，访问资源 知道自己发布项目的具体位置 Servlet：Servlet|Servlet应用小案例|Xml解析及会话技术 ServletConfig对象 ServletContext对象 HttpServletRequest对象 HttpServletResponse对象 HttpSession对象 Cookie对象 Filter（未学） Listener（未学） 【掌握页面传递参数到指定的servlet，servlet会接收页面的所有参数并操作数据库，将数据展示到指定页面】 JSP：JSP快速入门|借助JSP实现注册|登录|查询|JSON快速入门 JSP概述及其作用 基本语法 三大指令 JSP的九大内置对象 Web阶段的四大作用域 EL表达式、作用及其使用 EL的11个隐式对象 JSTL的两个标签：c:if; c:foreach JavaWeb综合应用：商品管理]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[JavaWeb综合应用：商品管理]]></title>
    <url>%2F2018%2F12%2F01%2FJavaWeb%E7%BB%BC%E5%90%88%E5%BA%94%E7%94%A8%EF%BC%9A%E5%95%86%E5%93%81%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[基于一个商品信息展示页面，实现以下商品管理功能： 查询所有商品； 根据商品名称模糊查询； 添加商品； 删除单个或多个商品； 修改商品； 主要代码如下： 主页面index.html12345678910111213141516&lt;a href="#"&gt; &lt;i class="fa fa-home"&gt;&lt;/i&gt; &lt;span class="nav-label"&gt;商品管理&lt;/span&gt; &lt;span class="fa arrow"&gt;&lt;/span&gt;&lt;/a&gt;&lt;ul class="nav nav-second-level"&gt; &lt;li&gt; &lt;a class="J_menuItem" href="products.jsp" data-index="0"&gt;查询商品&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a class="J_menuItem" href="add.jsp"&gt;添加商品&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a class="J_menuItem" href="edit.jsp"&gt;修改商品&lt;/a&gt; &lt;/li&gt;&lt;/ul&gt; products.jsp1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!--商品模糊查询--&gt;&lt;form action="/webday12/searchProductByName" method="post"&gt; &lt;div class="input-group"&gt; &lt;input type="text" placeholder="请输入商品名" name="name" class="form-control"&gt; &lt;span class="input-group-btn"&gt; &lt;button type="submit" class="btn btn-primary"&gt;搜索&lt;/button&gt; &lt;/span&gt; &lt;/div&gt;&lt;/form&gt;&lt;!--商品模糊查询--&gt;&lt;table class="table table-bordered" id="prodctId"&gt; &lt;tr&gt; &lt;th&gt;&lt;/th&gt; &lt;th&gt;商品名称&lt;/th&gt; &lt;th&gt;商品价格&lt;/th&gt; &lt;th&gt;商品类目&lt;/th&gt; &lt;th&gt;商品数量&lt;/th&gt; &lt;th&gt;商品描述&lt;/th&gt; &lt;th&gt;编辑&lt;/th&gt; &lt;/tr&gt; &lt;form action="/webday12/DeleteMore" method="post"&gt; &lt;c:forEach var="list" items="$&#123;productList &#125;"&gt; &lt;tr&gt; &lt;td&gt;&lt;input type="checkbox" name="id" value="$&#123;list.id &#125;"&gt; &lt;/td&gt; &lt;td&gt;$&#123;list.name &#125;&lt;/td&gt; &lt;td&gt;$&#123;list.price &#125;&lt;/td&gt; &lt;td&gt;$&#123;list.category &#125;&lt;/td&gt; &lt;td&gt;$&#123;list.pnum &#125;&lt;/td&gt; &lt;td&gt;$&#123;list.description &#125;&lt;/td&gt; &lt;td&gt;&lt;a href="Delete?id=$&#123;list.id &#125;"&gt;删除&lt;/a&gt;|&lt;a href="ShowEdit?id=$&#123;list.id &#125;"&gt;修改&lt;/a&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/c:forEach&gt; &lt;button type="submit" class="btn btn-primary"&gt;删除多个&lt;/button&gt; &lt;span&gt;&lt;/span&gt; &lt;/form&gt; &amp;nbsp; &lt;form action="/webday12/Search" method="post"&gt; &lt;button type="submit" class="btn btn-primary"&gt;显示所有商品&lt;/button&gt; &lt;/form&gt;&lt;/table&gt; add.jsp1234567891011121314151617181920212223242526272829303132333435363738&lt;form class="form-horizontal m-t" action="/webday12/AddProduct" method="post" id="signupForm"&gt; &lt;div class="form-group"&gt; &lt;label class="col-sm-3 control-label"&gt;商品名称：&lt;/label&gt; &lt;div class="col-sm-4"&gt; &lt;input id="name" name="name" class="form-control" type="text"&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;label class="col-sm-3 control-label"&gt;商品价格：&lt;/label&gt; &lt;div class="col-sm-4"&gt; &lt;input id="price" name="price" class="form-control" type="text"&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;label class="col-sm-3 control-label"&gt;类目：&lt;/label&gt; &lt;div class="col-sm-4"&gt; &lt;input id="category" name="category" class="form-control" type="text"&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;label class="col-sm-3 control-label"&gt;数量：&lt;/label&gt; &lt;div class="col-sm-4"&gt; &lt;input id="pnum" name="pnum" class="form-control" type="text"&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;label class="col-sm-3 control-label"&gt;描述：&lt;/label&gt; &lt;div class="col-sm-4"&gt; &lt;input id="description" name="description" class="form-control" type="text"&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;div class="col-sm-8 col-sm-offset-3"&gt; &lt;button class="btn btn-success" type="submit"&gt;&lt;i class="fa fa-save"&gt;&lt;/i&gt; &amp;nbsp;&amp;nbsp;添加&amp;nbsp;&amp;nbsp; &lt;/button&gt; &lt;/div&gt; &lt;/div&gt;&lt;/form&gt; edit.jsp1234567891011121314151617181920212223242526272829303132333435363738 &lt;form class="form-horizontal m-t" id="signupForm" action="/webday12/DoEdit" method="post"&gt;&lt;input type="hidden" name="id" value="$&#123;product.id &#125;"&gt; &lt;div class="form-group"&gt; &lt;label class="col-sm-3 control-label"&gt;商品名称：&lt;/label&gt; &lt;div class="col-sm-4"&gt; &lt;input id="name" name="name" value="$&#123;product.name &#125;" class="form-control" type="text"&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;label class="col-sm-3 control-label"&gt;商品价格：&lt;/label&gt; &lt;div class="col-sm-4"&gt; &lt;input id="price" name="price" value="$&#123;product.price &#125;" class="form-control" type="text"&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;label class="col-sm-3 control-label"&gt;类目：&lt;/label&gt; &lt;div class="col-sm-4"&gt; &lt;input id="cate" name="category" value="$&#123;product.category &#125;" class="form-control" type="text"&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;label class="col-sm-3 control-label"&gt;数量：&lt;/label&gt; &lt;div class="col-sm-4"&gt; &lt;input id="num" name="pnum" value="$&#123;product.pnum &#125;"class="form-control" type="text"&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;label class="col-sm-3 control-label"&gt;描述：&lt;/label&gt; &lt;div class="col-sm-4"&gt; &lt;input id="desc" name="description" value="$&#123;product.description &#125;"class="form-control" type="text"&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;div class="col-sm-8 col-sm-offset-3"&gt; &lt;button class="btn btn-success" type="submit"&gt;&lt;i class="fa fa-save"&gt;&lt;/i&gt; &amp;nbsp;&amp;nbsp;提交修改&amp;nbsp;&amp;nbsp; &lt;/button&gt; &lt;/div&gt; &lt;/div&gt;&lt;/form&gt; ServletSearch.java1234567891011ProductService ps = new ProductServiceImpl();try &#123; //查询所有商品 List&lt;Product&gt; productList = ps.searchProduct(); //将查询结果保存到request域中 request.setAttribute("productList", productList); //转发 request.getRequestDispatcher("products.jsp").forward(request, response);&#125; catch (Exception e) &#123; e.printStackTrace();&#125; searchProductByName.java12345678910111213ProductService ps = new ProductServiceImpl();try &#123; //接收页面参数 String name = request.getParameter("name"); //查询所有商品 List&lt;Product&gt; productList = ps.searchProductByName(name); //将查询结果保存到request域中 request.setAttribute("productList", productList); //转发 request.getRequestDispatcher("products.jsp").forward(request, response);&#125; catch (Exception e) &#123; e.printStackTrace();&#125; AddProduct.java123456789101112131415161718Product product = new Product();ProductService ps = new ProductServiceImpl();try &#123; // 接收页面参数 Map&lt;String, String[]&gt; map = request.getParameterMap(); BeanUtils.populate(product, map); // 调用service int i = ps.addProduct(product); if (i == 1) &#123;// 添加成功，重定向至查询界面 response.sendRedirect("/webday12/Search"); &#125; else &#123;// 转发至商品添加页面 request.setAttribute("product", product); request.getRequestDispatcher("add.jsp").forward(request, response); &#125;&#125; catch (Exception e) &#123; e.printStackTrace();&#125; Delete.java12345678910ProductService ps = new ProductServiceImpl();try &#123; String param = request.getParameter("id"); int i = ps.deleteProduct(param); if(i==1)&#123;//删除成功则重定向至商品查询展示页面 response.sendRedirect("/webday12/Search"); &#125;&#125; catch (Exception e) &#123; e.printStackTrace();&#125; DeleteMore.java12345678910111213141516ProductService ps = new ProductServiceImpl();try &#123; // 接收页面参数 String[] ids = request.getParameterValues("id"); // 调用service删除数 int i = ps.deleteMoreProduct(ids); if (i == 1) &#123;// 删除状态提示 response.getWriter().write("删除成功，页面跳转中。。。"); &#125; else &#123; response.getWriter().write("删除失败，，页面跳转中。。。"); &#125; // 页面重定向至查询所有商品页面 response.sendRedirect("/webday12/Search");&#125; catch (Exception e) &#123; e.printStackTrace();&#125; ShowEdit.java12345678910111213ProductService ps = new ProductServiceImpl();try &#123; // 接收页面参数 String id = request.getParameter("id"); // 调用service先根据id查询需要修改的商品 Product product = ps.getProductById(id); if (null != product) &#123;// 查到商品，则保存到域中，并转发至修改商品信息页面 request.setAttribute("product", product); request.getRequestDispatcher("edit.jsp").forward(request, response); &#125;&#125; catch (Exception e) &#123; e.printStackTrace();&#125; DoEdit.java123456789101112131415161718Product product = new Product();ProductService ps = new ProductServiceImpl();try &#123; // 接收页面参数 Map&lt;String, String[]&gt; map = request.getParameterMap(); BeanUtils.populate(product, map); //调用service，修改商品信息 int i = ps.editProduct(product); if(i==1)&#123;//如果修改成功，重定向至查询商品页面 response.sendRedirect("/webday12/Search"); &#125;else&#123;//如果修改失败，将重定向至查询商品页面 request.setAttribute("product", product); request.getRequestDispatcher("edit.jsp").forward(request, response); &#125;&#125; catch (Exception e) &#123; e.printStackTrace();&#125; ServiceProductService.java12345678910111213141516public interface ProductService &#123; //删除单个商品 public int deleteProduct(String id) throws Exception; //删除多个商品 public int deleteMoreProduct(String[] ids) throws Exception; //查询单个商品 public Product getProductById(String id) throws Exception; //修改商品信息 public int editProduct(Product product) throws Exception; //添加商品 public int addProduct(Product product) throws Exception; //查询所有商品 public List&lt;Product&gt; searchProduct() throws Exception; //根据商品名称模糊查询 public List&lt;Product&gt; searchProductByName(String name) throws Exception;&#125; ProductServiceImpl.java1234567891011121314151617181920212223242526272829303132public class ProductServiceImpl implements ProductService &#123; ProductDao pd = new ProductDaoImpl(); //删除单个商品 public int deleteProduct(String id) throws Exception &#123; return pd.deleteProduct(id); &#125; //查询单个商品 public Product getProductById(String id) throws Exception &#123; return pd.getProductById(id); &#125; //修改商品信息 public int editProduct(Product product) throws Exception &#123; return pd.editProduct(product); &#125; //删除多个商品 public int deleteMoreProduct(String[] ids) throws Exception &#123; return pd.deleteMoreProduct(ids); &#125; //添加商品 public int addProduct(Product product) throws Exception &#123; return pd.addProduct(product); &#125; //查询所有商品 public List&lt;Product&gt; searchProduct() throws Exception &#123; return pd.searchProduct(); &#125; //根据商品名称模糊查询 public List&lt;Product&gt; searchProductByName(String name) throws Exception &#123; return pd.searchProductByName(name); &#125;&#125; DaoProductDao.java12345678910111213141516public interface ProductDao &#123; // 查询所有商品 public List&lt;Product&gt; searchProduct() throws Exception; // 根据商品名称模糊查询 public List&lt;Product&gt; searchProductByName(String name) throws Exception; //根据id查询商品 public Product getProductById(String id) throws Exception; // 根据id删除单个商品 public int deleteProduct(String id) throws Exception; // 根据id删除多个商品 public int deleteMoreProduct(String[] ids) throws Exception; // 修改商品信息 public int editProduct(Product product) throws Exception; //添加商品 public int addProduct(Product product) throws Exception;&#125; ProductDaoImpl.java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667public class ProductDaoImpl implements ProductDao &#123; // 根据id删除单个商品 public int deleteProduct(String id) throws SQLException &#123; ComboPooledDataSource dataSource = new ComboPooledDataSource(); QueryRunner runner = new QueryRunner(dataSource); String sql = "delete from product where id=?"; int i = runner.update(sql, id); return i; &#125; //根据id查询商品 public Product getProductById(String id) throws Exception &#123; ComboPooledDataSource dataSource = new ComboPooledDataSource(); QueryRunner runner = new QueryRunner(dataSource); String sql = "select * from product where id=?"; Product product = runner.query(sql, new BeanHandler&lt;Product&gt;(Product.class), id); return product; &#125; // 修改商品信息 public int editProduct(Product product) throws Exception &#123; ComboPooledDataSource dataSource = new ComboPooledDataSource(); QueryRunner runner = new QueryRunner(dataSource); String sql = "update product set name=?,price=?,pnum=?,category=?,description=? where id=?"; int i = runner.update(sql, product.getName(), product.getPrice(), product.getPnum(), product.getCategory(), product.getDescription(), product.getId()); return i; &#125; // 根据id删除多个商品 public int deleteMoreProduct(String[] ids) throws Exception &#123; ComboPooledDataSource dataSource = new ComboPooledDataSource(); QueryRunner runner = new QueryRunner(dataSource); String sql = "delete from product where id=?"; for (String id : ids) &#123; int i = runner.update(sql, id); if (i == 0) &#123; return 0; &#125; break; &#125; return 1; &#125; //添加商品 public int addProduct(Product product) throws Exception &#123; ComboPooledDataSource dataSource = new ComboPooledDataSource(); QueryRunner runner = new QueryRunner(dataSource); String sql = "insert into product values(null,?,?,?,?,?)"; int i = runner.update(sql, product.getName(), product.getPrice(), product.getCategory(), product.getPnum(), product.getDescription()); return i; &#125; // 查询所有商品 public List&lt;Product&gt; searchProduct() throws Exception &#123; ComboPooledDataSource dataSource = new ComboPooledDataSource(); QueryRunner runner = new QueryRunner(dataSource); String sql = "select * from product"; List&lt;Product&gt; productList = runner.query(sql, new BeanListHandler&lt;Product&gt;(Product.class)); return productList; &#125; // 根据商品名称模糊查询 public List&lt;Product&gt; searchProductByName(String name) throws Exception &#123; ComboPooledDataSource dataSource = new ComboPooledDataSource(); QueryRunner runner = new QueryRunner(dataSource); String sql = "select * from product where name like ?"; String nname = "%" + name + "%"; List&lt;Product&gt; productList = runner.query(sql, new BeanListHandler&lt;Product&gt;(Product.class), nname); return productList; &#125;&#125; Product对象1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162public class Product &#123; private int id; private String name; private String description; private double price; private int pnum; private String category; public final int getId() &#123; return id; &#125; public final void setId(int id) &#123; this.id = id; &#125; public final String getName() &#123; return name; &#125; public final void setName(String name) &#123; this.name = name; &#125; public final String getDescription() &#123; return description; &#125; public final void setDescription(String description) &#123; this.description = description; &#125; public final double getPrice() &#123; return price; &#125; public final void setPrice(double price) &#123; this.price = price; &#125; public final int getPnum() &#123; return pnum; &#125; public final void setPnum(int pnum) &#123; this.pnum = pnum; &#125; public final String getCategory() &#123; return category; &#125; public final void setCategory(String category) &#123; this.category = category; &#125; @Override public String toString() &#123; return "Product [id=" + id + ", name=" + name + ", description=" + description + ", price=" + price + ", pnum=" + pnum + ", category=" + category + "]"; &#125;&#125;]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>Application</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态代理]]></title>
    <url>%2F2018%2F11%2F30%2F%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%2F</url>
    <content type="text"><![CDATA[动态代理动态代理的目的只有一个，即对类的方法进行增强。 装饰模式 是你，还有你，一切拜托你。 1234//接口public interface Inter &#123; public void play();&#125; 123456//需要增强的类public class Monkey implements Inter &#123; public void play() &#123; System.out.println("play"); &#125;&#125; 1234567891011121314151617181920//增强后的类public class EnMonkey implements Inter &#123; Monkey monkey; public EnMonkey() &#123; super(); &#125; public EnMonkey(Monkey monkey) &#123; super(); this.monkey = monkey; &#125; public void play() &#123; System.out.println("eat"); monkey.play(); System.out.println("sleep"); &#125;&#125; 12345678//测试类public class Test &#123; public static void main(String[] args) &#123; //有你(Monkey)，还有你(EnMonkey)，一切拜托你(monkey) EnMonkey monkey = new EnMonkey(new Monkey()); monkey.play(); &#125;&#125; 动态代理模式动态代理，即对一个类进行动态的增强。 被代理的类必须实现接口； 创建一个实现InvocationHandler接口的实现类； 重写方法。使用Method对象调用invoke(代理对象的实例)方法，要增强的功能 在invoke方法 的前后； 创建代理对象，Proxy.newProxyInstance()，并传入三个参数： 类加载器 代理类的接口 实现InvocationHandler接口的实现类 动态代理代码示例【被代理的对象，即想要增强的类】12345678910111213141516171819//类实现的接口public interface UserDao &#123; public void add(); public void updata();&#125;//被代理的对象public class UserDaoImpl implements UserDao &#123; @Override public void add() &#123; System.out.println("调用jdbc操作数据库 add"); &#125; @Override public void updata() &#123; System.out.println("调用jdbc操作数据库 update"); &#125;&#125; 【代理对象，即增强后的类】1234567891011121314151617181920212223public class DynamicProxy &#123; public static void main(String[] args) &#123; //被代理对象，即目标对象 UserDaoImpl userDaoImpl = new UserDaoImpl(); // 生成动态代理 UserDao userDao = (UserDao)Proxy.newProxyInstance(DynamicProxy.class.getClassLoader(), UserDaoImpl.class.getInterfaces(), new InvocationHandler() &#123; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; System.out.println("开启事务"); Object obj = method.invoke(userDaoImpl, args); System.out.println("关闭事务"); return obj; &#125; &#125;); //调用方法，测试 userDao.add(); System.out.println("-----------"); userDao.updata(); &#125;&#125; 动态代理代码改造12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class ProxyFactory implements InvocationHandler &#123; Transfer trans = new Transfer(); //被增强的类 Object obj; public ProxyFactory() &#123; super(); &#125; public ProxyFactory(Object obj) &#123; this.obj = obj; &#125; /** * 用于增强方法 */ @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; //prefix(); trans.open(); Object object = method.invoke(obj, args); //suffix(); trans.close(); return object; &#125; /** * 生成代理对象 * 参数: * 1.类加载器 * 2.被代理对象实现的接口，必须实现接口 * 3.实现InvocationHandler接口的实现类，当前类已实现 * @return 代理对象 */ public Object getProxy() &#123; return Proxy.newProxyInstance(ProxyFactory.class.getClassLoader(), obj.getClass().getInterfaces(), this); &#125; public void prefix()&#123; System.out.println("方法执行前。。。"); &#125; public void suffix()&#123; System.out.println("方法执行后。。。"); &#125;&#125; 12345678910//用于方法增强的类Transferpublic class Transfer &#123; public void open() &#123; System.out.println("开启事务"); &#125; public void close() &#123; System.out.println("关闭事务"); &#125;&#125; 1234567891011121314//测试类public class Test &#123; public static void main(String[] args) &#123; // 被代理对象，目标对象 ProxyFactory proxyFactory = new ProxyFactory(new UserDaoImpl()); // 生成代理对象 UserDao userDao = (UserDao) proxyFactory.getProxy(); // 调用方法 userDao.add(); &#125;&#125;]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>动态代理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AJAX快速入门]]></title>
    <url>%2F2018%2F11%2F29%2FAJAX%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[AJAX快速入门 Ajax 即“Asynchronous Javascript And XML”（异步 JavaScript 和 XML），是指一种创建交互式网页应用的网页开发技术。Ajax 用于创建快速动态网页，通过在后台与服务器进行少量数据交换，Ajax 可以使网页实现异步更新，即在无需重新加载整个网页的情况下，能够更新部分网页。 同步与异步 同步现象：客户端发送请求到服务器端，当服务器返回响应之前，客户端都处于等待，即卡死状态； 异步现象：客户端发送请求到服务器端，无论服务器是否返回响应，客户端都可以随意做其他事情，不会被卡死。 Ajax原理页面发起请求，会将请求发送给浏览器内核中的Ajax引擎，Ajax引擎会提交请求到 服务器端，在这段时间里，客户端可以任意进行任意操作，直到服务器端将数据返回 给Ajax引擎后，会触发你设置的事件，从而执行自定义的js逻辑代码完成某种页面功能。 jQuery对js原生的ajax进行了封装，封装后的ajax的操作方法更简洁，功能更强大。 $.get(url, [data], [callback], [type])$.get()和$.post()所需的4个参数均为： URL，请求的地址 携带的数据，json格式 请求成功时的回调函数，参数是请求成功返回的数据 接收数据的解析方式，如text、json、html 需要注意的是，ajax不接收畸形json字符串： 畸形json字符串：”{‘name’:’畸形json字符串’}” 标准的json字符串： “{\”name\”:\”标准的json字符串\”}”，\为转义符号） ‘{“name”:”标准的json字符串”}’， java不允许单引号 html页面代码：12345678910111213141516171819202122232425&lt;body&gt; &lt;form action=""&gt; Name:&lt;input type="text" id="acc" name="account" onblur="checkName()"&gt; &lt;/form&gt;&lt;/body&gt;&lt;script src="./js/jquery-1.8.3.min.js" type="text/javascript"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt; function checkName() &#123; $.get( //1.url "http://localhost:8080/webday11/Register", //2. 请求携带的参数 ，json格式 &#123; "name" : $("#acc").val() &#125;, //3.请求成功时的回调函数，参数是请求成功返回的数据 function(data) &#123; //var json = eval('(' + data + ')') //当格式是"text"时使用 alert(data.name); &#125;, //4. 告诉浏览器处理数据的格式：text、json、html //"text" "json") &#125;;&lt;/script&gt; servlet代码：123456789//接收页面参数String name = request.getParameter("name");System.out.println(name);//创建User对象User user = new User(name,"123");//将User对象转换为json字符串String str = JSON.toJSONString(user);//向页面响应json字符串response.getWriter().println("&#123;\"name\":\"标准的json字符串\"&#125;"); $.post(url, [data], [callback], [type])代码示例：12345678910111213141516171819202122232425&lt;body&gt; &lt;form action=""&gt; Name:&lt;input type="text" id="acc" name="account" onblur="checkName()"&gt; &lt;/form&gt;&lt;/body&gt;&lt;script src="./js/jquery-1.8.3.min.js" type="text/javascript"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt; function checkName() &#123; $.post( //1.url "http://localhost:8080/webday11/Register", //2. 请求携带的参数 ，json格式 &#123; "name" : $("#acc").val() &#125;, //3.请求成功时的回调函数，参数是请求成功返回的数据 function(data) &#123; //var json = eval('(' + data + ')') //当格式是"text"时使用 alert(data.name); &#125;, //4. 告诉浏览器处理数据的格式：text、json、html //"text" "json") &#125;;&lt;/script&gt; $.ajax({url:val1,data:val2,type:val3…})$.ajax()常用的参数为： url：请求的地址 data：请求携带的数据，json type：请求类型，”get”、”post” success：请求成功时的回调函数，参数是请求成功返回的数据 error：请求失败时的回调函数，参数是请求失败返回的数据 dataType：返回数据的解析方式 代码示例：1234567891011121314151617&lt;script src="./js/jquery-1.8.3.min.js" type="text/javascript"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt; function checkName() &#123; $.ajax(&#123; url:"http://localhost:8080/webday11/Register", data:&#123;"name": $("#acc").val()&#125;, type:"post", success:function(data)&#123; alert(data.name); &#125;, error:function(data)&#123; alert("error"); &#125;, dataType:"json" &#125;); &#125;;&lt;/script&gt; ajax应用：判断用户名是否存在步骤分析： HTML页面：发送ajax，携带数据 servlet：接收页面参数，调用service service：调用dao dao：操作数据库 代码示例： html页面： 123456789101112131415161718192021222324&lt;body&gt; &lt;form action=""&gt; Name:&lt;input type="text" id="acc" name="account" onblur="checkName()"&gt; &lt;span id="span"&gt;&lt;/span&gt; &lt;/form&gt;&lt;/body&gt;&lt;script src="./js/jquery-1.8.3.min.js" type="text/javascript"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt; function checkName() &#123; $.ajax(&#123; url:"http://localhost:8080/webday11/Register", data:&#123;"name": $("#acc").val()&#125;, type:"post", success:function(data)&#123; //alert(data.name); $("#span").html(data); &#125;, error:function(data)&#123; alert("error"); &#125;, //dataType:"json" &#125;); &#125;;&lt;/script&gt; servlet： 1234567891011121314try &#123; // 接收页面参数 String name = request.getParameter("name"); // 调用service User user = service.getUserByName(name); // 处理返回结果 if (null == user) &#123; response.getWriter().write("此用户名可用"); &#125; else &#123; response.getWriter().write("此用户名不可用"); &#125;&#125; catch (SQLException e) &#123; e.printStackTrace();&#125; service接口及实现类： 12345678910111213//service接口及实现类public interface UserService &#123; public User getUserByName(String name) throws SQLException;&#125;//service实现类public class UserServiceImpl implements UserService &#123; UserDao dao = new UserDaoImpl(); public User getUserByName(String name) throws SQLException &#123; return dao.getUserByName(name); &#125;&#125; dao接口及实现类： 12345678910111213141516//dao接口及实现类public interface UserDao &#123; public User getUserByName(String name) throws SQLException;&#125;//dao实现类public class UserDaoImpl implements UserDao &#123; public User getUserByName(String name) throws SQLException &#123; ComboPooledDataSource dataSource = new ComboPooledDataSource(); QueryRunner runner = new QueryRunner(dataSource); String sql = "select * from user2 where name=?"; User user = runner.query(sql, new BeanHandler&lt;User&gt;(User.class), name); return user; &#125;&#125; 请求后台并传递参数的三种方式请求后台并传递参数的三种方式： form表单 超链接 ajax123456789101112131415161718192021222324252627&lt;body&gt; &lt;!-- form表单 --&gt; &lt;form action="/webday11/Param" method="post"&gt; name:&lt;input type="text" name="name"&gt; &lt;button type="submit"&gt;Submit&lt;/button&gt; &lt;/form&gt; &lt;br&gt; &lt;!-- 超链接 --&gt; &lt;button type="submit"&gt; &lt;a href="http://localhost:8080/webday11/Param?name=linda"&gt;Submit&lt;/a&gt; &lt;/button&gt; &lt;!-- ajax --&gt; &lt;button type="submit" id="ajax"&gt;Ajax&lt;/button&gt;&lt;/body&gt;&lt;script type="text/javascript" src="./js/jquery-1.8.3.min.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt; $(function() &#123; $("#ajax").click(function()&#123; $.post( "/webday11/Param", &#123;"name":"mike"&#125;, ) &#125;); &#125;)&lt;/script&gt;]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>AJAX</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JSON快速入门]]></title>
    <url>%2F2018%2F11%2F28%2FJSON%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[JSON(JavaScript Object Notation, JS 对象简谱) 是一种轻量级的数据交换格式。它基于 ECMAScript (欧洲计算机协会制定的js规范)的一个子集，采用完全独立于编程语言的文本格式来存储和表示数据。简洁和清晰的层次结构使得 JSON 成为理想的数据交换语言。 易于人阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效率。 json数据格式json有两种格式： 对象格式：{“key1”:obj,”key2”:obj,”key3”:obj…} 数组/集合格式：[obj,obj,obj…] 代码示例：12345678910111213141516171819202122&lt;script type="text/javascript"&gt; //1. 对象格式 var j1 = &#123;"name": "linda1", "password" : "123"&#125;; //alert(j1.name+"---"+j1.password); //2. list集合格式 var j2 = [ &#123;"name" : "linda1","password" : "123"&#125;, &#123;"name" : "linda2","password" : "123"&#125;, &#123;"name" : "linda3","password" : "123"&#125; ] //alert(j2[0].name); //3. map集合格式 var j3 = &#123; "name":"linda", "user1": &#123;"name" : "linda1","password" : "123"&#125;, "user2":[&#123;"name" : "mike1","password" : "123"&#125;, &#123;"name" : "mike2","password" : "123"&#125;] &#125;; //alert(j3.name); //alert(j3.user1.name); //alert(j3.user2[0].name);&lt;/script&gt; Json数据解析 json对象转换为json字符串：Eval()函数，JSON.parse(obj)； json字符串转换为json对象：JSON.toJSONString(obj)。 1234567&lt;scrip src="./js/jquery-1.8.3.min.js" type="text/javascript"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt; //jason字符串转json对象：Eval()函数js原生函数 var str = "&#123;'name':'lisa'&#125;"; var j4 = eval('(' + str + ')'); //alert(j4.name);&lt;/script&gt; 12345678//jason字符串转json对象：JSON.parse(obj)String str = "&#123;'name':'lisa'&#125;";Object j5 = JSON.parse(str);System.out.println(j5);//json对象转换为json字符串：JSON.toJSONString(obj)String str2 = JSON.toJSONString(j5);System.out.println(str2);]]></content>
      <tags>
        <tag>JSON</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[借助JSP实现注册|登录|查询]]></title>
    <url>%2F2018%2F11%2F27%2F%E5%80%9F%E5%8A%A9JSP%E5%AE%9E%E7%8E%B0%E6%B3%A8%E5%86%8C-%E7%99%BB%E5%BD%95-%E6%9F%A5%E8%AF%A2%2F</url>
    <content type="text"><![CDATA[需求：实现登录、注册、商品的查询、退出登录要求：三层代码分离（web/service/dao）, mvc, jsp 实现注册功能servlet代码：1234567891011121314151617181920UserService service = new UserService();try &#123; // 接收页面参数 String name = request.getParameter("name"); String password = request.getParameter("password"); User user = new User(name, password); // 注册返回结果 int register = service.register(user); // 将返回结果存放至request域中 request.setAttribute("register", register); if (register == 1) &#123; // 转发 request.getRequestDispatcher("login.jsp").forward(request, response); &#125; else &#123; response.getWriter().println("服务器开小车喽，请客官稍后重试。。。"); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace();&#125; jsp代码：12345678910111213&lt;form action="/webday10/RegisterServlet" method="post"&gt; &lt;table&gt; &lt;tr&gt; &lt;td&gt;Name:&lt;/td&gt; &lt;td&gt;&lt;input type="text" name="name"&gt;&lt;/td&gt;&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Password:&lt;/td&gt; &lt;td&gt;&lt;input type="password" name="password"&gt;&lt;/td&gt;&gt; &lt;/tr&gt; &lt;/table&gt; &lt;button type="submit"&gt;Submit&lt;/button&gt;&lt;/form&gt; 实现登录功能servlet代码：1234567891011121314151617181920UserService service = new UserService();try &#123; //接收页面参数 String name = request.getParameter("name"); String password = request.getParameter("password"); User user = new User(name, password); //登录返回结果 User login = service.login(user); // 将返回结果存放至request域中 request.setAttribute("login", login); if(null==login)&#123; //转发至注册页面 request.getRequestDispatcher("register.jsp").forward(request, response); &#125;else&#123; //转发至查询页面 request.getRequestDispatcher("search.jsp").forward(request, response); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace();&#125; jsp代码：12345678910111213&lt;form action="/webday10/LoginServlet" method="post"&gt; &lt;table&gt; &lt;tr&gt; &lt;td&gt;Name:&lt;/td&gt; &lt;td&gt;&lt;input type="text" name="name"&gt;&lt;/td&gt;&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Password:&lt;/td&gt; &lt;td&gt;&lt;input type="password" name="password"&gt;&lt;/td&gt;&gt; &lt;/tr&gt; &lt;/table&gt; &lt;button type="submit"&gt;Submit&lt;/button&gt;&lt;/form&gt; 实现查询功能servlet代码：123456789101112131415UserService service = new UserService();try &#123; // 接收页面参数 String keyword = request.getParameter("keyword"); // 商品查询数据 List&lt;Product&gt; plist; plist = service.searchProduct(keyword); // 将返回结果存放至request域中 request.setAttribute("plist", plist); // 转发 request.getRequestDispatcher("search.jsp").forward(request, response);&#125; catch (SQLException e) &#123; e.printStackTrace();&#125; jsp代码：12345678910111213&lt;table border="1px" cellspacing="0" width="500px" align="center"&gt; &lt;caption&gt;Product List&lt;/caption&gt; &lt;tr align="center"&gt; &lt;th&gt;Name&lt;/th&gt; &lt;th&gt;Description&lt;/th&gt; &lt;/tr&gt; &lt;c:forEach items="$&#123;plist &#125;" var="product"&gt; &lt;tr align="center"&gt; &lt;td&gt;$&#123;product.name &#125;&lt;/td&gt; &lt;td&gt;$&#123;product.description &#125;&lt;/td&gt; &lt;/tr&gt; &lt;/c:forEach&gt;&lt;/table&gt; Service和Dao代码Service代码123456789101112131415161718192021222324252627282930313233public class UserService &#123; UserDao dao = new UserDao(); /** * 注册 * @param user 新用户 * @return 注册状态，成功返回1，失败返回0 * @throws SQLException */ public int register(User user) throws SQLException &#123; return dao.register(user); &#125; /** * 登录 * @param user 登录用户 * @return 登录状态，返回登录用户 * @throws SQLException */ public User login(User user) throws SQLException&#123; return dao.login(user); &#125; /** * 商品信息查询 * @param keyword 关键词 * @return 商品信息 * @throws SQLException */ public List&lt;Product&gt; searchProduct(String keyword) throws SQLException &#123; return dao.searchProduct(keyword); &#125;&#125; Dao代码1234567891011121314151617181920212223242526272829303132333435363738394041424344public class UserDao &#123; /** * 注册 * @param user 新用户 * @return 注册状态，成功返回1，失败返回0 * @throws SQLException */ public int register(User user) throws SQLException &#123; ComboPooledDataSource dataSource = new ComboPooledDataSource(); QueryRunner runner = new QueryRunner(dataSource); String sql = "insert into user2 values(null,? ,?)"; int i = runner.update(sql,user.getName(),user.getPassword()); return i; &#125; /** * 登录 * @param user 登录用户 * @return 登录状态，返回登录用户 * @throws SQLException */ public User login(User user) throws SQLException &#123; ComboPooledDataSource dataSource = new ComboPooledDataSource(); QueryRunner runner = new QueryRunner(dataSource); String sql = "select * from user2 where name=? and password=?"; User user2 = runner.query(sql, new BeanHandler&lt;User&gt;(User.class), user.getName(), user.getPassword()); return user2; &#125; /** * 商品信息查询 * @param keyword 关键词 * @return 商品信息 * @throws SQLException */ public List&lt;Product&gt; searchProduct(String keyword) throws SQLException &#123; ComboPooledDataSource dataSource = new ComboPooledDataSource(); QueryRunner runner = new QueryRunner(dataSource); String sql = "select * from product where name like ?"; String keyword2 = "%" + keyword + "%"; List&lt;Product&gt; plist = runner.query(sql, new BeanListHandler&lt;Product&gt;(Product.class), keyword2); return plist; &#125;&#125;]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>JSP</tag>
        <tag>Application</tag>
        <tag>Servlet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JSP快速入门]]></title>
    <url>%2F2018%2F11%2F26%2FJSP%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[JSP(Java Server Pages)，实质上就是servlet，用于开发动态web资源。JSP其实就是在html中写Java代码，即JSP = JAVA+HTML。 JSP动态页面技术的执行过程（原理）： JSP--&gt;翻译成servlet（.Java）--&gt;编译成（.class） --&gt;初始化--&gt;实例化--&gt;服务--&gt;销毁 所以第一次访问JSP时可能会比较慢。 JSP快速入门123456789101112131415161718192021222324252627282930313233&lt;%@ page language="Java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%&gt;&lt;!-- 导包 --&gt;&lt;%@ page import="java.util.*"%&gt;&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;my jsp&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 写的都方法体的内容 --&gt; &lt;% //获取当前时间 Date date = new Date(); String date2 = date.toLocaleString(); //response.getWriter().println(date2); %&gt; &lt;%=date2%&gt; &lt;!-- for循环 --&gt; &lt;% for (int i = 0; i &lt; 10; i++) &#123; %&gt; &lt;h1&gt;winter is coming!&lt;/h1&gt; &lt;% &#125; %&gt;&lt;/body&gt;&lt;/html&gt; JSP的基本语法注释 html的注释 1&lt;!-- html的注释 --&gt; jsp注释 1234&lt;%-- &lt;%//java注释int a = 2;%&gt; --%&gt; jsp小脚本可使用java注释 12345//java单行注释/*java多行注释*/ jsp小脚本 &lt;% 此处写java代码 %&gt; &lt;%=要输出的内容%&gt; &lt;% 声明局部变量 %&gt; &lt;%! 声明全局变量%&gt; 12345678&lt;!-- java小脚本 --&gt;&lt;%String str = "声明局部变量";%&gt;&lt;%!String str2="声明全局变量"; %&gt;&lt;%=str+" 输出内容" %&gt; 三大指令Page指令Page指令，作用在整个页面上。语法： &lt;%@ 指令名(page) 属性 %&gt; 123456789&lt;!-- 设置语言、编码方式等 --&gt;&lt;%@ page language="Java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%&gt;&lt;!-- 导包 --&gt;&lt;%@ page import="java.util.*"%&gt;&lt;!-- 指定出错跳转页面 --&gt;&lt;%@ page errorPage="error.jsp" %&gt; Include指令Include指令，用于静态包含，将另一个jsp静态页面包含在此jsp页面中。 12345678910111213141516&lt;%@ page language="Java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%&gt;&lt;%@ include file="header.jsp"%&gt;&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;Include&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;This is a include page&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;&lt;%@ include file="footer.jsp"%&gt; Taglib指令Taglib指令，用于引入一些jsp的标签库。需要jar包：jstl.jar、standard.jar。语法： &lt;%@taglib prefix=&quot;&quot; uri=&quot;&quot; %&gt; uri 标签文件的URI地址 prefix 标签组的命名空间前缀 1&lt;%@taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c" %&gt; EL表达式EL表达式（Expression Language）是jsp的内置表达式语言，用来取代jsp中的Java代码，主要作用是获取域中的数据。 其作用为： 获取域中数据EL表达式主要用于替换JSP页面中的脚本表达式，以从各种类型的web域 中检索java对象、获取数据。(访问javabean属性、list集合、map集合等) 执行算数运算 获取web对象 调用Java方法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;%@ page language="Java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8" import="com.bean.User, java.util.*"%&gt;&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;my jsp&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 获取域中数据和算数运算 --&gt; &lt;% request.setAttribute("name", "linda"); User user1 = new User("linda1", "linda1"); User user2 = new User("linda2", "linda2"); User user3 = new User("linda3", "linda3"); List&lt;User&gt; users = new ArrayList(); users.add(user1); users.add(user2); users.add(user3); Map&lt;String, User&gt; maps = new HashMap(); maps.put("user1", user1); maps.put("user2", user2); maps.put("user3", user3); session.setAttribute("user1", user1); session.setAttribute("list", users); session.setAttribute("map", maps); %&gt; &lt;!-- 获取域中的字符串 --&gt; $&#123;name&#125; &lt;!-- 获取域中的实体bean属性 --&gt; $&#123;user1.name&#125; &lt;!-- 获取域中的list集合 --&gt; $&#123;list[0].name &#125; &lt;!-- 获取域中的map集合 --&gt; $&#123;map.user1.name &#125; &lt;!-- 算数运算 --&gt; $&#123;1+2-3*4/5&#125;&lt;/body&gt;&lt;/html&gt; JSTL标准标签库 JSTL(JSP Standard Tag Library，jsp标准标签库)是Apache对EL表达式的扩展，也就是说JSTL依赖EL表达式。JSTL是标签语言，使用起来非常方便。但是它不是jsp内置的标签，所以用的时候需要我们自己导包，以及指定标签库。 &lt;c:if test=&quot;&quot;&gt;取代页面中if条件语句 &lt;c:forEach items var begin varStatus&gt;取代页面中for循环 代码示例：1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;%@ page language="Java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8" import="com.bean.User,java.util.*"%&gt;&lt;%@taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c"%&gt;&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;my jsp&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;% User user1 = new User("linda1", "linda1"); User user2 = new User("linda2", "linda2"); User user3 = new User("linda3", "linda3"); List&lt;User&gt; users = new ArrayList(); users.add(user1); users.add(user2); users.add(user3); Map&lt;String, User&gt; maps = new HashMap(); session.setAttribute("list", users); %&gt; &lt;c:if test="$&#123;!empty list &#125;"&gt; $&#123;list &#125; &lt;/c:if&gt; &lt;br&gt; &lt;c:forEach items="$&#123;list &#125;" var="user" begin="0" varStatus="stu"&gt; $&#123;stu.index &#125; $&#123;stu.count &#125; $&#123;user &#125; &lt;br&gt; &lt;/c:forEach&gt; &lt;!-- items 属性 ： 结合el表达式从域中获取要遍历的集合 var 属性 ： 每遍历一次 获取的实体User的接收者 ， begin ：开始遍历的角标 从0 开始计数 varStatus 遍历者当前的状态 index 从0开始 count 计数 --&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>JSP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Xml解析及会话技术]]></title>
    <url>%2F2018%2F11%2F25%2FXml%E8%A7%A3%E6%9E%90%E5%8F%8A%E4%BC%9A%E8%AF%9D%E6%8A%80%E6%9C%AF%2F</url>
    <content type="text"><![CDATA[XML 指可扩展标记语言（EXtensible Markup Language），类似 HTML。XML 的设计宗旨是传输数据，而非显示数据。XML 标签没有被预定义，您需要自行定义标签。XML 广泛应用于框架的配置文件，如ssm。XML 不是 HTML 的替代，XML 和 HTML 为不同的目的而设计： XML 被设计为传输和存储数据，其焦点是数据的内容； HTML 被设计用来显示数据，其焦点是数据的外观。 XML解析123456789&lt;!--xml文件--&gt;&lt;books&gt; &lt;book&gt; &lt;author&gt;钱钟书&lt;/author&gt; &lt;name id="qzs"&gt;围城&lt;/name&gt; &lt;content&gt;人生是一座围城，城里的人想出去，城外的人想进来，工作生活莫不是如此。&lt;/content&gt; &lt;price&gt;30&lt;/price&gt; &lt;/book&gt;&lt;/books&gt; 12345678910111213141516171819202122//xml解析public static void main(String[] args) throws DocumentException &#123; // 创建一个解析器 SAXReader reader = new SAXReader(); // 获取代表文件的对象 Document document = reader.read("src/demo.xml"); // 获取根节点&lt;books&gt; Element root = document.getRootElement(); // 获取根节点下的子节点&lt;book&gt; Element book = root.element("book"); // 获取book节点下的 子节点 Element author = book.element("author"); Element name = book.element("name"); Element content = book.element("content"); // 获取name节点属性 Attribute attribute = name.attribute("id"); String id = attribute.getValue(); // System.out.println(id); // 获取content节点的文本 String cont = content.getText(); // System.out.println(cont);&#125; 模拟Spring管理对象1234567&lt;!--xml文件--&gt;&lt;beans&gt; &lt;bean id="servlet"&gt;com.web.UserServlet&lt;/bean&gt; &lt;bean id="service"&gt;com.service.UserService&lt;/bean&gt; &lt;bean id="dao"&gt;com.dao.UserDao&lt;/bean&gt; &lt;bean id="bean"&gt;com.bean.UserBean&lt;/bean&gt;&lt;/beans&gt; 模拟spring管理对象，借助他人管理对象，而非new一个对象。123456789101112131415161718192021// 模拟spring管理对象public static void main(String[] args) throws Exception &#123; Map&lt;String, Object&gt; map = new HashMap(); // 创建一个解析器 SAXReader reader = new SAXReader(); // 获取代表文件的对象 Document document = reader.read("src/application.xml"); // 获取根节点&lt;beans&gt; Element root = document.getRootElement(); // 获取所有子节点 List list = root.elements(); for (Object obj : list) &#123; Element e = (Element) obj; String name = e.attribute("id").getValue(); String className = e.getText(); // 获取实现类 Object instance = Class.forName(className).newInstance(); map.put(name, instance); &#125; System.out.println(map);&#125; 简单依赖管理xml文件12345&lt;!-- xml文件:servlet依赖于service和dao --&gt;&lt;bean id="servlet" class="com.web.UserServlet"&gt; &lt;property id="service"&gt;com.service.UserService&lt;/property&gt; &lt;property id="dao"&gt;com.dao.UserDao&lt;/property&gt;&lt;/bean&gt; 简单依赖管理，servlet依赖于service和dao，所以先创建service和dao，然后创建servlet，避免报错。12345678910111213141516171819202122// 简单依赖管理public static void main(String[] args) throws Exception &#123; Map&lt;String, Object&gt; map = new HashMap(); SAXReader reader = new SAXReader(); Document document = reader.read("src/bean.xml"); Element bean = document.getRootElement(); List list = bean.elements(); //servlet依赖于service和dao，所以先创建service和dao for (Object obj : list) &#123; Element e = (Element) obj; String key = e.attribute("id").getValue(); String className = e.getText(); Object instance = Class.forName(className).newInstance(); map.put(key, instance); &#125; //创建service和dao之后，创建Servlet String key = bean.attribute("id").getValue(); String className = bean.attribute("class").getValue(); Object instance = Class.forName(className).newInstance(); map.put(key, instance);&#125; Cookie public class Cookie Creates a cookie, a small amount of information sent by a servlet to a Web browser, saved by the browser, and later sent back to the server. A cookie’s value can uniquely identify a client, so cookies are commonly used for session management. A cookie has a name, a single value, and optional attributes such as a comment, path and domain qualifiers, a maximum age, and a version number. Some Web browsers have bugs in how they handle the optional attributes, so use them sparingly to improve the interoperability of your servlets. 创建cookie12345678//创建cookieCookie cookie = new Cookie("name", "linda");//设置路径cookie.setPath("/");//设置最大存活时间cookie.setMaxAge(60*60);//将cookie发送至浏览器response.addCookie(cookie); 获取本地cookie123456789101112//获取本地cookieCookie[] cookies = request.getCookies();//遍历cookieif(null!=cookies)&#123; for (Cookie cookie : cookies) &#123; String name = cookie.getName(); if("name".equals(name))&#123; String value = cookie.getValue(); response.getWriter().println(value); &#125; &#125;&#125; 访问时间案例将创建cookie与取出cookie放在一起，实现动态显示上次访问时间。12345678910111213141516171819202122232425// 创建当前访问时间cookie// 获取当前访问时间long currentTimeMillis = System.currentTimeMillis();String time = currentTimeMillis + "";// 创建cookieCookie cookie = new Cookie("time", time);// 将cookie发送至浏览器response.addCookie(cookie);// 获取本地cookieCookie[] cookies = request.getCookies();if (null != cookies) &#123; for (Cookie cookie2 : cookies) &#123; if ("time".equals(cookie2.getName())) &#123; String value = cookie2.getValue(); long parseLong = Long.parseLong(value); Date date = new Date(parseLong); @SuppressWarnings("deprecation") String localeString = date.toLocaleString(); response.getWriter().println("您上次访问的时间是：" + localeString); &#125; &#125;&#125; else &#123; response.getWriter().println("您是第一次访问");&#125; 解决cookie存放中文的问题将含有中文的cookie先以utf-8编码，然后再以utf-8解码取出。12345678910111213141516171819// 创建cookieString name = "琳达";// 将中文编码String nname = URLEncoder.encode(name, "UTF-8");Cookie cookie = new Cookie("name", nname);response.addCookie(cookie);// 从本地获取cookieCookie[] cookies = request.getCookies();if (null != cookies) &#123; for (Cookie cookie2 : cookies) &#123; if ("name".equals(cookie2.getName())) &#123; String value = cookie2.getValue(); //解码 String decode = URLDecoder.decode(value, "UTF-8"); response.getWriter().println(decode); &#125; &#125;&#125; HttpSession public abstract interface HttpSession Provides a way to identify a user across more than one page request or visit to a Web site and to store information about that user. The servlet container uses this interface to create a session between an HTTP client and an HTTP server. The session persists for a specified time period, across more than one connection or page request from the user. A session usually corresponds to one user, who may visit a site many times. The server can maintain a session in many ways such as using cookies or rewriting URLs. Session作为一个域对象，存储数据，作用范围一次会话 1234567891011121314151617// 获取Seesion，域对象，作用范围：一次会话HttpSession session = request.getSession();// 设置session最大存活时间session.setMaxInactiveInterval(60 * 60);// 向seesion中存数据session.setAttribute("name", "linda");session.setAttribute("gender", "woman");session.setAttribute("age", 18);// 移除数据// session.removeAttribute("age");// 遍历存入的数据Enumeration&lt;String&gt; names = session.getAttributeNames();while (names.hasMoreElements()) &#123; String name = names.nextElement(); Object value = session.getAttribute(name); System.out.println(name + "=" + value);&#125; 借助session改进登录案列登录时，先从session中取用户信息。 如果取到，说明在登录状态，页面跳转； 如果没有取到，说明session过期，或者没有登录，需要从数据库查询数据登录。 操作数据库登录成功后，将用户信息放在session中。 如果登录失败，页面跳转。 1234567891011121314151617181920212223242526// 获取session域对象HttpSession session = request.getSession();User user = (User) session.getAttribute("user");if (null == user) &#123;// user为空，表明没有未登录 try &#123; // 从数据库查询数据登录 // 接收页面参数 String name = request.getParameter("name"); String pwd = request.getParameter("pwd"); // 直接操作数据库登录 ComboPooledDataSource dataSource = new ComboPooledDataSource(); QueryRunner runner = new QueryRunner(dataSource); String sql = "select * from user2 where name=? and password=?"; User user2 = runner.query(sql, new BeanHandler&lt;User&gt;(User.class), name, pwd); if(null!=user2)&#123;//登录成功，页面跳转，并将参数存入session response.sendRedirect("/webday09/success.html"); session.setAttribute("user", user2); &#125;else&#123;//跳转登录失败页面 response.sendRedirect("/webday09/sorry.html"); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125;&#125;else&#123;//页面跳转，已登录状态 response.sendRedirect("/webday09/successing.html");&#125;]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>XML</tag>
        <tag>Cookie</tag>
        <tag>HttpSession</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Servlet应用小案例]]></title>
    <url>%2F2018%2F11%2F24%2FServlet%E5%BA%94%E7%94%A8%E5%B0%8F%E6%A1%88%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[转账案例开发环境准备：jar包、c3p0.properties、db.properties(MyDbUtil工具类) 步骤分析: html页面： form，action，method servlet： 接收参数，调用service service： 事务管理，调用dao dao： 操作数据库 Connection的两种传递方式： 作为参数传递：dao 从本地线程中传递 html转账页：form表单12 servlet：接收参数，调用service12345678910111213141516171819202122232425262728293031public class Transfer extends HttpServlet &#123; private static final long serialVersionUID = 1L; // 调用UserService // UserService service = new UserService(); UserService2 service = new UserService2(); protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; request.setCharacterEncoding("UTF-8"); response.setCharacterEncoding("UTF-8"); response.setContentType("text/html; charset=UTF-8"); // 转账 try &#123; // 接收页面参数 String from = request.getParameter("from"); String to = request.getParameter("to"); String money = request.getParameter("money"); int i = service.transfer(from, to, money); if (i == 1) &#123; response.sendRedirect("/webday08/success.html"); // System.out.println("转账成功"); &#125; else &#123; response.sendRedirect("/webday08/sorry.html"); // System.out.println("转账失败"); &#125; &#125; catch (SQLException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125;&#125; service：事务管理，调用dao1234567891011121314151617181920212223242526272829public class UserService2 &#123; UserDao2 dao = new UserDao2(); /** * 转账服务 * @param from 付款人 * @param to 收款人 * @param money 金额 * @return 状态码，1表示转账成功，0表示转账失败 * @throws SQLException */ public int transfer(String from, String to, String money) throws SQLException&#123; Connection connection = MyDbUtil2.getConnection(); //开启事务 connection.setAutoCommit(false); //付款 int i = dao.payMoney(to, money); //bug //int a = 1/0; //收款 int j = dao.receMoney(from, money); //提交事务 connection.commit(); return i&amp;j; &#125;&#125; dao：操作数据库1234567891011121314151617181920212223public class UserDao2 &#123; public int payMoney(String to, String money) throws SQLException&#123; Connection connection = MyDbUtil2.getConnection(); //付款，执行SQL语句 String sql = "update user set money = money-? where name=?"; PreparedStatement statement = connection.prepareStatement(sql); statement.setString(1, money); statement.setString(2, to); int i = statement.executeUpdate(); return i; &#125; public int receMoney(String from, String money) throws SQLException&#123; Connection connection = MyDbUtil2.getConnection(); //收款，执行SQL语句 String sql = "update user set money = money+? where name=?"; PreparedStatement statement = connection.prepareStatement(sql); statement.setString(1, money); statement.setString(2, from); int j = statement.executeUpdate(); return j; &#125;&#125; MyDbUtil：获取连接的工具类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566public class MyDbUtil2 &#123; static String url = null; static String name = null; static String password = null; // 静态表代码块:加载配置文件，注册驱动 static &#123; // 加载配置文件 ResourceBundle bundle = ResourceBundle.getBundle("db"); String driverClass = bundle.getString("driverClass"); url = bundle.getString("url"); name = bundle.getString("name"); password = bundle.getString("password"); // 注册驱动 try &#123; Class.forName(driverClass); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; /** * 从本地线程中获取连接 * * @return 连接 * @throws SQLException * 数据库异常 */ static ThreadLocal&lt;Connection&gt; thread = new ThreadLocal&lt;&gt;(); public static Connection getConnection() throws SQLException &#123; //可理解为一个本地线程连接池 Connection connection = thread.get(); if(connection == null)&#123; connection = DriverManager.getConnection(url, name, password); thread.set(connection); &#125; return connection; &#125; /** * 释放资源 * * @param connection * 连接 * @param statement * 发送执行sql语句的对象 * @param resultSet * 查询返回的结果集 */ public static void release(Connection connection, Statement statement, ResultSet resultSet) &#123; try &#123; if (null != resultSet) &#123; resultSet.close(); &#125; if (null != statement) &#123; statement.close(); &#125; if (null != connection) &#123; connection.close(); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 查询商品案列查询页面1234567891011121314&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="UTF-8"&gt;&lt;title&gt;Search&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;Search Product&lt;/h1&gt; &lt;form action="/webday08/Search" method="get"&gt; &lt;input type="text" name="keywords"&gt; &lt;button type="submit"&gt;Search&lt;/button&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; servlet：获取页面参数，调用service1234567891011121314151617181920212223242526public class Search extends HttpServlet &#123; private static final long serialVersionUID = 1L; SearchService service = new SearchService(); protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; request.setCharacterEncoding("UTF-8"); response.setCharacterEncoding("UTF-8"); response.setContentType("text/html; charset=UTF-8"); try &#123; // 接收页面参数 String keywords = request.getParameter("keywords"); // 调用service if ("".equals(keywords)) &#123; List&lt;Product&gt; products = service.SearchAllProducts(); response.getWriter().write(products.toString()); &#125;else&#123; List&lt;Product&gt; products = service.SearchProductsLikeName(keywords); response.getWriter().write(products.toString()); &#125; &#125; catch (SQLException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125;&#125; service:查询事务管理，调用dao1234567891011121314public class SearchService &#123; SearchDao dao = new SearchDao(); //查询所有商品 public List&lt;Product&gt; SearchAllProducts() throws SQLException&#123; List&lt;Product&gt; products = dao.SearchAllProducts(); return products; &#125; //查询含有关键词的商品，条件模糊查询 public List&lt;Product&gt; SearchProductsLikeName(String keywords) throws SQLException&#123; List&lt;Product&gt; products = dao.SearchProductsLikeName(keywords); return products; &#125;&#125; dao:操作数据库1234567891011121314151617181920public class SearchDao &#123; //查询所有 public List&lt;Product&gt; SearchAllProducts() throws SQLException&#123; ComboPooledDataSource dataSource = new ComboPooledDataSource(); QueryRunner runner = new QueryRunner(dataSource); String sql = "select * from product"; List&lt;Product&gt; list = runner.query(sql, new BeanListHandler&lt;Product&gt;(Product.class)); return list; &#125; //条件模糊查询 public List&lt;Product&gt; SearchProductsLikeName(String keywords) throws SQLException&#123; ComboPooledDataSource dataSource = new ComboPooledDataSource(); QueryRunner runner = new QueryRunner(dataSource); String sql = "select * from product where name like ?"; String nkeywords = "%"+keywords+"%"; List&lt;Product&gt; list = runner.query(sql, new BeanListHandler&lt;Product&gt;(Product.class), nkeywords); return list; &#125;&#125; 面向接口编程面向对象编程： 类：属性（数据）和方法 找对象--&gt;类的实例 --&gt;打点调方法 面向接口编程： 接口--&gt;多态--&gt;一种事物的多种表现形式 左边接口 右边实现类 面向接口解耦合接口UserDao12345package com.ou;public interface UserDao &#123; public void test();&#125; 实现类UserDaoImpl11234567package com.ou;public class UserDaoImpl1 implements UserDao &#123; public void test() &#123; System.out.println("UserDaoImpl1"); &#125;&#125; 实现类UserDaoImpl21234567package com.ou;public class UserDaoImpl2 implements UserDao &#123; public void test() &#123; System.out.println("UserDaoImpl2"); &#125;&#125; 配置文件1userdao=com.ou.UserDaoImpl2 演示实例1234567891011121314151617181920public static void main(String[] args) &#123; try &#123; //加载配置文件 InputStream in = MyTest.class.getClassLoader().getResourceAsStream("dao.properties"); Properties p = new Properties(); p.load(in); //获取类名称 String className = p.getProperty("userdao"); //左边接口，右边实现类 //UserDao userdao = new UserDaoImpl1(); //实现dao解耦合：修改配置文件可以改变实现类，然后创建实例 UserDao userdao = (UserDao) Class.forName(className).newInstance(); //调用实现类方法 userdao.test(); &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125;&#125; 登录案列：接口+三层代码分离Servlet：接收页面参数，调用service12345678910111213141516171819202122public class Login extends HttpServlet &#123; private static final long serialVersionUID = 1L; LoginService service = new LoginServiceImpl(); protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; request.setCharacterEncoding("UTF-8"); response.setCharacterEncoding("UTF-8"); response.setContentType("text/html; charset=UTF-8"); try &#123; //接收页面参数 String name = request.getParameter("name"); String pwd = request.getParameter("pwd"); //调用service User user = service.login(name, pwd); System.out.println(user); &#125; catch (SQLException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125;&#125; Service: 事务管理，调用daoService接口123public interface LoginService &#123; public User login(String name, String pwd) throws SQLException;&#125; Service实现类12345678public class LoginServiceImpl implements LoginService &#123; LoginDao dao = new LoginDaoImpl(); public User login(String name, String pwd) throws SQLException &#123; User user = dao.login(name, pwd); return user; &#125;&#125; Dao: 操作数据库Dao接口123public interface LoginDao &#123; public User login(String name, String pwd) throws SQLException;&#125; Dao实现类123456789public class LoginDaoImpl implements LoginDao &#123; public User login(String name, String pwd) throws SQLException &#123; ComboPooledDataSource dataSource = new ComboPooledDataSource(); QueryRunner runner = new QueryRunner(dataSource); String sql = "select * from user2 where name=? and password=?"; User user = runner.query(sql, new BeanHandler&lt;User&gt;(User.class), name, pwd); return user; &#125;&#125;]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>Application</tag>
        <tag>Servlet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Servlet]]></title>
    <url>%2F2018%2F11%2F22%2FServlet%2F</url>
    <content type="text"><![CDATA[servlet是一个运行在web服务上的java程序。servlet通常通过HTTP协议，接收并响应来自Web客户端的请求。在用Eclipse进行web开发时，默认创建的Servlet有很多注释，不够简洁，可以在Eclipse中添加Servlet模板。 详见教程:Eclipse for JavaEE中修改Servlet新建模板 注册案例分析初级代码12345678910111213141516171819try &#123; //接收页面参数 String username = request.getParameter("username"); String password = request.getParameter("pwd"); //操作数据 ComboPooledDataSource dataSource = new ComboPooledDataSource(); QueryRunner runner = new QueryRunner(dataSource); String sql = "INSERT INTO user2 VALUES(null,?,?)"; int i = runner.update(sql, username,password); //页面跳转 if(i == 1)&#123;//注册成功跳转登录页面 response.sendRedirect("/webday07/login.html"); &#125;else&#123;//注册不成功跳转注册页面 response.sendRedirect("/webday07/register.html"); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace();&#125; 三层代码分离代码分离步骤分析及代码示例： Servlet 接收页面参数，处理请求–&gt;调用 Service：new UserService().register（参数） Service 处理事务：register（参数）–&gt;调用dao：new UserDao.addUser（参数） Dao 执行sql语句: addUser（参数）–&gt;执行sql语句 Servlet 接收页面参数，处理请求123456789101112131415161718192021try &#123; request.setCharacterEncoding("UTF-8"); //接收页面参数 String username = request.getParameter("username"); String password = request.getParameter("pwd"); User user = new User(); user.setName(username); user.setPassword(password); //操作数据 //int i = dao.addUser(user); int i = service.register(user); //页面跳转 if(i == 1)&#123;//注册成功跳转登录页面 response.sendRedirect("/webday07/login.html"); &#125;else&#123;//注册不成功跳转注册页面 response.sendRedirect("/webday07/register.html"); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace();&#125; 1234567request.setCharacterEncoding("UTF-8");String from = "mike";String to = "marry";int money = 1000;// 转账int i = userService.trans(from, to, money); Service 处理事务123456789101112131415161718192021//转账，收付款public class UserService &#123; UserDao dao = new UserDao(); public int trans(String from, String to ,int money)&#123; //开启事务 //收款 int receMoney = dao.receMoney(from, money); //付款 int payMoney = dao.payMoney(to, receMoney); return 1; //提交事务 &#125; //register public int register(User user) throws SQLException&#123; return dao.addUser(user); &#125;&#125; Dao 执行sql语句12345678910111213141516171819202122public class UserDao &#123; public int addUser(User user) throws SQLException &#123; // 操作数据 ComboPooledDataSource dataSource = new ComboPooledDataSource(); QueryRunner runner = new QueryRunner(dataSource); String sql = "INSERT INTO user2 VALUES(null,?,?)"; int i = runner.update(sql, user.getName(), user.getPassword()); return i; &#125; // 收款 public int receMoney(String from, int money) &#123; return 1; &#125; // 付款 public int payMoney(String to, int money) &#123; return 1; &#125;&#125; Servlet生命周期 发送请求 解析请求: web.xml-&gt;url-&gt;name-&gt;class 实例化，反射 初始化，调用init（）方法，调用1次 服务，调用service（）方法 返回响应信息 销毁，调用destroy（）方法，Servlet正常关闭时调用 如下图所示： ServletConfigServletConfig这个对象在 Servlet 初始化时就传给 Servlet，所以从servlet对象中去取。123456789101112&lt;!-- 初始化参数配置 web.xml中配置 --&gt;&lt;servlet&gt; &lt;description&gt;&lt;/description&gt; &lt;display-name&gt;ConfigObj&lt;/display-name&gt; &lt;servlet-name&gt;ConfigObj&lt;/servlet-name&gt; &lt;servlet-class&gt;com.demo.ConfigObj&lt;/servlet-class&gt; &lt;!-- 初始化参数 --&gt; &lt;init-param&gt; &lt;param-name&gt;name&lt;/param-name&gt; &lt;param-value&gt;lili&lt;/param-value&gt; &lt;/init-param&gt;&lt;/servlet&gt; 12345678910protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; // 获取ServletConfig对象 ServletConfig servletConfig = this.getServletConfig(); //获取初始化参数名，枚举 Enumeration&lt;String&gt; inits = servletConfig.getInitParameterNames(); String nextElement = inits.nextElement(); //获取初始化参数对应的值 String initParameter = servletConfig.getInitParameter(nextElement); System.out.println(nextElement+"---"+initParameter);&#125; ServletContextServletContext对象是Servlet三大（域）对象之一，每个Web应用程序都只有一个ServletContext对象，该对象是Web应用程序的全局对象，可以在整个Web应用中共享数据资源。Tomcat服务器在启动时，会自动创建一个ServletContext对象（域）。在关闭时，会自动销毁这个ServletContext对象。 ServletContext对象的作用 获取全局的初始化参数 实现整个web应用程序中多个servlet之间的数据共享 实现转发:一般使用request对象来转发 获取文件的真实路径和项目名（路径），web项目中文件的真实路径有三种: 第一种，src目录下的文件(src下的代码都在/WEB-INF/classes/目录下)，如/WEB-INF/classes/db.properties 第二种，WebContent目录下的文件(默认在根目录下)，如/db.properties 第三种，WEB-INF目录下的文件，如/WEB-INF/db.properties 获取全局初始化参数1234567&lt;/welcome-file-list&gt;&lt;!-- 全局初始化参数 --&gt;&lt;context-param&gt; &lt;param-name&gt;content&lt;/param-name&gt; &lt;param-value&gt;servletContext&lt;/param-value&gt;&lt;/context-param&gt;&lt;servlet&gt; 1234567// 获取context对象ServletContext context = this.getServletContext();// 获取全局初始化参数Enumeration&lt;String&gt; names = context.getInitParameterNames();String name = names.nextElement();String value = context.getInitParameter(name);System.out.println(name+"---"+value);//content---servletContext 全局共享数据全局域对象context，实现整个web项目中多个servlet之间的数据共享（application域）。 12345// 全局数据共享，域，范围，整个web项目，存储数据context.setAttribute("name", "zsx");// 获取域中的数据value = (String) context.getAttribute("name");System.out.println(value);//zsx 转发和重定向 转发：服务器内部的行为，1次请求，url不变，携带request。 重定向：2次请求，地址栏改变，不携带request。 url需要加项目名。 代码示例如下： 1234// 转发context.getRequestDispatcher("/hello.html").forward(request,response);// 重定向response.sendRedirect("/webday07/hello.html"); 获取文件真实路径及项目名1234567891011121314151617// 获取文件的真实路径 、输入流 、读取内容// src目录下的文件String path1 = context.getRealPath("/WEB-INF/classes/dbcp.properties");// WebContent目录下的文件String path2 = context.getRealPath("/dbcp.properties");// WEB-INF目录下的文件String path3 = context.getRealPath("/WEB-INF/dbcp.properties");System.out.println(path1);// 通过真实路径获取输入流FileInputStream fileInputStream = new FileInputStream(new File(path1));// 直接获取输入流InputStream in = context.getResourceAsStream("/WEB-INF/classes/dbcp.properties");// 获取项目名String contextPath = context.getContextPath();// System.out.println(contextPath);// /webday07 HttpServletRequestGET乱码问题12345678910111213protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; // TODO Auto-generated method stub response.getWriter().append("Served at: ").append(request.getContextPath()); request.setCharacterEncoding("UTF-8");//只针对POST乱码问题 response.setCharacterEncoding("UTF-8"); response.setContentType("text/html; charset=UTF-8"); //GET乱码问题 String name = request.getParameter("name"); //解码 byte[] bytes = name.getBytes("iso8859-1"); //编码 String nname = new String(bytes,"utf-8");&#125; 接收页面参数1234567891011121314151617181920212223242526//接收页面参数try &#123; //接收单个参数 String email = request.getParameter("email"); //System.out.println(email); //接收多个参数 String[] hobby = request.getParameterValues("hobby"); /* * for (String string : hobby) &#123; System.out.println(string); &#125; */ //接收一个map对象 MyUser user = new MyUser(); Map&lt;String, String[]&gt; map = request.getParameterMap(); Set&lt;Entry&lt;String, String[]&gt;&gt; entrySet = map.entrySet(); /* * for (Entry&lt;String, String[]&gt; entry : entrySet) &#123; String key = * entry.getKey(); String[] value = entry.getValue(); * System.out.println(key+"---"+value); &#125; */ //需要jar包：commons-beanutils-1.8.3.jar|commons-logging-1.1.1.jar BeanUtils.populate(user,map); //System.out.println(user);&#125; catch (Exception e) &#123; e.printStackTrace();&#125; 作为一个域对象，作用范围一次请求1234//作为一个域对象，作用范围一次请求request.setAttribute("name", "linda");//向域中存储数据String value = (String)request.getAttribute("name");//从域中取数据//System.out.println(value);//linda 转发转发的特点： url不变； 一次请求； 服务器内部的行为； 携带request域中的数据； WEB-INF受保护，但转发可以访问。 重定向的特点： 两次请求； 地址栏改变； 不携带request域中的数据； 无法访问WEB-INF中的文件。 1234//转发，转发会携带request域中的数据request.getRequestDispatcher("/Demo").forward(request, response);//request.getRequestDispatcher("/WEB-INF/hello.html").forward(request, response);//response.sendRedirect("/webday08/WEB-INF/hello.html");//404 获取项目名与context对象相似。123//获取项目名String contextPath = request.getContextPath();System.out.println(contextPath);// /webday08 HttpServletResponse 重定向 指定页面 url 状态码302 + location地址 写一个页面–&gt;响应–&gt;浏览器 html 字符流 图片 io 字节流 响应字节流和字符流不能同时使用，两个方法互斥 代码示例：123456// 字符流响应// response.getWriter().write("&lt;h1&gt;hello&lt;/h1&gt;");// sresponse.getWriter().write("&lt;h1&gt;你好&lt;/h1&gt;");// 字节流响应response.getOutputStream().write("你好".getBytes());]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>Servlet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tomcat]]></title>
    <url>%2F2018%2F11%2F21%2FTomcat%2F</url>
    <content type="text"><![CDATA[Tomcat服务器目前最为流行的web服务器，Tomcat服务器是Apache-Jarkarta开源项目中的一个子项目，是一个小型、轻量级的支持JSP和Servlet技术的Web服务器，也是初学者学习开发JSP应用的首选。 Tomcat下载Tomcat下载链接：Tomcat官方下载 Tomcat有安装版和解压版（绿色版） 安装版，以.exe形式的安装包，双击安装到电脑上，用的比较少。 解压版，即绿色版，解压后直接使用，用的比较多。 Tomcat在eclipse中发布web项目 添加服务器运行环境 Window/Preferences/Server/Runtime Environmen/Add/Apache Tomcat v8.0 设置服务器安装目录 D:\tool\apache-tomcat-8.0.53 显示服务器 Window/Show View/Other/Server/Servers 修改Tomcat发布位置 双击Tomcat v8.0 Server at localhost/Use Tomcat installtion 创建web项目 New/Project/Web/Dynamic Web Project/项目名称/Dynamic web module version 改为2.5 右击Tomcat v8.0 Server at localhost/Add and Remove/添加上面建立的项目 用户登录应用实例 HTML登录页面。包括form action method 创建服务器。接收页面的参数：name，passsword 查询数据库。拿到表单中的输入数据后，去数据库中查询。有数据 ，则登录成功，否则失败 跳转页面。登录成功跳转登录成功页面，登录失败则跳转登录页面 登录成功页面HTML 核心代码：12345678910111213141516171819202122protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; try &#123; // 接收页面参数 String username = request.getParameter("username"); String pwd = request.getParameter("pwd"); // 操作数据库 ，jar:驱动|c3p0|pool|dbutils ComboPooledDataSource dataSource = new ComboPooledDataSource(); QueryRunner runner = new QueryRunner(dataSource); String sql = "select * from user2 where name=? and password=?"; User user = runner.query(sql, new BeanHandler&lt;User&gt;(User.class), username, pwd); if (null != user) &#123;// 不为空表明登录成功 response.sendRedirect("/webday06/hello.html"); &#125; else &#123; response.sendRedirect("/webday06/login.html"); &#125; &#125; catch (SQLException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125;&#125; 登录页面:123456789101112131415&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="UTF-8"&gt;&lt;title&gt;Login&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;登录页面&lt;/h1&gt; &lt;form action="/webday06/MyServlet" method="get"&gt; 用户名：&lt;input type="text" name="username"&gt; &lt;br/&gt; 密码：&lt;input type="password" name="pwd"&gt; &lt;br/&gt; &lt;input type="submit" value="登录"&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 登录成功页面:1234567891011121314&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="UTF-8"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;winter is coming!&lt;/h1&gt; &lt;p&gt; 目前最为流行的Tomcat服务器是Apache-Jarkarta开源项目中的一个子项目， 是一个小型、轻量级的支持JSP和Servlet 技术的Web服务器，也是初学者学习开发JSP应用的首选。 &lt;/p&gt;&lt;/body&gt;&lt;/html&gt; User:1234567891011121314151617181920212223242526public class User &#123; private String name; private String password; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; @Override public String toString() &#123; return "User [name=" + name + ", password=" + password + "]"; &#125;&#125;]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>Tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C3p0及事务]]></title>
    <url>%2F2018%2F11%2F20%2Fc3p0%E5%8F%8A%E4%BA%8B%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[C3p0导入jar包c3p0-0.9.1.2.jar commons-dbutils-1.4.jar commons-pool-1.5.6.jar mysql-connector-java-5.0.4-bin.jar 配置文件123456// 文件名 c3p0.properties// 配置文件在src下，也可以建立Source Folderc3p0.driverClass=com.mysql.jdbc.Driverc3p0.jdbcUrl=jdbc:mysql:///mydb1?characterEncoding=UTF-8c3p0.user=rootc3p0.password=root C3p0代码示例123456789101112public class Demo1 &#123; public static void main(String[] args) throws SQLException &#123; //获取数据库连接池对象 ComboPooledDataSource dataSource = new ComboPooledDataSource(); //创建工具类，参数：数据库连接池对象 QueryRunner runner = new QueryRunner(dataSource); //执行sql语句 封装结果集 String sql = "select * from user"; List&lt;User&gt; query = runner.query(sql, new BeanListHandler&lt;User&gt;(User.class)); System.out.println(query); &#125;&#125; 结果集的实际映射是根据sql语句来进行映射的，不是按照表中原有名称进行映射的。代码示例如下： 12345678910select uid 'id',NAME 'name' from user--返回结果id name1 tom2 fox-- 原表useruid NAME1 tom2 fox 条件查询123456789101112public class Demo2 &#123; public static void main(String[] args) throws SQLException &#123; //获取数据库连接池对象 ComboPooledDataSource dataSource = new ComboPooledDataSource(); //创建工具类，参数：数据库连接池对象 QueryRunner runner = new QueryRunner(dataSource); //执行sql语句，返回查询结果 String sql = "select * from user where uid=? and name=?"; User query = runner.query(sql, new BeanHandler&lt;User&gt;(User.class), 1,"tom"); System.out.println(query); &#125;&#125; 事务 一致性：事务中的SQL语句要么同时执行，要么都不执行。如代码示例中的价格一増一减，保持总和不变；如果中途出错，则都不变。 持久性：事务中的数据提交之后，可以持久存储查询。 原子性：不可再分。 隔离性：互不影响，避免混淆。 代码示例：12345678910111213141516171819202122232425262728293031323334public class Demo3 &#123; // 事务 public static void main(String[] args) throws SQLException &#123; Connection connection = null; PreparedStatement statement = null; try &#123; connection = MyDbUtil.getConnection(); // 事务的开启：关闭mysql的事务自动提交 connection.setAutoCommit(false); // 上海减1000 String sql1 = "update orders set money=money+1000 where id=2 "; statement = connection.prepareStatement(sql1); statement.executeUpdate(); // bug // int i = 1/0; // 广州加1000 String sql2 = "update orders set money=money-1000 where id=3 "; statement = connection.prepareStatement(sql2); statement.executeUpdate(); // 事务的关闭 connection.commit(); &#125; catch (SQLException e) &#123; // 回滚 connection.rollback(); e.printStackTrace(); &#125; &#125;&#125;]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>c3p0</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库连接池]]></title>
    <url>%2F2018%2F11%2F19%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0%2F</url>
    <content type="text"><![CDATA[数据库连接池数据库连接池（Data Base Connection Pooling，简称DBCP）是程序启动时建立足够的数据库连接，并将这些连接组成一个连接池，由程序动态地对池中的连接进行申请，使用，释放。优点： 节省创建连接与释放连接的性能消耗 连接池中连接起到复用的作用，提高程序性能 数据库连接池的运行机制： 程序初始化时，创建连接池 使用时，向连接池申请可用连接 使用完毕，将连接返还给连接池 程序退出时，断开所有连接，并释放资源 数据库连接池的使用首先，导入jar包： commons-dbcp-1.4.jar commons-pool-1.5.6.jar mysql-connector-java-5.0.4-bin.jar 手动方式12345678910111213141516171819202122232425public class Demo1 &#123;//手动方式 public static void main(String[] args) throws SQLException &#123; // 获取数据库连接池对象 BasicDataSource basicDataSource = new BasicDataSource(); // 设置四大参数 basicDataSource.setDriverClassName("com.mysql.jdbc.Driver"); basicDataSource.setUrl("jdbc:mysql://localhost:3306/mydb"); basicDataSource.setUsername("root"); basicDataSource.setPassword("zsx"); // 获取连接 Connection connection = basicDataSource.getConnection(); // 获取发送执行sql语句的PreparedStatement String sql = "select * from user"; PreparedStatement statement = connection.prepareStatement(sql); // 执行sql语句，如果是查询返回结果集 ResultSet resultSet = statement.executeQuery(); // 遍历查询返回的结果集 while (resultSet.next()) &#123; System.out.println(resultSet.getString("uid")); System.out.println(resultSet.getString("NAME")); &#125; &#125;&#125; 半自动方式配置文件123456// 文件名 dbcp.properties// 配置文件在src下，key不能改driverClassName=com.mysql.jdbc.Driverurl=jdbc:mysql://localhost:3306/mydb?characterEncoding=UTF-8username=rootpassword=zsx 1234567891011121314151617181920212223242526public class Demo2 &#123; // 半自动方式 public static void main(String[] args) throws Exception &#123; //获取数据库连接工厂对象 BasicDataSourceFactory basicDataSourceFactory = new BasicDataSourceFactory(); //加载配置文件 FileInputStream inputStream = new FileInputStream(new File("src/dbcp.properties")); Properties p = new Properties(); p.load(inputStream); //创建数据源 DataSource dataSource = basicDataSourceFactory.createDataSource(p); //获取连接 Connection connection = dataSource.getConnection(); // 获取发送执行sql语句的PreparedStatement String sql = "select * from user"; PreparedStatement statement = connection.prepareStatement(sql); // 执行sql语句，如果是查询返回结果集 ResultSet resultSet = statement.executeQuery(); // 遍历查询返回的结果集 while (resultSet.next()) &#123; System.out.println(resultSet.getString("uid")); System.out.println(resultSet.getString("NAME")); &#125; &#125;&#125;]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>DBCP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JDBC快速入门]]></title>
    <url>%2F2018%2F11%2F17%2FJDBC%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[JDBC（Java Data Base Connectivity，java数据库连接）是一种用于执行SQL语句的Java API，可以为多种关系数据库提供统一访问，它由一组用Java语言编写的类和接口组成。JDBC提供了一种基准，据此可以构建更高级的工具和接口，使数据库开发人员能够编写数据库应用程序。 JDBC的组成包：java.sql. ，javax.sql.，这两个包都包含在了JDK中。还需要数据库的驱动，这些驱动就相当于对JDBC规范的实现。 JDBC入门程序JDBC创建流程 创建一个java项目 导入mysql的数据库驱动jar包： 新建文件lib-&gt;将mysql-connector-java-5.0.4-bin.jar包粘贴到lib文件夹 -&gt;右击Bulid Path-&gt;Add To Bulid Path 注册驱动 建立与数据库的连接 获取发送和执行SQL语句的对象 Statement 执行SQL语句，获取查询结果集 如果执行的是查询语句，则遍历查询结果集 关闭资源 初级代码示例1234567891011121314151617181920212223242526public class JdbcDemo1 &#123; public static void main(String[] args) throws Exception &#123; //注册驱动 //DriverManager.registerDriver(new Driver());//两次注册 Class.forName("com.mysql.jdbc.Driver"); //建立连接 String url = "jdbc:mysql://localhost:3306/mydb"; String user = "root"; String password = "zsx"; Connection connection = DriverManager.getConnection(url, user, password); //获取发送执行sql语句的对象statement Statement statement = connection.createStatement(); //发送执行sql语句，返回查询结果 String sql = "select * from user";//查询 ResultSet resultSet = statement.executeQuery(sql); //如果是查询，需要遍历查询结果 while(resultSet.next())&#123; System.out.println(resultSet.getString(1)); //uid System.out.println(resultSet.getString(2)); //NAME &#125; //关闭资源 resultSet.close(); statement.close(); connection.close(); &#125;&#125; 更新代码示例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667public class JdbcDemo2 &#123; /** * 修订jdbc入门程序 * 1. 驱动注册两次问题：Class.forName() * 2. 四大参数硬编码问题 ：加载配置文件 * 3. 释放资源：异常处理 * 异常不能正常关系 * * @param args */ public static void main(String[] args) &#123; String driverClass = null; String url = null; String name = null; String password = null; // 加载配置文件 try &#123; Properties p = new Properties(); String conf = "C:/Users/Administrator/Desktop/code/JDBC/config/db.properties"; p.load(new FileReader(conf)); driverClass = p.getProperty("driverClass"); url = p.getProperty("url"); name = p.getProperty("name"); password = p.getProperty("password"); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; Connection connection = null; Statement statement = null; ResultSet resultSet = null; try &#123; // 1.注册驱动 Class.forName(driverClass); // 2.建立连接 connection = DriverManager.getConnection(url, name, password); // 3.获取发送执行sql语句的statement对象 statement = connection.createStatement(); // 4.执行sql语句 String sql = "select * from user";// 查询 statement.executeQuery(sql); // 5.如果是查询，返回查询结果集，并遍历结果集 resultSet = statement.getResultSet(); while (resultSet.next()) &#123; System.out.println(resultSet.getString("uid")); System.out.println(resultSet.getString("NAME")); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; // 6.关闭资源 try &#123; if (null != resultSet) &#123; resultSet.close(); &#125; if (null != statement) &#123; statement.close(); &#125; if (null != connection) &#123; connection.close(); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 读取配置文件12345678910111213141516171819202122public class GetProperties &#123; /** * 加载.properties配置文件的方法（相对路径） * * @param args * @throws IOException */ public static void main(String[] args) throws IOException &#123; /* * //1. 获取类加载器 获取文件的输入流 * InputStream in = GetProperties.class.getClassLoader().getResourceAsStream("db.properties"); * Properties p = new Properties(); * p.load(in); String * url = p.getProperty("url"); System.out.println(url); */ // 2. ResourceBundle 加载文件 参数文件的基名(不加文件后缀) ResourceBundle bundle = ResourceBundle.getBundle("db"); String url = bundle.getString("url"); System.out.println(url); &#125;&#125; 封装工具类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public class MyDbUtil &#123; static String url = null; static String name = null; static String password = null; // 静态表代码块:加载配置文件，注册驱动 static &#123; // 加载配置文件 ResourceBundle bundle = ResourceBundle.getBundle("db"); String driverClass = bundle.getString("driverClass"); url = bundle.getString("url"); name = bundle.getString("name"); password = bundle.getString("password"); // 注册驱动 try &#123; Class.forName(driverClass); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; /** * 与数据库建立连接 * * @return 连接 * @throws SQLException * 数据库异常 */ public static Connection getConnection() throws SQLException &#123; return DriverManager.getConnection(url, name, password); &#125; /** * 释放资源 * * @param connection * 连接 * @param statement * 发送执行sql语句的对象 * @param resultSet * 查询返回的结果集 */ public static void release(Connection connection, Statement statement, ResultSet resultSet) &#123; try &#123; if (null != resultSet) &#123; resultSet.close(); &#125; if (null != statement) &#123; statement.close(); &#125; if (null != connection) &#123; connection.close(); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 单元测试123456789101112public class MyTest &#123; @Before public void hello() &#123; System.out.println("before"); &#125; @Test public void test() &#123; System.out.println("test"); &#125;&#125; 测试工具类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566public class TestUtil &#123; Connection connection = null; Statement statement = null; /** * 初始化 * * @throws SQLException */ @Before public void init() throws SQLException &#123; // 建立连接 connection = MyDbUtil.getConnection(); // 获取发送执行sql语句的statement对象 statement = connection.createStatement(); &#125; /** * 操作数据：查询、增加、删除 */ @Test public void add() &#123; try &#123; // 执行sql String sql = "select * from user"; // String sql = "insert into user values(3, 'jack')"; // String sql = "delete from user where uid=3"; ResultSet resultSet = statement.executeQuery(sql); // statement.executeUpdate(sql); // 处理查询返回的结果集，对结果进行封装 ArrayList&lt;User&gt; userList = new ArrayList&lt;&gt;(); while (resultSet.next()) &#123; // System.out.println(resultSet.getString("uid")); // System.out.println(resultSet.getString("NAME")); User user = new User(); user.setUid(resultSet.getString("uid")); user.setName(resultSet.getString("Name")); userList.add(user); &#125; System.out.println(userList); // 释放资源 MyDbUtil.release(connection, statement, null); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; /** * prepareStatement * 1. 有缓存区，所以效率更高 * 2. 有缓存区，更安全，防止sql注入(1=1) * @throws SQLException */ @Test public void testPre() throws SQLException &#123; Connection conn = MyDbUtil.getConnection(); String sql = "select * from user where uid = ? and NAME = ?"; PreparedStatement ps = conn.prepareStatement(sql); ps.setString(1, "1"); ps.setString(2, "tom"); ResultSet resultSet = ps.executeQuery(); System.out.println(resultSet); &#125;&#125; 创建的User对象如下：1234567891011121314151617181920212223242526public class User &#123; private String uid; private String name; public String getUid() &#123; return uid; &#125; public void setUid(String uid) &#123; this.uid = uid; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; this.name = name; &#125; @Override public String toString() &#123; return "User [uid=" + uid + ", name=" + name + "]"; &#125;&#125; 中文乱码解决办法：1url=jdbc:mysql://localhost:3306/mydb?characterEncoding=utf8 常用对象：类或接口 DriverManger： 注册驱动； 获取与数据库的链接 Connection： 获取发送执行sql语句的statement对象 Statement： 向数据库发送并执行具体的SQL语句 PreparedStatement： 需要预编译以及需要参数； 有缓存区，效率更高； 有缓存区，更安全，防止了sql注入（1=1）； 语句中的参数可以使用占位符(?)。]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>JDBC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[北京主要景点参观指南]]></title>
    <url>%2F2018%2F11%2F16%2F%E5%8C%97%E4%BA%AC%E4%B8%BB%E8%A6%81%E6%99%AF%E7%82%B9%E5%8F%82%E8%A7%82%E6%8C%87%E5%8D%97%2F</url>
    <content type="text"><![CDATA[景点：开放时间，参观耗时门票，交通 住宿：酒店，民宿（适合人多） 注意事项：交通方式，北京特产，其他 北京主要景点清单 天安门：毛主席纪念堂、天安门城楼、故宫、人民大会堂、中国国家博物馆 故宫依次向北：景山公园、北海公园、后海、奥体中心 皇家园林：北大、清华、圆明园、颐和园 距离最远：八达岭长城、十三陵 位置靠南：天坛 下面简单说明各景点的开放时间、门票价格、参观耗时、交通等。以下内容中的蓝色字体为链接，点击可查看详情。 天安门：毛主席纪念堂|天安门城楼|故宫 乘地铁1号线至天安门西站或天安门东站下车即达 参观天安门最好携带身份证，随机查证；参观毛主席纪念堂和天安门城楼严禁携带任何大包小包、相机、液体等入场。如带有上述物需到存包处寄存。 参观顺序：人民大会堂-&gt;毛主席纪念堂-&gt;天安门城楼(单向参观)，国家博物馆酌时间和喜好参观 1. 毛主席纪念堂： 毛主席纪念堂于2017年3月1日至8月31日进行施工，最早于2017年9月1日重新对外开放。 开放时间：周二至周日8:00—12:00，特殊活动及节假日除外。 门票价格：免门票，自愿献花，10元每支。 参观耗时：半小时至一小时不等，主要是排队时间不确定。 2. 天安门城楼： 开放时间：周一至周日，8:30-17:00(16:30止票)，特殊活动除外。 门票价格：成人15元，学生、老人5元。 参观耗时：半小时。 3. 故宫： 故宫目前试行每日限流8万人，可提前登录故宫博物院官网购票，凭身份证在午门入口直接入园（故宫博物院门票预售系统） 开放时间：8:30-16:00，周一下午闭馆，节假日及暑假(7月1日至8月31日)除外。 门票价格：60元/人；学生票半价，60岁以上老人凭身份证原件半价优惠。 参观耗时：两小时至半天不等。 参观路线：故宫两小时最佳游览路线 4. 人民大会堂： 开放时间：7月、8月：7:30至16:00，法定节日延长开放时间。 门票价格：成人30元，学生、老人15元。 参观耗时：1-2小时。 游客参观需按顺序从东门入场。请勿带包，大会堂南门东侧设有存包处。 5. 中国家博物馆： 开放时间：9：00-17：00（周一闭馆）。 门票价格：免门票，凭身份证取票。 参观耗时：2-3小时。 景山|北海|后海景山公园万春亭可以俯瞰故宫和北海，北海又紧邻后海 1. 景山公园：俯瞰故宫和北海 如果你去过故宫，或者是没有时间参观故宫，景山公园都将是一个不错的选择。景山公园万春亭北面的地面上有一个“北京城南北中轴线”黄铜圆盘，标志着景山公园万春亭坐落在明清北京城的中轴线上。 站在万春亭，往南俯瞰故宫，映入眼帘的是，红色的宫墙，黄色的琉璃瓦，各级宫殿高低起伏沿南北中轴线鳞次栉比对称排列。往北可以望见坐落在中轴线上的钟鼓楼以及远方奥体中心这几年新建的北京奥林匹克塔。往西可以瞥见北海和白塔，顿时唤醒你往昔的记忆。 开放时间：夏季6:30-21:00，冬季6:30-20:00 门票价格：15元（学生票5元） 参观耗时：1-2h 交通：乘地铁1号线至天安门东站下车，步行或骑共享单车很快到达。 2. 北海公园：让我们荡起双桨 开放时间：06:30~20:00 门票价格：旺季10，淡季5 参观耗时：1-2h 交通：乘地铁8号线至什刹海下车，步行850m到达。 3. 后海：晚上酒吧很热闹 开放时间：全天 门票价格：免门票 参观耗时：1-2h 交通：乘地铁8号线至什刹海下车，步行即达。 奥体中心：鸟巢|水立方乘地铁8号线在奥体中心站下车即达。鸟巢水立方可远观而不可亵玩，进入场馆内画风突变，找不到看点。 鸟巢：夜晚有灯光，或许会更美 开放时间：开放时间：9:00-21:00。 门票价格：成人50元，学生、老人25元。 参观耗时：0.5小时。 水立方：夜晚有灯光，或许会更美 开放时间：开放时间：8:30-16:00，特殊活动及节假日除外。 门票价格：成人30元，学生、老人15元。 参观耗时：0.5小时。 北大|清华|圆明园|颐和园 北大、清华、圆明园、颐和园相邻，乘地铁4号线至北京大学东门站下，步行即达北大东门，参观完北大，从北大西门出来，步行或骑共享单车很快到达清华西门，再往前走就是圆明园南门。 圆明园东门不远有公交站，出来步行、共享单车到达，乘车前往下一个目的地。 北大西门至颐和园：584路/332路 清华至颐和园：取决于从清华哪个门出来 1. 北京大学：未名湖-北大西门 参观入口： 北京大学东门 开放时间：8:30-16:30(不限时间) 门票价格：免门票 参观耗时：1-2h 2. 清华大学：清华西门-清华园 参观入口： 清华大学西门 开放时间：上午8:30-16:30(不限时间) 门票价格：免门票 参观耗时：1-2h 3. 圆明园：西洋楼遗址 开放时间：6:30-18:00 门票价格：10元/人，学生老人半价，西洋楼遗址门票15元/人，学生老人半价。 参观耗时：1-2小时 参观路线：圆明园官方游园指南 4. 颐和园：万寿山|昆明湖|十七孔桥 开放时间：6:30—18:00 门票价格：30元/张（旺季），20元/张（淡季）学生票半价 参观耗时：1-2小时 八达岭长城|十三陵之定陵 八达岭长城在延庆，十三陵在昌平，都在北京西北方向，顺路。 1. 八达岭长城： 开放时间：6:30-19:00 门票价格：旺季40元，淡季35元，学生半价。 参观耗时：3-4小时 交通：2号线积水潭站A口（西北口）或B口（东南口）出站，步行到德胜门正后方乘877路公交直达八达岭长城，现金票价13元，刷卡6.5元，耗时2.5小时左右，如果不幸遇见高速堵车，路上将耗时三四个小时。 2. 十三陵之定陵：地宫 开放时间：旺季8:00-17:30（停票时间） 门票价格：旺季60元/张，学生老人半价 参观耗时：1-2小时 交通：2号线积水潭站A口（西北口）或B口（东南口）出站，步行到德胜门正后方乘坐872路公交车直达定陵，耗时1.5小时。 天坛 开放时间：6:00-17:30 门票价格：15.00元 参观耗时：1-2h 交通：乘地铁5号线至天坛东门下车，步行即达。 住宿：可考虑酒店或民宿 考虑到有老人和小孩一同出行，建议选择离北京站较近的房源。便于出行，避免在地铁上花费太多时间，从而留出更多的参观时间。 房源非常多，价格因地段不一。基于上述原则，筛选出下面所列的酒店或民宿。不过，无需拘泥于这些酒店，而应根据具体情况，如老人小孩身体状况、景点位置、天气等做出合适选择。 注意事项1. 交通方式帝都交通比较发达，可供选择的交通方式较多。 地铁：四通八达，准时准点，时间有保证，自动售票机比较方便，自备现金。 公交：到达时间不确定，不过仍是去八达岭和十三陵的不二之选。另外，公交卡买票半价，办卡押金可退。 共享单车：解决从目的地到地铁站或者公交站的最后一公里。如摩拜单车、小黄车、哈罗单车等 哈罗单车，支付宝蚂蚁信用700分以上可免押金骑。 摩拜单车，微信扫码骑车，如使用摩拜客户端可用支付宝花呗交押金。 小黄车，支付宝扫码骑车，可用花呗支付。 滴滴：如果天气很热、人困马乏，滴滴将是一种不错的选择，目前13元起步。 2. 北京特产关于购买北京特产，基本上任意一家大型超市都有，而且种类价格都差不太多。 3. 其他 保管好手机钱包等贵重物品，小心人多手杂。 前往八达岭长城，路途遥远，请自备干粮。 从八达岭返回的公交上人比较多，耐心等待。 如果你是研究生还在为不能享受门票半价优惠不平衡，不妨尝试一下学生卡而非学生证，亲测有效，故宫没试过。 参观时间及路线规划（2017年暑假） 进京时间：8.3（周四）12:04；离京时间：8.6（周日）13:06。 8.3（周四）下午及晚上：景山公园|后海|奥体中心 后海和奥体中心开放至晚上，后海酒吧街晚上灯红酒绿很是热闹，奥体中心的鸟巢、水立方、玲珑塔及北京奥利匹克塔夜晚有灯光，看起来很漂亮。 景山公园地理位置优越，地处故宫后门对面，去往景山公园的路上可以看到美丽的故宫角楼。 进入景山公园登上万春亭，向南可以俯瞰故宫：红色的宫墙，黄色的琉璃瓦，各级宫殿高低起伏沿南北中轴线鳞次栉比对称排列。向北可以看到钟鼓楼以及远方奥体中心的玲珑塔。向西可以瞥见北海和白塔，满满的都是回忆。 8.4（周五）全天：毛主席纪念堂|天安门城楼|故宫|北大|清华|颐和园 毛主席纪念堂因施工最早于2017年9月1日开放参观。 登天安门城楼不允许携带任何大包小包、液体等。 故宫目前每日限流8万人，如果参观故宫，提前在故宫博物院官网购票。如去过景山公园，故宫可放在后边有时间再参观，而且有些宫殿并不开放，比如金銮殿，只能在门口隔着人群远观。 北大清华排队参观的人通常比较多，特别是节假日或周末。 有所取舍，清华北大人多，去圆明园，颐和园看看也不错。参观圆明园如果从南门进东门出，不要错过了黑天鹅和全景模型。时间紧张，这次参观不完，且为下次留作念想。 8.5（周六）全天：八达岭长城、定陵 八达岭长城地处北京西北边缘，乘公交需要2小时左右，如果高速堵车耗时更长，所以能早起最好。八达岭长城分为南北两支，南边那支稍短，北边那支较长，可酌体力和时间选择。 十三陵其实非常大，如果时间允许，八达岭长城出口有公交直达十三陵景区。可选择去定陵，而且定陵有地宫。 8.6（周日）上午 上午的时间比较短暂，可休整一下，就近逛逛王府井或天坛公园，晴天里的天坛在蓝天白云的衬托下格外漂亮。或者去超市购买特产，准备火车上吃的食物之类。预祝各位旅途愉快。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>北京</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Machine Learning-Coursera]]></title>
    <url>%2F2018%2F11%2F15%2FMachine-Learning-Coursera%2F</url>
    <content type="text"><![CDATA[Source: Coursera: Machine Learning &amp; Stanford-CS229A-Fall2011 L1 机器学习概述：应用、定义、分类机器学习分类：监督学习，非监督学习。其他如，增强学习，推荐系统等。 监督学习：有标签； 非监督学习：无标签。 监督学习（有标签） 回归：预测连续结果，如房价、股价等； 分类：预测离散结果，如是否患有癌症、是否是垃圾邮件等。 非监督学习（无标签） 聚类热点新闻 社交网络分析 市场划分等 L2 机器学习模型以单因素线性回归为例，预测房价 同步更新假设中的所有参数 学习速度小，则梯度下降速度慢；学习速度大，则可能错过最小值，可能不收敛，甚至发散。 凸函数，碗状，全局最优，不出现局部最优 批量梯度下降法：每次梯度下降，使用所有的训练样本 L3 线性代数：矩阵、向量及其运算加法、乘法、求逆、转置 L4 多变量线性回归与单个变量的模型及求解方法相似 特征缩放：均值归一化 特征缩放，保证特征在相似范围内，加速梯度下降，如[-3, 3]或[-1/3, 1/3] 均值归一化，样本值减去均值，除以标准差或级差 选择学习速度 尝试不同学习速度：0.001，0.003，0.01，0.03，0.1，0.3，1，… 足够小的学习速度，代价函数随迭代次数降低。 学习速度太小，则梯度下降的收敛速度慢。太大，则可能不收敛，甚至发散。 梯度下降法VS标准方程法 梯度下降法 选择学习速度 多次迭代计算 特征非常多（n非常大，如10^6）时计算速度也很快 标准方程法 无需选择学习速度； 无需多次迭代计算； 需要计算n×n矩阵的逆矩阵，计算复杂度O(n^3)； 特征非常多（n非常大,如100,1000,10000）时，计算速度非常慢； 不可逆矩阵求逆 Octave：函数pinv()可求解伪逆矩阵，即便矩阵不可逆。函数inv()求解逆矩阵，只有在矩阵可逆才能使用。 矩阵不可逆原因及对策 特征冗余，存在特征线性相关，如不同单位表示的房屋面积； 特征数量太多，如特征数量多余样品数量。对策，删除部分特征，正则化处理。 L5 Octave教程 基本操作 数据移动 数据计算 数据可视化：作图 控制语句：for，while，if 向量化应用 L6 逻辑回归：预测离散结果 二元分类（0 or 1）是否为垃圾邮件、线上交易是否为诈骗、恶性or良性肿瘤 模型假设：基于输入参数，预测输出结果为真(y=1)的可能性 S形函数 决策边界 代价函数 高级优化算法。一般常用算法为梯度下降法，高级算法无需手动选择学习速度，通常比梯度下降法的速度要快，但是比较复杂。包含以下几种方法： 共轭梯度 BFGS L-BFGS 多元分类：one vs. all拆成多个二元分类进行处理，取最大可能性 邮件分组：工作、朋友、家庭、爱好 病情诊断：没病、感冒、流感 天气：晴天、多云、下雨、下雪 L7 正则化：应对过拟合问题选用过多输入特征（变量），模型假设用训练集拟合非常好，而用测试集预测效果差 解决过拟合问题的对策： 减少特征数量：手动挑选特征，调整模型算法 正则化：保留所有特征，适当减小参数值，特征很多时依然可行 代价函数及其梯度引入正则化项，lambda非常大，参数接近零，则导致模型假设欠拟合 L8 神经网络：正向传播起源：模拟大脑的算法 应用：80年代和90年代早期广泛应用，90年代末热度下降，近些年重新变得热门，得到广泛应用 神经网络结构： 输入层 隐藏层（中间层） 输出层 神经网络学习生成自己的特征（隐藏层） 应用举例 以逻辑运算或（or）、与（and）、非（not）模拟同或（xnor，输入相同为真） 手写数字分类 L9 神经网络：反向传播代价函数 应用细节 矩阵展开为列向量，matrix(:) 列向量转换成矩阵，reshape(vector, num_rows, num_columns) 梯度检查：数值计算估计梯度 随机初始化theta 神经网络算法 随机初始化theta 正向传播神经网络计算代价函数 反向传播神经网络计算梯度 数值模拟检查梯度，检查完毕关闭梯度 使用高级优化算法fminuc或计算梯度结合反向传播神经网络计算theta 反向传播神经网络应用实例：自动驾驶 L10 应用机器学习的建议评价模型假设 数据集划分：70%训练集，30%测试集 利用训练集得到theta 计算测试集误差 或计算分类错误比例 模型选择 数据集划分：60%训练集，20%交叉验证集，20%测试集 利用训练集得到theta 利用交叉验证集选择最优模型（最高幂次） 利用测试集检查模型泛化能力 诊断偏差vs方差 选择模型幂次 模型幂次低，欠拟合，高偏差，训练集误差和交叉验证集误差都很高且相近 模型幂次高，过度拟合，高方差，训练集误差小，交叉验证集误差大 选择正则化参数lambda：已基于交叉验证集选择模型幂次，增加正则化项应对过度拟合问题。 逐个试验选择合适lambda：0，0.01，0.02，0.04，…，10 lambda小，过度拟合，高方差，训练集误差小，测试集误差大 lambda大，欠拟合，高偏差，训练集误差和测试集误差都很高且相近 学习曲线 增加样本数量对高方差有效，而对于高偏差则帮助不大 应对策略 增加样本数量，适合高方差，过度拟合 减少特征数量，适合高方差，过度拟合 增加特征数量，适合高偏差，欠拟合 增加多项式特征，适合高偏差，欠拟合 降低lambda，适合高偏差，欠拟合 增大lambda，适合高方差，过度拟合 L11 机器学习系统设计 以垃圾邮件分类为例 选择训练集中出现频率最高的n个词语（10000-50000）作为垃圾邮件特征 推荐的系统设计思路 首先建立可以快速应用的简单模型，利用交叉验证集进行验证 绘制学习曲线，确定是否需要更多的样本、特性等 误差分析，手动分析算法出错的样本（交叉验证集），识别这些样本的类型以及有助于算法改进的特征 量化评价的重要性 误差分析并不能帮助确定使用词干提取软件能否改进算法表现，唯一的办法就是尝试 通过量化比较算法在不使用与使用词干提取软件时的表现，确定是否采用词干提取软件 歪斜样本的误差量化训练集中，有些样本非常多，有些样本非常少，样本分布不均匀。如癌症分类算法，样本中患癌症的病人非常少，绝大多数正常 预测准确度precision：预测为真的样本中确实为真的比例(P) 召回率recall：确实为真的样本中预测为真的比例(R) F1：权衡预测准确度和召回率 1F1 = 2*PR/(P+R) 设计一个高准确度的学习算法 有非常多参数（许多特征，有很多隐藏层的神经网络） 有非常大样本（不存在过度拟合） 训练集和测试集误差相近，测试集误差小，低方差 L12 支持向量机 核函数与相似度 基于样本，选择地标，将m个样本赋给m个地标 利用核函数计算相似度 SVM参数 C：C大，高方差；C小，高偏差。 sigma^2：sigma^2大，高偏差；sigma^2小，高方差 使用SVM软件包 选择参数C 选择核函数：无核函数（线性核函数），高斯核函数（选择sigma^2，特征缩放） 多元分类 许多SVM软件包内置多元分类函数 使用 one VS all方法，训练多个SVM 逻辑回归vs支持向量机 L13 非监督学习：聚类K-均值算法 随机初始化K个聚类中心。 聚类中心数目小于样本数，随机选取K个训练样本，作为K个聚类中心 将样本分别分配到相应的聚类中心 计算每个聚类中心所属样本的均值 重复步骤2和3，移动聚类中心位置，使得代价函数全局最小 K值的选择 肘部法，曲线变化趋势缓慢，没有明确的分界点 根据算法所要实现效果的好坏，选取合适的K值 L14 降维：主成分分析（PCA）数据压缩及数据可视化1234graph LRA[nD] --&gt; |降维| B[3D立体]B --&gt; |降维| C[2D平面]C --&gt; |降维| D[1D线段] 1234graph LRA[多指标] --&gt; |降维| B[三指标]B --&gt; |降维| C[二指标]C --&gt; |降维| D[单指标] 二维数据降至一维数据：寻找一个向量，样本在其方向上的投影误差最小 n维数据降至k维数据：寻找k个向量，样本在其方向上的投影误差最小 主成分分析不是线性回归 主成分分析（PCA）算法 数据预处理：均值归一化，有选择地特征缩放 算法主体： 由压缩模型重建原始模型 选择主成分数量 主成分分析（PCA）应用建议 加速监督学习，提取浓缩输入，减少矩阵的维度 数据压缩，减少存储数据占用的内存和磁盘 数据可视化 防止过度拟合（不正确的应用） L15 异常检测问题产生 制造业产品质检，如飞行器发动机 网络欺诈检测 监测数据中心的电脑 高斯（正态）分布1x ~ (μ, σ^2) 异常检测算法 选择你认为能够表征异常样本的特征 选择不经常出现的大数值或小数值作为特征 如果已有特征不服从高斯分布，可通过取对数、开平方等，使其符合 拟合各个特征的均值和标准差 给定新样本，计算相应概率，概率小于临界值即为异常样本 开发|评价异常检测算法 将样本分为训练集，交叉验证集，测试集 利用训练集拟合均值和标准差参数，计算样本异常概率，建立异常检测模型 利用交叉验证集或测试集，计算F1评价算法异常检测效果 利用交叉验证集或测试集，选择异常临界值ε 异常检测vs监督学习异常检测 异常样本(y=1)较少，通常0-20个 大量的正常样本(y=0)， 异常类型很多，算法很难从已有异常样本中学习到异常的特征，未来出现的异常可能与我们目前见过的异常大不相同。 异常检测算法应用：欺诈检测，产品质检，监测数据中心中的机器… 监督学习 正面与反面样本都很多 有足够的反面样本让算法学习反面样本的特征，未来的算法检测结果可能与训练集中的情况相似 监督学习算法应用：垃圾邮件分类，天气预报，癌症分类… 多元高斯分布综合所有特征建立一个异常检测模型，不再为每个特征分别建立模型 一元高斯分布vs多元高斯分布 L16 推荐系统问题产生：预测电影评分，用户给电影打分，从一星到五星。 基于内容的推荐算法 协同过滤算法 向量化：低秩矩阵分解 寻找相关电影，最相似的5部电影 应用细节：均值归一化 L17 大型机器学习大数据集机器学习 随机梯度下降法批量梯度下降vs随机梯度下降 微型批量梯度下降 三种梯度下降法对比 批量梯度下降：每次迭代使用训练集所有样本 随机梯度下降：每次迭代使用训练集1个样本 微型批量梯度下降：每次迭代使用训练集部分样本（2~100） 检查梯度下降是否收敛 批量梯度下降，绘制代价函数随迭代次数的变化曲线 随机梯度下降，每迭代1000次，计算前面1000次迭代的代价函数均值。在更新参数theta之前计算代价函数。 如果出现代价函数随迭代次数上升，则应使用更小的学习速度 随机梯度下降算法 线上学习 网上邮寄，根据用户特点、包裹从哪到哪等信息，实现最优价格 网上产品搜索，推荐最符合描述的产品 个性化推荐工作、新闻、产品等 映射规约和并行计算 将训练集分为若干部分，分别由若干台机器同时计算，最后一台机器对上述所有机器的计算结果进行整合 许多学习算法都可以表示为，计算函数和（关于训练集）的形式 多核计算机，可利用多核实现并行计算 L18 应用实例：Photo OCR问题描述及处理流程 1234graph LRA[图片]--&gt;B[文本检测]B --&gt; C[字符分割]C --&gt; D[字符识别] 检测滑行窗口文本、行人 人工合成数据，获取大量数据 引入“扭曲”合成数据 以演讲识别为例，引入的“扭曲”应该代表噪音的类型或是测试集中存在的“扭曲”，如背景噪声、连接信号差等 通常添加纯粹随机或者无意义的噪音对数据合成帮助不大 在做更多的工作之前，确保你有一个低偏差的分类器，例如增加特征数量或是神经网络隐藏层的数量，直到得到一个低偏差的分类器 获取10倍于当前的数据，需要花费什么样的努力？ 人工合成数据 自己收集或标记数据 众筹，如Amazon Mechanical Turk 上限分析：定位关键环节]]></content>
      <categories>
        <category>Machine Learning</category>
      </categories>
      <tags>
        <tag>Coursera</tag>
        <tag>Andrew Ng</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[溶液粘度]]></title>
    <url>%2F2018%2F11%2F14%2F%E6%BA%B6%E6%B6%B2%E7%B2%98%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[本文参考维基百科词条：粘度和特性粘度 对于溶液（尤其是高分子溶液），常用到以下几种黏度。 相对粘度又称黏度比，是溶液（或分散相）的黏度η与溶剂（或连续相）的黏度η0之比，即： $$\eta_r=\frac{\eta}{\eta_0}$$ 增比粘度又称比黏度，是溶液（或分散相）的黏度η与溶剂（或连续相）的黏度η0之差被溶剂（或连续相）黏度的η0除得之商，即：$$\eta _{sp}=\frac {\eta -\eta _0}{\eta _0}=\frac {\eta}{\eta _0}-1=\eta _{r}-1$$ 比浓粘度又称换算黏度或黏度数,是单位浓度的溶液（或分散相）的增比浓度，即：$${\displaystyle {\frac {\eta _{sp}}{c}}={\frac {\eta _{r}-1}{c}}}$$ 比浓对数粘度又称对数粘度，是相对黏度的自然对数被溶液（或分散相）的浓度除得之商，即：$${\displaystyle \left{\eta \right}={\frac {\ln {\eta _{r}}}{c}}}$$ 特性粘度又称极限粘度，是浓度趋于零时比浓粘度的极限值，即：$${\displaystyle \left[\eta \right]=\lim _{c\to 0}{\frac {\eta _{sp}}{c}}}$$]]></content>
      <categories>
        <category>Research</category>
      </categories>
      <tags>
        <tag>Petroleum</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[岩心驱替实验流程及注意事项]]></title>
    <url>%2F2018%2F11%2F14%2F%E5%B2%A9%E5%BF%83%E9%A9%B1%E6%9B%BF%E5%AE%9E%E9%AA%8C%E6%B5%81%E7%A8%8B%E5%8F%8A%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%2F</url>
    <content type="text"><![CDATA[岩心驱替实验流程岩心驱替实验的流程主要包括如下6个步骤： 抽真空造束缚水 水测渗透率 饱和油 前期水驱 注驱油剂 后续水驱 抽真空造束缚水首先，岩心烘干，量取岩心直径、长度，并称量岩心质量（若采用称量法测量孔隙体积会用到）。 其次，逐段检查管线是否漏气，并在-0.1MPa压力条件下抽取4-5h，然后将吸水后岩心取出，用纸将表面水快速擦去后，再次称量其质量，岩心吸水后增加的质量，即可得到岩心孔隙体积，并可计算出孔隙度。 另外，还可以直接在岩心夹持器内抽真空（无需称质量），抽完真空后岩心吸水体积即为岩心孔隙体积，并可计算出孔隙度。 注意：测量岩心孔隙体积时，若管线较长，需扣除管线内水的体积。 水测渗透率可分别采用3个注入速度进行水测渗透率，液测渗透率取平均值，岩心各测点的压力稳定即可转入下一阶段。 饱和油以合适的注入速度（如0.05mL/min）进行饱和油，出口端用量筒计量排出水的体积，直到不再出水，排出水的总体积即为饱和油体积，并可计算出原始含油饱和度及束缚水饱和度。岩心饱和油之后老化12h，然后进行前期水驱。 注意：饱和油阶段时间较长，可安排在夜间进行。 前期水驱以一定的速度水驱至岩心出口端含水率高于98%，通常需要注水2PV左右，转入注驱油剂阶段（如注聚）。 注意：前期水驱速度需要提前确定，并和水测渗透率阶段的其中1个注入速度相同。 注驱油剂选定驱油剂注入速度（如0.5mL/min），注入一定PV数的驱油剂，而后转入下一阶段。聚合物驱中，通常是注入0.3PV的聚合物溶液，或者是注入到岩心各测点的压力稳定时，停止驱油剂注入，大概在3PV左右。 注意：驱油剂注入速度需要提前确定，并和水测渗透率阶段的其中1个注入速度相同。 后续水驱注驱油剂阶段结束，转入后续水驱阶段，以相同的注入速度进行后续水驱，直至岩心各测点压力稳定。 注意：尽可能缩短前后两个阶段的转换时间，因为岩心各测点的压力会快速下降。 注意事项 水测渗透率阶段压力较小（kPa数量级，如20kPa），注驱油剂阶段的压力较大（MPa数量级，如2MPa），注入压力压力大小与岩心气测渗透率和驱油剂浓度有关，所以需要选取合适量程的压力传感器。 实验前最好将压力传感器进行校准，以减小计量误差。 岩心驱替实验的围压至少比入口端压力高2MPa。 实验过程中，注意泵压变化，若压力快速上升，可能有阀门没有打开，或是发生堵塞。实验开始前需要对各个阀门进行检查（是否通畅，是否排空气，螺母是否拧紧，阀门打开是否正确等）。” 这篇文章的 PRESS.one 签名:“https://press.one/file/v?s=47dbd0703a580716265a192518095d41e4c5d4404307da4dc5eb8d264ecdd728b1d4b6ec28b0e36dec3a6f5cfda6a65cd5072ca33b99b7f21e41d9d94c4f40951&amp;h=f5de4f6e033b6f3333a7aaee393b558b4586c8accb8aeaad6dc1cf6da63a36f5&amp;a=5fff08474362b1e48d72b083abf18d2360881d5e&amp;f=P1&amp;v=2]]></content>
      <categories>
        <category>Research</category>
      </categories>
      <tags>
        <tag>Guide</tag>
        <tag>Petroleum</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[哈克流变仪粘度测量步骤及注意事项]]></title>
    <url>%2F2018%2F11%2F14%2F%E5%93%88%E5%85%8B%E6%B5%81%E5%8F%98%E4%BB%AA%E7%B2%98%E5%BA%A6%E6%B5%8B%E9%87%8F%E6%AD%A5%E9%AA%A4%E5%8F%8A%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%2F</url>
    <content type="text"><![CDATA[聚合物溶液流变性（如粘度）测量仪器为HAKKE RS6000旋转流变仪，流变仪由4部分组成： 空气压缩机； 温控系统； 流变测量系统； 软件系统（控制-测量-数据处理）。 液体粘度测量的操作步骤： 开机，其顺序为：空气压缩机→温控仪→测量系统→电脑控制系统。 根据被测样品及其测量条件，选择安装合适的转子系统和温控器，并在测量程序中首先选择对应的转子和温控器。 新建测量文件（Job），文件包含常规要素（General elements）、测量要素（Measurement elements）、评价要素（Evaluation elements）3个部分。通常测量，只需将温度模块和测量方法两个模块拖至右侧，并进行简单设置即可（温度、剪切速率上下限）。 测量台调平。使测量台处于水平状态。 校零（Zero point）。校准上下椎板的距离。 加样，用移液管向下椎板中心部位移取1.5mL左右的待测溶液。 开始测量，点击Start按钮开始测量，测量结束输入文件名保存文件。 分离并清洗上下椎板，并导出测量数据（数据全选复制到Excel表格中）。 关机，关机顺序与开机顺序刚好相反。 相关注意事项设置剪切速率在设置剪切速率时，首先需要选中测量模式的CR（控制剪切速率）才进行设置（CS是表示控制应力）。而且，除了设置上下限，还有剪切速率是以ln还是log进行分布，两者的区别在于： ln模式：测量点在剪切速率上限附近多，下限附近稀疏，适合目标剪切速率较大的测量。 log模式：与ln模式相反，测量点在剪切速率上限附近稀疏，下限附近多，适合目标剪切速率较小（如7.34s-1）的测量。 设置测量步数及单步测量停止条件测量步数需要结合剪切速率上下限进行设置，以保证剪切速率与目标值尽可能接近，例如聚合物粘度测量常用的剪切速率0.1~1000，100个测量点，log模式，剪切速率目标值7.34s-1，实际值7.221-1很接近。 单步测量停止条件：默认每个剪切速率测量30s时间，然后改变剪切速率再次测量，直到最后。测量步数和单步测量时间决定了每个样品的测试时间。以剪切速率0.1~1000,100步，单步测量时间30s，一个样品耗时3300s，即55min。样品量少，如果测量温度较高，则测量时间不能太久，否则样品挥发，导致测量失败。所以在不影响测量结果情况下，适当减少测量步数，缩短单步测量时间（如10s），以及设置限制条件gradient =0.5都可减少测量时间。 如果常用某种测量模式（JOB），新建并设置测量文件后，可保存并命名该测量文件，以便下次测试时直接调用。 常见异常及处理 测量过程中，弹出温控系统Timeout错误信息。 需检查各插头连接是否良好，并重启温控系统重新测量。 当测量出现粘度非常大（几十万），粘度及应力曲线出现异常的杂峰状况： 一种情况，空气压缩机未打开，打开后再次测量即可。 第二种情况，测量台未处于水平状态（即把水平仪放置于测量台上，其中气泡偏离正常区域），可通过调节流变仪底座的四个支点使其处于水平状态，再次进行测量。 另外，注意每次实验前必须检查测量台是否处于水平状态，然后进行归零校准！！！ 控制流变仪的电脑故障：主机指示灯状态为3和4，显示屏无法显示。请按照下图提示自行解决：“ 这篇文章的 PRESS.one 签名:“https://press.one/file/v?s=518e1251f8cf0d964dc9cb4b67f622974412f2cbad579673390d04c8671f03ec8e7f2e152ede080fc663f06eeb47db76f269ff3100f9da3eaa3fe17839f02e3f0&amp;h=8638863ba0c65b8bad2edeef7c0205fadb0a7eecdec5cfa0f528aedff9da4c7d&amp;a=5fff08474362b1e48d72b083abf18d2360881d5e&amp;f=P1&amp;v=2]]></content>
      <categories>
        <category>Research</category>
      </categories>
      <tags>
        <tag>Guide</tag>
        <tag>Petroleum</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL数据库]]></title>
    <url>%2F2018%2F11%2F13%2FMYSQL%E6%95%B0%E6%8D%AE%E5%BA%93%2F</url>
    <content type="text"><![CDATA[MySQL数据库是一个小型关系型数据库管理系统，开发者为瑞典MySQL AB公司。在2008年1月16号被Sun公司收购。而2009年，Sun公司又被Oracle公司收购。目前MySQL被广泛地应用在Internet上的中小型网站中。由于其体积小、速度快、总体拥有成本低，尤其是开放源码这一特点，许多中小型网站为了降低网站总体拥有成本而选择了MySQL作为网站数据库。 MySQL数据库的下载安装MySQL官方下载地址：MySQL 如果重装mysql，可先删除服务：1Sc delete MySQL ① 解压mysql-5.7.17-winx64.zip压缩包（32位操作系统的请下载winx32的压缩包） ② 进入到刚才的解压目录，修改my-default.ini配置文件，修改后保存： //注意：替换MySQL安装路径 basedir = C:\mysql\mysql-5.7.17-winx64 datadir = C:\mysql\mysql-5.7.17-winx64\data port = 3306 ③ 添加环境变量： //注意：替换MySQL安装路径 MYSQL_HOME：C:\mysql\mysql-5.7.17-winx64 将MYSQL_HOME追加到系统的path变量的末尾， 注意用英文分号（;）隔开。追加内容： ;%MYSQL_HOME%\bin; ④ 将MySQL添加到系统服务中并启动： 1) 右键“开始”——&gt; “运行(R)”或者快捷键：“开始”+“R”(以管理员身份运行cmd)2) cd 到MySQL所在的本地磁盘路径的bin目录，然后执行：12//替换MySQL安装路径mysqld install MySQL --defaults-file=&quot;D:\Mysql01\mysql-5.7.17-winx64\my-default.ini&quot; 启动mysql：12345678910net start mysql``` 此时会出现MySQL服务无法启动，服务没有报告任何错误。解决办法：执行如下代码：```mysqlmysqld --installmysqld --initializenet start mysql ⑤ 修改mysql密码 Mysql在启动后会初始化一个默认密码，该密码在mysql的安装目录data/xxx.err结尾的文件中。 [Note] A temporary password is generated for root@localhost: ****** 在cmd下执行：1mysql -uroot -p 输入上面文件中的密码，即可进入mysql操作界面。然后执行如下代码以修改密码： 12//root即为新密码SET PASSWORD = PASSWORD(&apos;root&apos;); 使用quit或者exit退出mysql，在cmd下执行：1mysql -uroot -p 然后输入设置的密码后就能登录到mysql中。 数据库和表的操作数据库的操作12345678910111213141516171819201 查看当前所有的数据库show databases;2 创建数据库create database &lt;database name&gt;;3 展示创建数据库show create database &lt;database name&gt;;4 创建数据库指定编码create database &lt;database name&gt; character set utf8;5 删除数据库drop database &lt;database name&gt;;6 选择使用数据库use &lt;database name&gt;;7 查看当前使用数据库select database(); 表的操作12345678910111 创建表create table &lt;tableName&gt;(id int, name varchar(30));2 查看当前数据库中所有的表show tables; 3 查看表结构desc &lt;tableName&gt;; 4 创建表时的数据约束类型create table &lt;tableName&gt;(id int primary key auot_increment, name varchar(30) not null, email varchar(30) noy null unique, role varchar(20) default &apos;VIP&apos;); 对数据进行操作对数据进行操作主要有：增、删、改、查 增加数据123451 向表中插入指定字段的数据insert into &lt;tableName&gt; (id,name,email) values(1,&apos;zsx&apos;,&apos;zsx@qq.com&apos;);3 插入所有列的所有数据insert into &lt;tableName&gt; values(1,&apos;zsx&apos;,&apos;zsx@qq.com&apos;,&apos;MVP&apos;); 删除数据123456781 删除表中所有数据delete from 表名 删除所有的数据2 删除表中指定条件的数据delete from 表名 where 条件3 将表的数据清空 ，表结构截断 ，相当于生成一个新的表格 。Truncate table 表名 修改数据1Update 表名 set 字段1 = 值1 ，字段2 = 值2 ......where 条件 查询数据123451 简单无条件查询所有的数据select * from 表名2 条件查询数据select * from 表名 where 条件 条件查询代码示例：123456789101112131415161718192021222324252627281.查询所有计算机类商品信息select * from products where category = &apos;计算机&apos;2.查询出商品价格大于90的商品信息select * from products where price &gt; 903.查询出商品总价大于10000的商品信息select * from products where price*pnum &gt;100004.查询出价格在100-200之间的商品信息select * from products where price &gt;=100 and price &lt;=200select * from products where price between 100 and 2005.查询出ID在1和5之间，并且价格在50和100之间select * from products where (id between 1 and 5) and (price between 50 and 100)6.查询出商品价格是65,100或190的商品信息(两种方式：or，in)select * from products where price = 65 or price = 100 or price = 190select * from products where price in (65,100,190)7.查询出商品的名称中包含java的商品信息。select * from products where name like &apos;%java%&apos; //含javaselect * from products where name like &apos;java%&apos; //以java开头select * from products where name like &apos;%java&apos; //以java结尾select * from products where name like &apos;_java%&apos; //java前有一个字符8.查询出商品价格不为null商品信息select * from products where price is not null 排序123451 查询出所有商品，根据数量进行升序排列，如果数量相同，根据价格进行降序排列select * from products order by pnum asc, price desc2 查询出id小于8的商品，根据数量进行升序排列，如果数量相同，根据价格进行降序排列select * from products where id &lt; 8 order by pnum asc, price desc 聚合函数12345678910111213141516171819201.统计商品表中共有多少条记录select count(*) from products2.统计商品表中价格大于50的有多少条记录select count(*) from products where price &gt; 503.统计有多少商品select sum(pnum) from products4.统计所有商品的总价值select sum(price*pnum) from products5.统计所有商品的平均价格select sum(price*pnum)/sum(pnum) from products6.统计出记录中price的平均值select avg(price) from products7.统计出商品表中price最大与最小值select max(price), min(price) from products 子查询12//子查询：一条语句的查询结果作为另一条查询的条件select * from products where price in (select price from products where id &lt; 8) 分组GROUP BY 语句用于结合聚合函数，根据一个或多个列对结果集进行分组。语法解析如下： SELECT column_name, aggregate_function(column_name) FROM table_name WHERE column_name operator value GROUP BY column_name HAVING 条件 代码示例：123456781 对商品分类别统计，求出每一种类商品的总数量select category,sum(pnum) from products group by category2 对商品分类别统计，求出每一种类商品的总数量，数量要大于100select category,sum(pnum) from products group by category having sum(pnum)&gt;1003 对id小于9的商品分类别统计，求出每一种类商品的总数量，要求数量要大于100，并以数量降序排列，而且只显示前两名select category,sum(pnum) from products where id&lt;9 group by category having sum(pnum)&gt;100 order by sum(pnum) desc limit 1,2 Having与where的区别： having是在分组后对数据进行过滤，where是在分组前对数据进行过滤 having后面可以使用分组函数(统计函数)，where后面不可以使用分组函数。 操作数据库的客户端在dos命令中操作数据库有很多不方便，用数据库客户端软件Navicat操作数据库。 多表设计 一对一：如同身份证，一个人和唯一身份证绑定。实际中，不太常用。 一对多：在进行表设计时，如果存在一对多关系，要求在多的一方加入一个外键，用于描述它来自于一方的主键。 多对多：存在多对多关系，进行表设计时，产生一个中间的关系表，来描述关系。 外键约束表与表之间的关系也包括：一对一，一对多，多对多。而表与表之间关系是通过外键来维护的。将两张表关联起来，让表和表发生关系。外键约束特性如下： 外键必须是另一表或自身表的主键的值； 外键可以重复； 外键可以为空； 一张表中可以有多个外键。 外键约束作用:可以保证数据的完整性。以用户与订单（一对多）进行说明，创建外键约束有两种方式： 先建表后添加外键123456789101112131415161718192021222324-- 用户表CREATE TABLE USER( uid INT PRIMARY KEY AUTO_INCREMENT, -- 用户编号 NAME VARCHAR(20) -- 用户姓名);-- 用户表插入数据INSERT INTO USER VALUES(NULL,&quot;tom&quot;);INSERT INTO USER VALUES(NULL,&quot;fox&quot;);-- 订单表CREATE TABLE orders( id INT PRIMARY KEY AUTO_INCREMENT, -- 订单编号 money DOUBLE, -- 订单总价 receiveraddress VARCHAR(50), -- 订单收货地址 uid INT -- 用户id);-- 订单表插入数据INSERT INTO orders VALUES(NULL,1000,&quot;北京&quot;,1);INSERT INTO orders VALUES(NULL,2000,&quot;上海&quot;,1);INSERT INTO orders VALUES(NULL,3000,&quot;广州&quot;,2);INSERT INTO orders VALUES(NULL,4000,&quot;深圳&quot;,2);-- 表创建后添加外键ALTER TABLE orders ADD CONSTRAINT FK_UID FOREIGN KEY(uid) REFERENCES USER(uid); 创建表时指定外键1234567891011121314151617181920212223-- 用户表CREATE TABLE USER( uid INT PRIMARY KEY AUTO_INCREMENT, -- 用户编号 NAME VARCHAR(20) -- 用户姓名);-- 用户表插入数据INSERT INTO USER VALUES(NULL,&quot;tom&quot;);INSERT INTO USER VALUES(NULL,&quot;fox&quot;);-- 创建表时指定外键CREATE TABLE orders( id INT PRIMARY KEY AUTO_INCREMENT, -- 订单id money DOUBLE, -- 订单总价 receiveraddress VARCHAR(50), -- 订单收货地址 uid INT, -- 用户id CONSTRAINT FK_UID FOREIGN KEY orders(uid) REFERENCES USER(uid) );-- 订单表插入数据INSERT INTO orders VALUES(NULL,1000,&quot;北京&quot;,1);INSERT INTO orders VALUES(NULL,2000,&quot;上海&quot;,1);INSERT INTO orders VALUES(NULL,3000,&quot;广州&quot;,2);INSERT INTO orders VALUES(NULL,4000,&quot;深圳&quot;,2);]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Bootstrap快速入门]]></title>
    <url>%2F2018%2F11%2F12%2FBootstrap%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[Bootstrap是基于HTML、CSS、JavaScript 开发的简洁、直观、强悍的前端开发框架，使得 Web 开发更加快捷。 Bootstrap提供了优雅的HTML和CSS规范，它即是由动态CSS语言Less写成。Bootstrap一经推出后颇受欢迎，一直是GitHub上的热门开源项目，包括NASA的MSNBC（微软全国广播公司）的Breaking News都使用了该项目。 国内一些移动开发者较为熟悉的框架，如WeX5前端开源框架等，也是基于Bootstrap源码进行性能优化而来。 Bootstrap的优势 移动设备优先：自 Bootstrap 3 起，框架包含了贯穿于整个库的移动设备优先的样式。 浏览器支持：Chrome、Firefox、IE等所有的主流浏览器都支持 Bootstrap。 容易上手：只要具备 HTML 和 CSS 的基础知识，就可以开始学习 Bootstrap。 响应式设计：Bootstrap 的响应式 CSS 能够自适应于台式机、平板电脑和手机。 为开发人员创建接口提供了一个简洁统一的解决方案；包含了功能强大的内置组件，易于定制；还提供了基于 Web 的定制；而且还是开源的。 Bootstrap主要学习内容Bootstrap的学习内容，主要包括组件、全局CSS样式和JavaScript插件。Bootstrap参考文档：Bootstrap中文网 组件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;!--声明文档兼容模式，表示使用IE浏览器的最新模式--&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;!--设置视口的宽度(值为设备的理想宽度)，页面初始缩放值&lt;理想宽度/可见宽度&gt;--&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt; &lt;!-- 上述3个meta标签*必须*放在最前面，任何其他内容都*必须*跟随其后！ --&gt; &lt;title&gt;Bootstrap容器介绍&lt;/title&gt; &lt;!-- 引入Bootstrap核心样式文件 --&gt; &lt;link href="./css/bootstrap.min.css" rel="stylesheet"&gt; &lt;!-- 引入jQuery核心js文件 --&gt; &lt;script src="./js/jquery-1.11.0.min.js"&gt;&lt;/script&gt; &lt;!-- 引入BootStrap核心js文件 --&gt; &lt;script src="./js/bootstrap.min.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;!--组件：进度条--&gt; &lt;div class="progress"&gt; &lt;div class="progress-bar" role="progressbar" aria-valuenow="60" aria-valuemin="0" aria-valuemax="100" style="width: 60%;"&gt; 60% &lt;/div&gt; &lt;/div&gt; &lt;br /&gt; &lt;!--组件：图标--&gt; &lt;button type="button" class="btn btn-default" aria-label="Left Align"&gt; &lt;span class="glyphicon glyphicon-align-left" aria-hidden="true"&gt;&lt;/span&gt; &lt;/button&gt; &lt;button type="button" class="btn btn-default btn-lg"&gt; &lt;span class="glyphicon glyphicon-star" aria-hidden="true"&gt;&lt;/span&gt; Star &lt;/button&gt; &lt;br /&gt; &lt;!--组件：下拉菜单--&gt; &lt;div class="dropdown"&gt; &lt;button class="btn btn-default dropdown-toggle" type="button" id="dropdownMenu1" data-toggle="dropdown" aria-haspopup="true" aria-expanded="true"&gt; Dropdown &lt;span class="caret"&gt;&lt;/span&gt; &lt;/button&gt; &lt;ul class="dropdown-menu" aria-labelledby="dropdownMenu1"&gt; &lt;li&gt;&lt;a href="#"&gt;Action&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;Another action&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;Something else here&lt;/a&gt;&lt;/li&gt; &lt;li role="separator" class="divider"&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;Separated link&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;br /&gt; &lt;!-- 组件：按钮--&gt; &lt;div class="btn-group" role="group" aria-label="..."&gt; &lt;button type="button" class="btn btn-danger"&gt;Left&lt;/button&gt; &lt;button type="button" class="btn btn-gr"&gt;Middle&lt;/button&gt; &lt;button type="button" class="btn btn-default"&gt;Right&lt;/button&gt; &lt;/div&gt; &lt;br /&gt;&lt;br /&gt; &lt;!-- 组件：输入框--&gt; &lt;div class="input-group"&gt; &lt;span class="input-group-addon" id="basic-addon1"&gt;@&lt;/span&gt; &lt;input type="text" class="form-control" placeholder="Username" aria-describedby="basic-addon1"&gt; &lt;/div&gt; &lt;div class="input-group"&gt; &lt;input type="text" class="form-control" placeholder="Recipient's username" aria-describedby="basic-addon2"&gt; &lt;span class="input-group-addon" id="basic-addon2"&gt;@example.com&lt;/span&gt; &lt;/div&gt; &lt;div class="input-group"&gt; &lt;span class="input-group-addon"&gt;$&lt;/span&gt; &lt;input type="text" class="form-control" aria-label="Amount (to the nearest dollar)"&gt; &lt;span class="input-group-addon"&gt;.00&lt;/span&gt; &lt;/div&gt; &lt;label for="basic-url"&gt;Your vanity URL&lt;/label&gt; &lt;div class="input-group"&gt; &lt;span class="input-group-addon" id="basic-addon3"&gt;https://example.com/users/&lt;/span&gt; &lt;input type="text" class="form-control" id="basic-url" aria-describedby="basic-addon3"&gt; &lt;/div&gt; &lt;!--组件：导航条--&gt; &lt;nav class="navbar navbar-inverse"&gt; &lt;div class="container-fluid"&gt; &lt;!-- Brand and toggle get grouped for better mobile display --&gt; &lt;div class="navbar-header"&gt; &lt;button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1" aria-expanded="false"&gt; &lt;span class="sr-only"&gt;Toggle navigation&lt;/span&gt; &lt;span class="icon-bar"&gt;&lt;/span&gt; &lt;span class="icon-bar"&gt;&lt;/span&gt; &lt;span class="icon-bar"&gt;&lt;/span&gt; &lt;/button&gt; &lt;a class="navbar-brand" href="#"&gt;Brand&lt;/a&gt; &lt;/div&gt; &lt;!-- Collect the nav links, forms, and other content for toggling --&gt; &lt;div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1"&gt; &lt;ul class="nav navbar-nav"&gt; &lt;li class="active"&gt;&lt;a href="#"&gt;Link &lt;span class="sr-only"&gt;(current)&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;Link&lt;/a&gt;&lt;/li&gt; &lt;li class="dropdown"&gt; &lt;a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false"&gt;Dropdown &lt;span class="caret"&gt;&lt;/span&gt;&lt;/a&gt; &lt;ul class="dropdown-menu"&gt; &lt;li&gt;&lt;a href="#"&gt;Action&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;Another action&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;Something else here&lt;/a&gt;&lt;/li&gt; &lt;li role="separator" class="divider"&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;Separated link&lt;/a&gt;&lt;/li&gt; &lt;li role="separator" class="divider"&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;One more separated link&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;/ul&gt; &lt;form class="navbar-form navbar-left"&gt; &lt;div class="form-group"&gt; &lt;input type="text" class="form-control" placeholder="Search"&gt; &lt;/div&gt; &lt;button type="submit" class="btn btn-default"&gt;Submit&lt;/button&gt; &lt;/form&gt; &lt;ul class="nav navbar-nav navbar-right"&gt; &lt;li&gt;&lt;a href="#"&gt;Link&lt;/a&gt;&lt;/li&gt; &lt;li class="dropdown"&gt; &lt;a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false"&gt;Dropdown &lt;span class="caret"&gt;&lt;/span&gt;&lt;/a&gt; &lt;ul class="dropdown-menu"&gt; &lt;li&gt;&lt;a href="#"&gt;Action&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;Another action&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;Something else here&lt;/a&gt;&lt;/li&gt; &lt;li role="separator" class="divider"&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;Separated link&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;!-- /.navbar-collapse --&gt; &lt;/div&gt;&lt;!-- /.container-fluid --&gt; &lt;/nav&gt; &lt;br /&gt; &lt;!-- 巨幕 --&gt; &lt;div class="jumbotron"&gt; &lt;h1&gt;Hello, world!&lt;/h1&gt; &lt;p&gt;...&lt;/p&gt; &lt;p&gt;&lt;a class="btn btn-primary btn-lg" href="#" role="button"&gt;Learn more&lt;/a&gt;&lt;/p&gt; &lt;/div&gt; &lt;br /&gt; &lt;!-- 标签 --&gt; &lt;span class="label label-default"&gt;Default&lt;/span&gt; &lt;span class="label label-primary"&gt;Primary&lt;/span&gt; &lt;span class="label label-success"&gt;Success&lt;/span&gt; &lt;span class="label label-info"&gt;Info&lt;/span&gt; &lt;span class="label label-warning"&gt;Warning&lt;/span&gt; &lt;span class="label label-danger"&gt;Danger&lt;/span&gt; &lt;br /&gt; &lt;!-- 带表格的面版 --&gt; &lt;div class="panel panel-default"&gt; &lt;!-- Default panel contents --&gt; &lt;div class="panel-heading"&gt;Panel heading&lt;/div&gt; &lt;div class="panel-body"&gt; &lt;p&gt;带表格的面版&lt;/p&gt; &lt;/div&gt; &lt;!-- Table --&gt; &lt;table class="table"&gt; &lt;tr&gt; &lt;td&gt;#&lt;/td&gt; &lt;td&gt;First Name&lt;/td&gt; &lt;td&gt;Last Name&lt;/td&gt; &lt;td&gt;Username&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;1&lt;/td&gt; &lt;td&gt;Mark&lt;/td&gt; &lt;td&gt;Otto&lt;/td&gt; &lt;td&gt;@mdo&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 全局 CSS 样式123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;body&gt; &lt;!--全局 CSS 样式--&gt; &lt;!--表单--&gt; &lt;form&gt; &lt;div class="form-group"&gt; &lt;label for="exampleInputEmail1"&gt;Email address&lt;/label&gt; &lt;input type="email" class="form-control" id="exampleInputEmail1" placeholder="Email"&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;label for="exampleInputPassword1"&gt;Password&lt;/label&gt; &lt;input type="password" class="form-control" id="exampleInputPassword1" placeholder="Password"&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;label for="exampleInputFile"&gt;File input&lt;/label&gt; &lt;input type="file" id="exampleInputFile"&gt; &lt;p class="help-block"&gt;Example block-level help text here.&lt;/p&gt; &lt;/div&gt; &lt;div class="checkbox"&gt; &lt;label&gt; &lt;input type="checkbox"&gt; Check me out &lt;/label&gt; &lt;/div&gt; &lt;button type="submit" class="btn btn-default"&gt;Submit&lt;/button&gt; &lt;/form&gt; &lt;br /&gt; &lt;!--按钮--&gt; &lt;!-- Standard button --&gt; &lt;button type="button" class="btn btn-default"&gt;（默认样式）Default&lt;/button&gt; &lt;!-- Provides extra visual weight and identifies the primary action in a set of buttons --&gt; &lt;button type="button" class="btn btn-primary"&gt;（首选项）Primary&lt;/button&gt; &lt;!-- Indicates a successful or positive action --&gt; &lt;button type="button" class="btn btn-success"&gt;（成功）Success&lt;/button&gt; &lt;!-- Contextual button for informational alert messages --&gt; &lt;button type="button" class="btn btn-info"&gt;（一般信息）Info&lt;/button&gt; &lt;!-- Indicates caution should be taken with this action --&gt; &lt;button type="button" class="btn btn-warning"&gt;（警告）Warning&lt;/button&gt; &lt;!-- Indicates a dangerous or potentially negative action --&gt; &lt;button type="button" class="btn btn-danger"&gt;（危险）Danger&lt;/button&gt; &lt;!-- Deemphasize a button by making it look like a link while maintaining button behavior --&gt; &lt;button type="button" class="btn btn-link"&gt;（链接）Link&lt;/button&gt; &lt;br /&gt; &lt;!--按钮--&gt; &lt;img src="../img/1.jpg" alt="..." class="img-rounded"&gt; &lt;img src="../img/1.jpg" alt="..." class="img-circle"&gt; &lt;img src="../img/1.jpg" alt="..." class="img-thumbnail"&gt;&lt;/body&gt; JavaScript 插件Carousel carousel.js12345678910111213141516171819202122232425262728293031323334353637383940&lt;body&gt; &lt;!--JavaScript 插件--&gt; &lt;!--Carousel carousel.js--&gt; &lt;div id="carousel-example-generic" class="carousel slide" data-ride="carousel"&gt; &lt;!-- Indicators --&gt; &lt;ol class="carousel-indicators"&gt; &lt;li data-target="#carousel-example-generic" data-slide-to="0" class="active"&gt;&lt;/li&gt; &lt;li data-target="#carousel-example-generic" data-slide-to="1"&gt;&lt;/li&gt; &lt;li data-target="#carousel-example-generic" data-slide-to="2"&gt;&lt;/li&gt; &lt;/ol&gt; &lt;!-- Wrapper for slides --&gt; &lt;div class="carousel-inner" role="listbox"&gt; &lt;div class="item active"&gt; &lt;img src="../img/1.jpg" alt="..."&gt; &lt;div class="carousel-caption"&gt; ... &lt;/div&gt; &lt;/div&gt; &lt;div class="item"&gt; &lt;img src="../img/2.jpg" alt="..."&gt; &lt;div class="carousel-caption"&gt; ... &lt;/div&gt; &lt;/div&gt; ... &lt;/div&gt; &lt;!-- Controls --&gt; &lt;a class="left carousel-control" href="#carousel-example-generic" role="button" data-slide="prev"&gt; &lt;span class="glyphicon glyphicon-chevron-left" aria-hidden="true"&gt;&lt;/span&gt; &lt;span class="sr-only"&gt;Previous&lt;/span&gt; &lt;/a&gt; &lt;a class="right carousel-control" href="#carousel-example-generic" role="button" data-slide="next"&gt; &lt;span class="glyphicon glyphicon-chevron-right" aria-hidden="true"&gt;&lt;/span&gt; &lt;span class="sr-only"&gt;Next&lt;/span&gt; &lt;/a&gt; &lt;/div&gt;&lt;/body&gt;]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>Bootstrap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MCGS组态工程安装及注意事项]]></title>
    <url>%2F2018%2F11%2F12%2FMCGS%E7%BB%84%E6%80%81%E5%B7%A5%E7%A8%8B%E5%AE%89%E8%A3%85%E5%8F%8A%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%2F</url>
    <content type="text"><![CDATA[Step 1：主程序及驱动安装打开MCGS安装程序，点击自动运行程序(Autorun.exe) 进行自动安装。主程序安装完之后，需要继续安装驱动程序。 安装过程中，可能会弹出安装错误提示，选择“跳过”或“忽略”即可。 Step 2：USB To COM驱动程序安装打开并安装USB To COM驱动程序。如果电脑之前已经安装，则不需要重新安装。 Step 3：2个关键文件替换 将文件石油大学.mcg复制到安装目录下的Work文件夹中进行替换。 将文件夹用户定制设备复制到安装目录下的Programs/Drivers文件夹中进行替换。 注意：替换之前记录已经校准的各个压力的上下限。 Step 4：确认本机COM端口号按照以下步骤确认本机的COM端口号（以XP系统为例，win7相同）： 123456graph LRA[我的电脑]--&gt;|右击|B[管理]B--&gt;C[设备管理器]C--&gt;D[端口设置]D--&gt;E[高级]E--&gt;F[COM端口号=COM4] Step 5：调用石油大学定制组态工程点击桌面MCGS组态环境快捷方式，到达组态环境界面，并通过以下两步调用石油大学定制组态工程： 123graph LRA[文件]--&gt;B[打开工程]B--&gt;C[调用D:MCGS/Work/石油大学.mcg] 然后，可以通过点击组态环境工具栏中的图标（带有向下箭头），或者桌面MCGS组态工程快捷方式进入组态工程工作界面。 Step 6：调整压力计量时间间隔完成上述步骤后，在组态工程界面将压力采集间隔设置为30s。 通过上述6步即可完成MCGS组态工程的安装，下次使用可通过Step 5中所说的2种方式进入组态工程工作界面。 另外，若使用过程中出现工作界面弹不出来或者卡顿等问题，可通过重启程序，按照上述步骤检查，或者直接重启电脑。 注：本文档是在张昱师兄记录的基础上完善而成，供大家参考。 这篇文章的 PRESS.one 签名:“https://press.one/file/v?s=b2f970b065f161fdb727037fbda63925986b8da221ae472313337c2cb22e5271d225af36a9075f7ff434868bafed30d0e92debed04e205f0b062af7b6cad782d0&amp;h=8f9fe5f5343b6b05b2d7be922213aa7bfe458995d19bf46053ac018cbf68c40a&amp;a=5fff08474362b1e48d72b083abf18d2360881d5e&amp;f=P1&amp;v=2]]></content>
      <categories>
        <category>Research</category>
      </categories>
      <tags>
        <tag>Guide</tag>
        <tag>Petroleum</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery快速入门]]></title>
    <url>%2F2018%2F11%2F11%2FjQuery%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[jQuery是一个快速、简洁的JavaScript框架，它封装JavaScript常用的功能代码，提供一种简便的JavaScript设计模式，优化HTML文档操作、事件处理、动画设计和Ajax交互。jQuery设计的宗旨是“Write Less，Do More”，即倡导写更少的代码，做更多的事情。他是继Prototype之后又一个优秀的JavaScript代码库（或JavaScript框架）。 jQuery使用jquery是一个代码库(框架)，相当于java中能够的jar包，要使用，必须先导入。 jquery-1.8.3.js：一般用于学习，可读性强 jquery-1.8.3.min.js：用于项目使用阶段，可读性极差 jQuery参考文档： W3School:jQuery 教程 jQueryAPI中文文档 jQueryAPI英文文档 jQuery的快速入门 调用jQuery代码示例 12345678910111213141516&lt;script src="../js/jquery-1.8.3.js"&gt;&lt;/script&gt;&lt;script &gt; $(function()&#123;//全局加载函数,相当于window.onload //获取元素的一般方法 //var val1 = document.getElementById("name").value; //alert(val1); //jQuery获取元素 var val2 = $("#name").val(); alert(val2); &#125;)&lt;/script&gt;&lt;body&gt; &lt;input type="text" id="name" value="mike" /&gt;&lt;/body&gt; 将js对象转换成jQuery对象 1234567891011121314151617&lt;script src="../js/jquery-1.8.3.js"&gt;&lt;/script&gt;&lt;script&gt; $(function() &#123; //全局加载函数,相当于window.onload //获取js对象 var name = document.getElementById("name"); var val1 = name.value; //alert(val1); //将js对象转换成jQuery对象 var name2 = $(name); var val2 = name2.val(); alert(val2); &#125;)&lt;/script&gt;&lt;body&gt; &lt;input type="text" id="name" value="mike" /&gt;&lt;/body&gt; jQuery选择器基本选择器12345678910111213141516171819202122232425262728&lt;script&gt; $(function() &#123; //&lt;input type="button" value="选择 id为 one 的元素." id="btn1" /&gt; $("#btn1").click(function()&#123; $("#one").css("background-color","red"); &#125;); //&lt;input type="button" value="选择 class 为 mini 的所有元素." id="btn2" /&gt; $("#btn2").click(function()&#123; $(".mini").css("background-color", "green"); &#125;); //&lt;input type="button" value="选择 元素名是 div 的所有元素." id="btn3" /&gt; $("#btn3").click(function()&#123; $("div").css("background-color", "yellow"); &#125;); //&lt;input type="button" value="选择 所有的元素." id="btn4" /&gt; $("#btn4").click(function()&#123; $("*").css("background-color", "yellow"); &#125;); //&lt;input type="button" value="选择 所有的span元素和id为two的元素." id="btn5" /&gt; $("#btn5").click(function()&#123; $("span,#two").css("background-color", "yellow"); &#125;); &#125;)&lt;/script&gt; 层级选择器12345678910111213141516171819202122232425262728&lt;script&gt; $(function() &#123; //&lt;input type="button" value="选择 body内的所有div元素." id="btn1" /&gt; $("#btn1").click(function() &#123; $("body div").css("background-color", "yellow"); &#125;); //&lt;input type="button" value="在body内,选择子元素是div的。" id="btn2" /&gt; $("#btn2").click(function() &#123; $("body&gt;div").css("background-color", "red"); &#125;); //&lt;input type="button" value="选择 id为one 的下一个div元素." id="btn3" /&gt; $("#btn3").click(function() &#123; $("#one+div").css("background-color", "red"); &#125;); //&lt;input type="button" value="选择 id为two的元素后面的所有div兄弟元素." id="btn4" /&gt; $("#btn4").click(function() &#123; $("#two~div").css("background-color", "red"); &#125;); //&lt;input type="button" value="选择 id为two的元素的所有div兄弟元素." id="btn5" /&gt; $("#btn5").click(function() &#123; $("#two").siblings("div").css("background-color", "red"); &#125;); &#125;);&lt;/script&gt; 可见性12345678910111213&lt;script src="../js/jquery-1.8.3.js"&gt;&lt;/script&gt;&lt;script&gt; $(function()&#123; //alert($("input:hidden").val()); //alert($(":visible").size()); console.log($(":visible"));//打印日志 &#125;);&lt;/script&gt;&lt;body&gt; &lt;input type="hidden" value="hidden" /&gt; &lt;input type="text" value="visible" /&gt;&lt;/body&gt; 表单属性12345678910111213&lt;script type="text/javascript" src="../js/jquery-1.8.3.js"&gt;&lt;/script&gt;&lt;script&gt; $(function() &#123; //$("input:disabled").val("dis"); //alert($("#in").attr("id")); $("#in").attr("value", "hello"); &#125;);&lt;/script&gt;&lt;body&gt; &lt;input type="text" disabled="disabled" id="in" / value="disabled"&gt;&lt;br /&gt; &lt;input type="text" value="world" /&gt;&lt;/body&gt; 事件绑定123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;script type="text/javascript" src="../js/jquery-1.8.3.js" &gt;&lt;/script&gt;&lt;script&gt; $(function()&#123; //常规事件绑定 /*$("button").click(function()&#123; alert("点我干啥1"); &#125;);*/ //事件处理bind /*$("button").bind("click", function()&#123; alert("点我干啥2"); &#125;);*/ //事件处理on /*$("button").on("click", function()&#123; alert("点我干啥3"); &#125;);*/ //事件处理one /*$("button").one("click", function()&#123; alert("点我干啥4"); &#125;);*/ //事件切换toggle /*$("button").toggle(function()&#123; alert("点我干啥1"); &#125;,function()&#123; alert("点我干啥2"); &#125;,function()&#123; alert("点我干啥3"); &#125;);*/ //显示隐藏的匹配元素。效果show $("button").bind("click", function()&#123; $("p").show(1000); //$("p").show("slow"); //$("p").show("normal"); //$("p").show("fast"); &#125;) &#125;)&lt;/script&gt;&lt;body&gt; &lt;p style="display: none;"&gt;hello&lt;/p&gt; &lt;button&gt;点击&lt;/button&gt;&lt;/body&gt; 列表动态显示12345678910111213141516171819202122&lt;!-- 引入jQuery --&gt;&lt;script src="../js/jquery-1.8.3.js" type="text/javascript"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt; $(function()&#123; //隐藏第4个之后的品牌，保留最后的“其它品牌相机”继续显示 var cam = $("li:gt(4):not(:last)"); cam.hide(); //span绑定点击事件 $("span").click(function() &#123; if(cam.is(":hidden")) &#123; cam.show(1000); //更换span元素内容 //this.innerHTML = "隐藏更多品牌"; $(this).html("隐藏更多品牌"); &#125;else&#123; cam.hide(1000); //this.innerHTML = "隐藏更多品牌"; $(this).html("显示更多品牌"); &#125; &#125;); &#125;);&lt;/script&gt; 动画效果123456789101112131415161718192021222324&lt;script type="text/javascript" src="../js/jquery-1.8.3.js" &gt;&lt;/script&gt;&lt;script&gt; $(function()&#123; $("#b1").click(function()&#123; //$("img").show(1000); //$("img").slideDown(1000); //$("img").slideToggle(1000); $("img").fadeIn(1000); &#125;); $("#b2").click(function()&#123; //$("img").hide(1000); //$("img").slideUp(1000); $("img").fadeOut(1000); &#125;); &#125;);&lt;/script&gt;&lt;body&gt; &lt;div id="img" width="400px" height="400px"&gt; &lt;img src="../img/1.jpg" hidden="hidden" width="100%" height="100%"/&gt; &lt;/div&gt; &lt;button id="b1" &gt;显示图片&lt;/button&gt; &lt;button id="b2" &gt;隐藏图片&lt;/button&gt;&lt;/body&gt; 元素遍历123456789101112131415161718192021222324252627282930&lt;script type="text/javascript" src="../js/jquery-1.8.3.js" &gt;&lt;/script&gt;&lt;script&gt; $(function()&#123; //第一种方式：元素遍历 /* //$("input").val("hello");//所有元素赋值相同 $("input").each(function(i,n)&#123; //i 每个元素的索引 //alert(i); //n 每个元素对应的js对象 n.value = "hi, "+i; &#125;); */ //第二种方式：元素遍历 $.each($("input"), function(i,n) &#123; //alert(i); n.value = "hello, "+i; &#125;); &#125;);&lt;/script&gt;&lt;body&gt; &lt;input type="text" /&gt; &lt;input type="text" /&gt; &lt;input type="text" /&gt; &lt;input type="text" /&gt; &lt;input type="text" /&gt; &lt;input type="text" /&gt;&lt;/body&gt; 文档处理123456789101112131415161718192021222324252627282930313233&lt;!--文档处理简单案例1--&gt;&lt;script type="text/javascript" src="../js/jquery-1.8.3.js"&gt;&lt;/script&gt;&lt;script&gt; $(function()&#123; //将div2移动到div1 $("#div2").appendTo("#div1"); //div2添加内容"&lt;h1&gt;hello&lt;/h1&gt;" $("#div2").append("&lt;h1&gt;hello&lt;/h1&gt;"); &#125;);&lt;/script&gt;&lt;body&gt; &lt;div id="div1" style="width: 400px; height: 400px; background-color: yellow;"&gt;&lt;/div&gt; &lt;div id="div2" style="width: 100px; height: 100px; background-color: red;"&gt;&lt;/div&gt;&lt;/body&gt;&lt;!--文档处理简单案例2--&gt;&lt;script type="text/javascript" src="../js/jquery-1.8.3.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt; $(function()&#123; //三个元素全部移动 $("#left3").click(function()&#123; $("#leftSelectId option").appendTo("#rightSelectId"); &#125;); //移动选中的元素 $("#left2").click(function()&#123; $("#leftSelectId option:selected").appendTo("#rightSelectId"); &#125;); //移动第1个元素 $("#left1").click(function()&#123; $("#leftSelectId option:first").appendTo("#rightSelectId"); &#125;); &#125;);&lt;/script&gt; 页面加载1234567891011121314151617181920212223242526272829303132&lt;script type="text/javascript" src="../js/jquery-1.8.3.js" &gt;&lt;/script&gt;&lt;script type="text/javascript"&gt; //全局加载:方法内的代码在html页面加载完成后才会执行 //方式1 window.onload = function() &#123; var name = document.getElementById("name").value; //alert(name); //alert($("#name").val()); &#125; //方式二 $(function()&#123; var name = document.getElementById("name").value; //alert(name); //alert($("#name").val()); &#125;); //方式三 jQuery(function()&#123; var name = document.getElementById("name").value; //alert(name); //alert($("#name").val()); &#125;); //方式四 $(document).ready(function()&#123; var name = document.getElementById("name").value; //alert(name); //alert($("#name").val()); &#125;);&lt;/script&gt;&lt;body&gt; &lt;input type="text" id="name" value="mike" /&gt; &lt;br /&gt; &lt;button id="btn"&gt;点击&lt;/button&gt;&lt;/body&gt;]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常规驱油实验方案]]></title>
    <url>%2F2018%2F11%2F10%2F%E5%B8%B8%E8%A7%84%E9%A9%B1%E6%B2%B9%E5%AE%9E%E9%AA%8C%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[实验材料及仪器 聚合物溶液、岩心、模拟油（原油和煤油按照一定比例配制而成，混合比例需提前确定） 中间容器3个（模拟地层水、模拟油、聚合物溶液） 岩心夹持器、压力传感器 真空泵（岩心抽真空）、手摇泵（岩心加围压）、恒速恒压泵（动力源） 流变仪、紫外分光光度计 具塞量筒（50mL，1个），具塞试管（5mL，30个）其他（移液管等） 驱油实验步骤驱油实验步骤主要包括如下7个部分： 抽真空造束缚水 水测渗透率 饱和油 水驱 注聚合物 后续水驱 样品采集及实验目的 抽真空造束缚水首先，岩心烘干，量取岩心直径、长度，并称量岩心质量。然后，在-0.1MPa压力条件下，岩心抽真空造束缚水4h以上。最后，再次称量岩心质量，岩心吸水后增加的质量，即可得到岩心孔隙体积，并可计算出孔隙度。 测量岩心孔隙体积时，若管线较长，需扣除管线内水的体积。 另外，还可以直接在岩心夹持器内抽真空（无需称质量），抽完真空后岩心吸水体积即为岩心孔隙体积，并可计算出孔隙度。 水测渗透率选取高、中、低三个注入速度进行水测渗透率，取平均值，待岩心各测点的压力稳定即可转入下一阶段。 饱和油以合适的注入速度（如0.05mL/min）进行饱和油，出口端用量筒计量排出水的体积，直到不再出水，排出水的总体积即为饱和油体积。岩心饱和油之后老化12h，然后进行水驱。 非均质岩心饱和油时，低渗层在下，高渗层在上。 饱和油阶段时间较长，合理安排时间。 如果原油粘度很高，可以在高温条件下饱和油，然后恢复常温进行接下来的实验。 在高温条件饱和油，如果边升温边实验，因为热膨胀或者原油中溶解气析出，会导致采出液量远大于注入量的情况。因此，建议先将恒温箱温度升至目标温度，然后开始实验，保持实验过程中的温度基本不变。 水驱以合适的注入速度（如0.5mL/min）水驱至岩心出口端含水率高于98%，大概注水2PV左右（注意保持多组实验水驱PV数的一致性），转入聚合物驱阶段。 注聚合物以合适的注入速度（如0.5mL/min），注入0.3PV(通常是0.25-0.5PV)，然后转入后续水驱。 后续水驱聚合物驱结束，转入后续水驱阶段，以相同的注入速度进行后续水驱，直至岩心各测点压力稳定。需要注意的是：尽可能缩短前后两个阶段的转换时间，因为岩心各测点的压力会快速下降。 样品采集及实验目的采样原则 使用合适量程的量筒不间断计量出油体积。 采样间隔6min，用5ml试管取样，样品体积约3mL。 液测渗透率后换压力传感器，然后再饱和油，避免原油泄漏。 管线出口端应加橡皮塞，为避免采出油沾到试管壁，便于读数。 采样后，放置几分钟，待油水分层后读取示数。 水驱：0.5PV开始采样，计算含水率，含水率到达98%转入下一阶段。样品全部收集到100mL具塞量筒。 聚合物驱：按照上述采样原则，持续采样，计算含水率，用5mL试管单独盛放每个采集样品（需要测量聚合物浓度）。 后续水驱：按照上述采样原则，持续采样，计算含水率，每个样品一个5mL试管，样品单独放置（需要测量聚合物浓度）。 实验目的和测量指标实验目的：驱油效率，波及效率，见聚时间（聚合物滞留量，粘度损失）。 测量指标：含水率，浓度（粘度）。 根据测量指标达到实验目的： 计量每个样品的体积（油、水），计算含水率及最终驱油效率。 测量样品浓度，确定岩心出口端的见聚时间。（并根据聚合物的总注入量，计算聚合物在岩心中滞留量） （最后测试样品粘度，明确聚合物溶液的粘度损失情况。） 数据处理注意事项 计算注入孔隙体积(PV)时，应当以岩心出口端采出的液体量而计算得到的PV数为准。 简单用泵速乘以实验时间计算得到的PV数是偏大的，因为岩心中的实际流速要低于设定的泵速。 这篇文章的 PRESS.one 签名:“https://press.one/file/v?s=fd1b726164a6b4303d248e891a271a7eac2208cfb588464fa2772c584092a644224958acb34a48ce386828941074283119a7a911f82d3ae1068f2d66f6649f841&amp;h=7528596698111a68070e79cc2f7ca3ade590c46d377af1a5b8c888b3a5db25d6&amp;a=5fff08474362b1e48d72b083abf18d2360881d5e&amp;f=P1&amp;v=2]]></content>
      <categories>
        <category>Research</category>
      </categories>
      <tags>
        <tag>Guide</tag>
        <tag>Petroleum</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[七牛云测试域名过期，存储图片的下载方法]]></title>
    <url>%2F2018%2F11%2F09%2F%E4%B8%83%E7%89%9B%E4%BA%91%E6%B5%8B%E8%AF%95%E5%9F%9F%E5%90%8D%E8%BF%87%E6%9C%9F%EF%BC%8C%E5%AD%98%E5%82%A8%E5%9B%BE%E7%89%87%E7%9A%84%E4%B8%8B%E8%BD%BD%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[作为免费图床，七牛云是很好选择之一。但是，自上个月起，七牛云开始回收测试域名，即便重新分配测试域名也是30天之后自动回收，详见七牛云官方通告：测试域名使用规范。 七牛云邮件提醒回收测试域名时，没有及时下载备份存储的图片？ 七牛云测试域名回收之后，原来通过外链引用的图片失效？ 想要更新外链，七牛云存储的图片 却无法直接下载？ 此情此景，百度一下，不少人像我一样有如此遭遇。下面根据查找的资料，给出解决方法： 新建存储空间(bucket)重新创建一个新的存储空间，会自动分配一个新的测试域名，选择的地区（如华北）应与原存储空间选择的地区相同。 批量复制(batchcopy)七牛云命令行工具(qshell)批量复制及下载均需要借助七牛云的命令行工具(qshell)，下载地址、使用指南及常用命令参见：命令行工具(qshell)。 根据系统下载命令行工具(qshell)，以win7系统为例进行详细说明，避免入坑： 下载命令行工具后，为了便于使用，将与系统对应的exe文件重命名为qshell.exe。 打开系统命令行工具，将qshell.exe文件所在目录设置为当前工作目录，才可以使用七牛云命令行工具(qshell)。如果不设置前两步而直接运行EXE文件则闪退。 设置秘钥。秘钥可在“个人面板/秘钥管理”页面查看12$ qshell account AccessKey SecretKey //设置秘钥$ qshell account //查看秘钥 获取仅有文件名的文件列表批量复制batchcopy命令，需要用到仅有文件名的文件列表。 获取原存储空间的完整文件列表（包含文件名、类型、日期等） 12//bucketname：原存储空间名称；list.txt：原存储空间文件列表的保存文件$ qshell listbucket bucketname list.txt 获取仅有文件名的文件列表。对于wins系统，简单粗暴的做法就是，将刚刚获取的list.txt粘到excel表格中，然后将第1列文件名粘贴到新的文件如name.txt。如果有文件名含中文，则需要将txt文件的编码方式转为UTF-8编码，否则复制名称含中文的文件时会报错。不过，其他文件并不受影响。 批量复制文件至新存储空间1234567/* -force 加入此选项不需要输入验证码&lt;SrcBucket&gt; 原存储空间名称&lt;DestBucket&gt; 新建存储空间名称&lt;SrcDestKeyMapFile&gt; 需要复制的文件列表，即上述得到的name.txt*/$ qshell batchcopy -force &lt;SrcBucket&gt; &lt;DestBucket&gt; &lt;SrcDestKeyMapFile&gt; 批量下载(qdownload)复制完成之后，可以进入新的存储空间进行确认复制是否成功。 123//[&lt;ThreadCount&gt;]: 同时下载文件数量（1-2000），默认为5//&lt;LocalDownloadConfig&gt;: 配置文件，如tmp.conf$ qshell qdownload [&lt;ThreadCount&gt;] &lt;LocalDownloadConfig&gt; 需要在上述qshell.exe文件所在目录新建配置文件，以.conf为后缀，如tmp.conf。配置文件的内容如下：123456789101112/*dest_dir 下载文件存储目录。wins下目录示例 D:\\jemy\\backup，尽量不要出现中文，否则涉及编码问题bucket 新建存储空间的名称suffixes 下载文件的后缀cdn_domain 新建存储空间的CDN测试域名，可在新存储空间页面查看*/&#123; "dest_dir" : "&lt;LocalBackupDir&gt;", "bucket" : "&lt;Bucket&gt;", "suffixes" : ".png,.jpg", "cdn_domain" : "down.example.com",&#125; 配置完成，就可以开始批量下载了，好运！]]></content>
      <categories>
        <category>Guide</category>
      </categories>
      <tags>
        <tag>七牛云</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[专属你的青海湖旅游攻略]]></title>
    <url>%2F2018%2F11%2F08%2F%E4%B8%93%E5%B1%9E%E4%BD%A0%E7%9A%84%E9%9D%92%E6%B5%B7%E6%B9%96%E6%97%85%E6%B8%B8%E6%94%BB%E7%95%A5%2F</url>
    <content type="text"><![CDATA[本攻略包含两部分可供你参考的内容： 我们青海湖旅行的见闻及遇到的问题； 建议青海湖旅行路线及相关注意事项。 第一部分：我们青海湖旅行的见闻 从火车站出来，西宁给人的第一感觉：清爽。 环青海湖旅行主要有三种方式： 跟团(360/2天，来自去哪儿网和蚂蚁窝) 包车(600/天，1000/2天，来自火车站师傅报价) 自由行。 我们是乘坐大巴自由行，环青海湖旅行路线： 二郎剑景区–&gt; 黑马河乡 –&gt;茶卡盐湖 第一站：二郎剑景区（151基地） 交通：西宁火车站出站，左手边就是汽车站，有旅游大巴到青海湖，在二郎剑景区下车，3h车程，车票35/人。坐在大巴去青海湖的一路上，也能饱览青海地区的独特风景。（20170822，12:00-15:00） 门票价格：100/人，美团95/人，自助取票。 开放时间：全天开放 参观耗时：2h 观后感：置身二郎剑景区，近距离接触青海湖，近处的湖面在微风的吹拂下泛起阵阵涟漪，远处碧水蓝天，白云高山，相映成趣。 建议：总体而言，青海湖二郎剑景区本身并没有什么特别引人注目的地方。不过，从黑马河乡返回西宁时，途径二郎剑景区，如果有时间也不妨停下来看看，说不定有意外的收获。 第二站：黑马河乡 二郎剑景区到黑马河乡，1h车程，票价30/人。（17:00-18:00） 在宾馆稍作休息后，去超市买了些零食，然后伴着落日和晚霞，从宾馆后面向青海湖边走去。 穿过几道铁丝网，越靠近湖边草原上的水越多，以至于无法靠近湖边，只好远远眺望。 不幸的是，第二天早上下雨，所以并没有看到预想的日出。 第三站：茶卡盐湖 交通从黑马河乡徒步近2h，大概8km路程，终于拦到一辆西宁到乌兰的大巴，途径茶卡盐湖，车程1h左右，票价25/人。路上也拦了很多辆从西宁到敦煌、兰州的大巴，但司机都不停车。徒步过程中，沿途的风景非常美，手机拍照效果不佳，美景唯有留在心中。（20170823，10:00-11:50）从茶卡盐湖下车，步行3km，耗时50min，到达茶卡盐湖景区，如坐出租车，大概10min左右。 门票价格：70/人，有自助购票机。去哪儿或携程购买门票68/人，可直接扫二维码进入景区。 参观耗时：步行参观时长3h，路程约11km。 观后感：进入景区，到达天空之境广场，此时丝毫看不到茶卡盐湖的“天空之境”的踪迹，只看到游人如织，人在蓝天白云和连绵高山的衬托下如同蝼蚁。往前走，一代天骄成吉思汗的盐雕在蓝天白云巍然屹立。一步步走向茶卡盐湖，天空之境渐入眼帘，洁白的湖面，倒映着蓝天白云，周围的连绵高山与天相接。许多游人脱下鞋子，走到湖中拍照，以洁白湖面和蓝天白云为背景，游人显得愈发美丽，更加纯粹。 返回西宁：五点从茶卡盐湖景区出来，经过询问，乘坐出租车去茶卡镇坐大巴。出租车司机，飞一般的速度把我们送到汽车站，刚好赶上五点二十的最后一班返回西宁的大巴，预计耗时五个小时，于十点半到达西宁汽车站。不幸的是，大巴车档位错乱，中途停了两次，比预计晚了两个小时，十二点半到目的地。第一次停车期间，我快速爬到了一座山头，站在海拔3800m的山顶俯瞰青海湖。一路小跑上山，喘得很厉害，有点高原反应的意思，所以不得不降低速度，不过下山就快了许多，山坡比较舒缓，而且刚下山没多久，大巴就再次出发。 旅途虽有坎坷，却已留下我们的足迹，都将成为今后的回忆。 第二部分：建议青海湖旅行路线7-8月是环青海湖旅行的最佳季节，7月中旬到8月中旬则是青海湖看油菜花的绝好时机。建议青海湖旅行路线如下，并分别各景区的门票价格、参观耗时、交通及注意事项等进行简单介绍。 茶卡盐湖–&gt;|大巴|–&gt;黑马河乡–&gt;|徒步|–&gt;环湖西路 本攻略是青海湖两到三天的旅游路线规划，但涵盖内容有限。想了解更多详细内容可参考：蚂蜂窝旅游攻略——青海湖旅游。 茶卡盐湖：欣赏天空之境 交通： 火车：Y961(西宁-茶卡)，上午8:25开车，直达茶卡盐湖景区，硬座成人票价62.5，耗时4h，正点到达茶卡的时间是12:23。 大巴：汽车站(火车站旁)坐大巴，5h车程，直达茶卡镇，然后坐出租车到茶卡盐湖景区，下午参观茶卡盐湖(耗时3h)。 门票价格：70/人，去哪儿或携程购买门票68/人，可直接扫二维码进入景区。 开放时间：7:00～18:30 参观耗时：3小时 注意事项：从西宁到茶卡，如果乘大巴，最好坐8:00的大巴。因为西宁到茶卡镇有5h车程，参观景区耗时3h，坐出租往返茶卡镇和景区以及中途歇息吃饭还需要约1h，所以最快17:00才到茶卡镇汽车站，赶上从茶卡镇到黑马河乡的最晚一趟17:20的大巴。为了节省体力和时间，可坐小火车到茶卡盐湖中央，返回时徒步，慢慢欣赏沿途的美景。 黑马河乡：观赏日落日出最好赶在17:20之前，坐大巴去黑马河乡(耗时1h)，当晚在黑马河乡下榻。黑马河乡是位于青海湖西南部，是距离环湖西路最近的补给点，乘大巴去茶卡盐湖需从此翻越3800m的橡皮山。黑马河乡是青海湖观赏日出的最佳地点之一。 食宿：黑马河乡的马路两旁都是宾馆和小饭馆，所以吃饭和住宿很好解决。需要注意的是，当地的自来水很凉，宾馆可能是用太阳能提供热水，如遇阴雨天气，热水可能并不热，建议入住前试一下热水温度。 观赏日落和日出：订好宾馆后，可以走到宾馆后边的草原上看看日落，如果天还很亮，可以看到远处的青海湖。你可能想从草原上走到青海湖边，但由于越靠近湖边草原上的水越多，以至于根本无法到达湖边，正因为如此，使得青海湖可望而不可及。另外，当天晚上查一下共和县第二天的日出时间，以便第二天如约和日出相遇。 环湖西路：沿青海湖徒步 由于没能去亲自去环湖西路，所以该部分内容主要参考蚂蜂窝青海湖旅游攻略上面的介绍。 黑马河乡是环湖西路的起点，黑马河乡至石乃亥乡共41km的环湖西路是青海湖最美路段。 其中，环湖西路的13-16km处是距湖最近点，下了公路步行3-5min即可到达湖边亲手触摸到湖水，风景绝佳，环湖西路上的民宿是夜晚观看璀璨星空的绝佳地点。 而且，环湖西路在不同的季节呈现出不同的美景： 5月，野花绽放、群鸟飞翔； 8月，万亩油菜花在湖畔灿烂盛开； 10月，繁华过尽，草原归于平静，青海湖呈现出最朴素的自然美。 交通：从黑马河乡到石乃亥乡：有绿色班车，如果包车前往，费用在150左右。另外，从黑马河乡到西宁：有茶卡或乌兰至西宁的大巴路过黑马河乡，4h车程，40/人。 注意事项 天气：昼夜温差大，天气变化快，长衣长裤必备。 防晒：气候干燥，紫外线强，携带防晒品。 高原反应：景区海拔3000m以上，最好携带抗高反药品（如携氧片、红景天等），特别是上了年纪的人。 拍照：由于多需要拍远景，手机拍照显得有点相形见绌，所以想要拍出美丽的照片，相机就显得非常有必要。 旅行是一场考验体力和财力的视觉盛宴，小伙伴且行且珍惜。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>青海湖</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java开发环境配置]]></title>
    <url>%2F2018%2F11%2F07%2FJava%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[下载安装编辑器：Notepad++|Sublime Text 3|Atom，任选其一即可。 下载安装JDK：Java SE 8 Archive Downloads，需要注册oracle账户。 环境变量配置（基于win7系统） 计算机-&gt;右击，属性-&gt;高级系统设置-&gt;环境变量-&gt;新建系统变量： 变量名：JAVA_HOME 变量值：C:\Program Files\Java\jdk1.8.0_172（即jdk安装目录） -&gt;更改系统变量Path在最左侧添加： %JAVA_HOME%\bin;]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>Guide</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript快速入门]]></title>
    <url>%2F2018%2F11%2F06%2FJavaScript%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[Javascript概述 JavaScript一种直译式脚本语言，是一种动态类型、弱类型、基于原型的语言，内置支持类型。它的解释器被称为JavaScript引擎，为浏览器的一部分，广泛用于客户端的脚本语言，最早是在HTML（标准通用标记语言下的一个应用）网页上使用，用来给HTML网页增加动态功能。 JavaScript是因特网上最流行的脚本语言。因脚本语言不能单独使用，必须嵌入到其他语言中组合使用。所以JavaScript不能单独使用，必须和其他语言（HTML）结合使用。 JavaScript由浏览器解释执行（解释一条，执行一条。故写代码时能用一条语句就不要用两条语句）。所以JavaScript代码必须强调效率和可读性；JavaScript代码遇到错误，解析引擎停止 Javascript的作用及特点Javascript的作用： JS可以控制前端页面的逻辑操作书写规范 JS可以控制CSS的样式； JS可以对表单项进行校验（主要作用） JS可以对HTML元素进行动态控制 Javascript的特点： 安全性（没有访问系统文件权限，无法用来做木马病毒） 跨平台性（浏览器有JS解析器，有浏览器就能运行JS代码，和平台无关） 交互性（JavaScript控制HTML元素） Javascript组成部分 ECMAScript，描述了Javascript的语法和基本对象。 文档对象模型（DOM），描述处理网页内容的方法和接口。 浏览器对象模型（BOM），描述与浏览器进行交互的方法和接口。 JavaScript和HTML的结合方式JavaScript在HTML中有两种使用方式： 内部使用方式。 代码示例如下12345&lt;script type="text/javascript"&gt; //JavaScript的代码 var str = "Hello JS"; alert(str);&lt;/script&gt; 外部使用方式。 外部引用时script标签内不能有script代码，即使写了也不会执行。代码示例如下12&lt;script type="text/javascript" src="../js/test.js"&gt;&lt;/script&gt; Javascript基本语法参考文档：W3School:JavaScript 教程 注释单行注释 //单行注释内容 多行注释 /*多行注释内容 第二行注释 第三行注释 */ 变量JavaScript变量的声明JavaScript中所有类型的变量声明都用var关键字。 变量以字母开头，也可以 $ 和 _ 符号开头（不推荐） 变量名称对大小写敏感 JavaScript变量的数据类型分为：原始数据类型和引用数据类型 JavaScript原始数据类型 string，字符串类型，””和’’都表示字符串； boolean，布尔类型，true、false； number，数字类型：整数、小数和NaN（Not a Number）。其中，NaN!=NaN； null，空，对象的占位符，表示引用类型的对象不存在； undefined，值未定义，即声明变量未赋值，系统会自动赋值undefined。其中，undefined==undefined。 变量定义代码示例如下：123456789101112131415161718&lt;script type="text/javascript"&gt; var str = "hi"; var num1 = 12; var num2 = 12.0; var num3 = "12.0l"; var b = true; var n =null; var a; alert(typeof(str)); //string alert(typeof(num1)); //number alert(typeof(num2)); //number alert(typeof(num3)); //string alert(typeof(b)); // boolean alert(typeof(n)); // object alert(typeof(a)); // undefined alert(c); // undefined&lt;/script&gt; 其中，undefined容易和”变量未声明就使用”混淆。“变量声明未赋值时使用”或”对象的属性未赋值时使用”都会出现undefined。但如果变量”未声明”就使用，JavaScript会报错”变量未定义”并截停代码。123456//变量声明未赋值时使用： var str; alert(str);//undefined//变量未声明就使用： alert(a);//报错，并且截断javascript代码 引用数据类型Javascript引用数据类型如下，可以参考w3school：JavaScript 对象，后面结合函数部分会选取其中的Date和RegExp进行深入学习。 Javascript常用对象-Boolean Javascript常用对象-Number Javascript常用对象-Array Javascript常用对象-String Javascript常用对象-Date Javascript常用对象-Math Javascript常用对象-RegExp 运算符算数运算符 加号+：算术运算加；字符串连接符。 减号-：算术运算减；数字转换符，会把其他值转换成数字。 string转number 如果string可以转换成number，那么转换后算术运算 如果不能转换成number，那么整体NaN boolean转number True---&gt;1 False---&gt; 0 null转number 转换成0 undefined转number 转成NaN NaN和其他数字运算都是NaN 1234567891011121314151617&lt;script&gt; var a = 12; var b = 2; var c = "12"; var d = 10.2; var t = true; var n = null; var u; alert(a+b); // 12 alert(a+c); // 1212 alert(a+d); // 22.2 alert(typeof(-c)); // number alert(a-c); // 0 alert(a-t); // 11 alert(a-n); // 12 alert(a-u); // NaN&lt;/script&gt; 比较运算符== 比较值 === 比较值和类型。 如果变量值和变量类型都相同，那么true，有一个不同则为false。 != 比较值 !== 全不等。比较值或比较类型，有一个不同即为不同，true。值和类型都相同，则为false。 代码示例：1234567891011121314151617181920&lt;script&gt; var x=8; alert(x==8); //true alert(x===8); //true alert(x=="8"); //true alert(x==="8"); // false alert(x!=8); // false alert(x!=1); //true alert(x!==8); //false alert(x!==1); //true alert(x!="8"); //false alert(x!="1"); //true alert(x!=="8"); //true alert(x!=="1"); //true&lt;/script&gt; 逻辑运算符&amp;&amp; 逻辑与 || 逻辑或 ！ 非 注：使用以上逻辑运算符，最终都会用boolean类型运算，若不是boolean类型，则进行转换。 number转boolean：-0或0或NaN转换成false，其他为true; string转boolean：&quot;&quot;为false，其他为true; null转boolean：转为false; undefined转boolean：转为false; 对象转boolean：转为true; 综上：0、-0、null、””、undefined、NaN，转换为false，否则转换为true。 流程控制语句判断语句与java相同，代码示例： 123456var a = 12;if(a)&#123; alert(a);&#125; else&#123; alert(-1);&#125; 循环语句：常用的是for循环，while和switch用的比较少。区别于Java中的增强for，JavaScript中的增强for遍历数组时，其中变量代表的是数组的下标，而且无需写定义变量符号（var）。 代码示例： 123456789101112&lt;script&gt; var arr = [1, 2, 3, 4, 5, 6]; alert(arr.length); //输出数组长度 //普通for循环 for(var i = 0; i &lt; arr.length; i++) &#123; alert(arr[i]); &#125; //增强for循环 for(i in arr)&#123; alert(arr[i]); &#125;&lt;/script&gt; Javascript的方法（函数）Javascript的方法示例Javascript函数创建及调用方式如代码示例所示。与java相比，Javascript函数有返回值无需声明返回值类型，没有返回值也无需声明void。123456789101112131415161718&lt;script type="text/javascript"&gt; //最常用创建函数的方法 function add(a, b) &#123; return a + b; &#125; //创建函数的方法2 var add = function(a, b) &#123; return a + b; &#125; //创建函数的方法3 var add = new Function("a", "b","return a + b");//参数列表，函数体 //调用函数 var sum = add(1,2); alert(sum);&lt;/script&gt; 使用add(1,2,3,4)调用上述代码示例中的add函数，如果在java中是会报错的，但是对于javascript来说，不会报错。也就是说，在javascript中，函数调用时传递的参数不一定要与函数声明时的参数个数一致。而且当调用函数时传递的参数与函数定义时参数个数不一致时，可以借助一个特殊对象arguments，来获取函数中的所有参数。代码示例如下：123456789101112&lt;script type="text/javascript"&gt; //最常用创建函数的方法 function add(a, b) &#123; // return a + b; alert(arguments.length); //返回传入参数个数 for(i in arguments)&#123; //逐个打印传入的参数 alert(arguments[i]); &#125; &#125; //调用函数，依次返回传入参数个数，及各个参数值 add(1,2,3,4);&lt;/script&gt; 日期对象-DateDate 对象用于处理日期和时间。Date 对象具有很多方法，可参考JavaScript Date 对象参考手册。借助Date 对象实现一个简单的动态时钟，代码示例如下:12345678910111213141516171819202122232425262728&lt;body&gt; &lt;h1 id="clock"&gt;&lt;/h1&gt;&lt;/body&gt;&lt;script type="text/javascript"&gt; //创建一个动态时钟，每隔一秒跳动一次。 function clock() &#123; //1. 创建Date 对象，它会自动把当前日期和时间保存为其初始值。 var d = new Date(); //2. 获取时间，时分秒 var h = d.getHours(); var m = d.getMinutes(); var s = d.getSeconds(); h = (h &lt; 10) ? "0" + h : h; m = (m &lt; 10) ? "0" + m : m; s = (s &lt; 10) ? "0" + s : s; //3. 获取元素，doccument对象方法 var h1 = document.getElementById("clock"); //4. 向元素中插入获取的时间 h1.innerHTML = h + ":" + m + ":" + s; &#125; //5. 动态时钟。setInterval方法是在函数体之外调用， //setInterval方法有两个参数：1. 调用方法名称（注意括号，引号）；2. 时间间隔，单位毫秒 setInterval("clock()", 1000);&lt;/script&gt; 正则表达式-RegExp使用正则表达式对输入框的数据进行校验，代码示例如下。123456789101112131415161718192021222324&lt;body&gt; username: &lt;input type="text" id="name" value="hellomike" /&gt; &lt;span id="msg"&gt;&lt;/span&gt;&lt;/body&gt;&lt;script type="text/javascript"&gt; //使用正则表达式对输入框的数据进行校验 function checkname() &#123; //1. 定义正则表达式 rex = /^[a-zA-Z]&#123;6,12&#125;$/; //2. 获取输入框中的内容 var name = document.getElementById("name").value; //3. 校验输入内容是否合法，并输出校验结果 if(rex.test(name)) &#123; //如果输入内容合法，则输出“格式正确” document.getElementById("msg").innerHTML = "&lt;font color='green'&gt;格式正确&lt;/font&gt;"; &#125; else &#123; document.getElementById("msg").innerHTML = "&lt;font color='red'&gt;格式不正确&lt;/font&gt;"; &#125; &#125; //调用函数 checkname();&lt;/script&gt; 事件的绑定事件： 记录用户在浏览器上的操作行为。 事件源： 触发事件的元素。 事件和方法的绑定： 当触发事件的时候执行具体的某个方法。 在javascript中，事件经常与函数一起使用，事件与函数绑定，就是某个事件被触发后，函数被调用。事件与函数绑定通常有两种方法： 在事件源元素上直接写事件属性，并赋值方法名（别忘了函数的小括号）。代码示例如下： 12345678&lt;body&gt; &lt;button id="btn" onclick="test()"&gt;点我&lt;/button&gt;&lt;/body&gt;&lt;script&gt; function test()&#123; alert("点我，干啊哈"); &#125;&lt;/script&gt; 先获取事件源元素，然后给事件属性赋值方法。代码示例如下： 12345678&lt;body&gt; &lt;button id="btn"&gt;点我&lt;/button&gt;&lt;/body&gt;&lt;script&gt; document.getElementById("btn").onclick = function()&#123; alert("又点我，作甚"); &#125;&lt;/script&gt; DOM对象当网页被加载时，浏览器会创建页面的文档对象模型（Document Object Model），页面加载HTML文档，HTML文档内部遵循文档对象模型规范，其内部维护一个DOM树模型(如同HTML源代码一样一层一层)。DOM对象就是用来操作DOM树的。 获取单个或多个元素DOM对象可以操作dom文档中的任何元素、元素的属性和文本。代码示例： 123456789101112131415&lt;body&gt; username: &lt;input type="text" id="nick" value="mike" class="input" /&gt; &lt;br /&gt; E-mail: &lt;input type="text" id="email" value="123@qq.com" class="input" /&gt; &lt;br /&gt; gender: &lt;input type="text" id="gender" value="man" class="input" /&gt; &lt;br /&gt;&lt;/body&gt;&lt;script&gt; //获取单个元素 var name = document.getElementById("nick").value; //alert(name); //获取多个元素 var ins = document.getElementsByClassName("input"); var ins2 = document.getElementsByTagName("input"); alert(ins.length);&lt;/script&gt; JavaScript综合案例表单校验案列1234567891011121314151617181920212223242526272829303132333435363738394041&lt;body&gt; &lt;!--表单校验；校验用户名和密码，两者均合法才能跳转到注册成功页面。 onsubmit事件比较特殊，需要有返回值。 submit.html与本文件在相同目录下。 --&gt; &lt;form action="submit.html" onsubmit="return checkall()"&gt; username:&lt;input type="text" id="name" value="hellomike" onblur="check('name')"/&gt; &lt;span id="namespan"&gt;&lt;/span&gt;&lt;br /&gt; password:&lt;input type="password" id="pwd" value="123456" onblur="check('pwd')"/&gt; &lt;span id="pwdspan"&gt;&lt;/span&gt;&lt;br /&gt; &lt;button type="submit"&gt;submit&lt;/button&gt; &lt;/form&gt;&lt;/body&gt;&lt;script&gt; //提交数据前，校验输入数据是否都合法，都合法返回true，否则false function checkall()&#123; var rex = /^[a-zA-Z0-9]&#123;6,8&#125;$/; var name = document.getElementById("name").value; var pwd = document.getElementById("pwd").value; if(rex.test(name) &amp;&amp; rex.test(pwd))&#123; return true; &#125; else&#123; return false; &#125; &#125; //校验用户名和密码 function check(id)&#123; //获取输入数据，即用户名或密码 var nick = document.getElementById(id).value; //定义正则表达式，校验数据 var rex = /^[a-zA-Z0-9]&#123;6,8&#125;$/; if(rex.test(nick))&#123; //输出校验结果 document.getElementById(id+"span").innerHTML = "&lt;font color='green'&gt;格式正确&lt;/font&gt;"; &#125;else&#123; document.getElementById(id+"span").innerHTML = "&lt;font color='red'&gt;不格式正确&lt;/font&gt;"; &#125; &#125;&lt;/script&gt; 鼠标悬浮变色案例1234567891011121314151617181920212223242526272829303132333435363738&lt;body&gt; &lt;!--生成3行3列表格--&gt; &lt;table border="1px" cellspacing="0" width="300px" bgcolor="green"&gt; &lt;caption&gt;3行3列数字表格&lt;/caption&gt; &lt;tr&gt; &lt;td&gt;1&lt;/td&gt; &lt;td&gt;2&lt;/td&gt; &lt;td&gt;3&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;1&lt;/td&gt; &lt;td&gt;2&lt;/td&gt; &lt;td&gt;3&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;1&lt;/td&gt; &lt;td&gt;2&lt;/td&gt; &lt;td&gt;3&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/body&gt;&lt;script&gt; //获取所有表格行元素 var trs = document.getElementsByTagName("tr"); for(i in trs)&#123; //鼠标滑过单元格背景色变白色 trs[i].onmouseover = function()&#123; this.style.backgroundColor = "white"; &#125; //鼠标滑过单元格背景色恢复原色（绿色） trs[i].onmouseout = function()&#123; this.style.backgroundColor = "green"; &#125; &#125;&lt;/script&gt; 动态切换图片案列 图片手动切换 123456789101112131415161718&lt;body&gt; &lt;div&gt; &lt;img id="picture" width="300" height="300" src="../img/0.jpg"/&gt; &lt;/div&gt; &lt;input type="button" value="手动切换图片" onclick="imageUpdate()" /&gt;&lt;/body&gt;&lt;script type="text/javascript"&gt; var i = 0; function imageUpdate()&#123; i++; document.getElementById("picture").src = "../img/" + i + ".jpg"; //图片名称分别为0，1，2，3，4 if(i == 5)&#123; i = 0; &#125; &#125;&lt;/script&gt; 图片动态切换 1234567891011121314151617&lt;body&gt; &lt;div id=""&gt; &lt;img id="img" width="300px" height="300px" src="../img/0.jpg"/&gt; &lt;/div&gt; &lt;/body&gt;&lt;script type="text/javascript"&gt; var i = 0; function imageUpdate()&#123; document.getElementById("img").src = "../img/"+ i +".jpg/"; i++; //图片名称分别为0，1，2，3，4 i = (i==5)?0:i; &#125; //每隔1s调用函数1次，以实现图片动态切换 setInterval("imageUpdate()",1000);&lt;/script&gt; 全选/反选案例12345678910111213141516171819202122232425262728293031323334353637&lt;body&gt; &lt;table border="1px" cellspacing="0" width="500px" bgcolor="#FF0000"&gt; &lt;caption&gt;3x4 Table&lt;/caption&gt; &lt;tr&gt; &lt;!-- 点击复选框调用check函数，并将第一个复选框的选中状态作为参数传给check函数 --&gt; &lt;td&gt;&lt;input type="checkbox" onclick="check(this.checked)"/&gt;全选/反选&lt;/td&gt; &lt;td&gt;1&lt;/td&gt; &lt;td&gt;2&lt;/td&gt; &lt;td&gt;3&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;input type="checkbox"/&gt;&lt;/td&gt; &lt;td&gt;1&lt;/td&gt; &lt;td&gt;2&lt;/td&gt; &lt;td&gt;3&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;input type="checkbox"/&gt;&lt;/td&gt; &lt;td&gt;1&lt;/td&gt; &lt;td&gt;2&lt;/td&gt; &lt;td&gt;3&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;/body&gt;&lt;script&gt; function check(data)&#123; //获取复选框所在单元格元素 var ins = document.getElementsByTagName("input"); //将第一个复选框的选中状态传递给剩余复选框，以实现全选或反选 for(i in ins)&#123; ins[i].checked = data; &#125; &#125;&lt;/script&gt; 城市的二级级联12345678910111213141516171819202122232425262728293031323334353637383940&lt;body&gt; &lt;table&gt; &lt;tr&gt; &lt;td&gt;出生地&lt;/td&gt; &lt;td&gt; &lt;select name="prov" onchange="updateCity(this.value)"&gt; &lt;option&gt;--请选择--&lt;/option&gt; &lt;option value="0"&gt;北京市&lt;/option&gt; &lt;option value="1"&gt;河北省&lt;/option&gt; &lt;option value="2"&gt;河南省&lt;/option&gt; &lt;/select&gt; &lt;select id="city"&gt; &lt;/select&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;/body&gt;&lt;script&gt; //创建二维数组存放城市 var cities = new Array(3); cities[0] = new Array("朝阳", "海淀", "丰台"); cities[1] = new Array("石家庄", "保定", "廊坊", "邢台"); cities[2] = new Array("郑州", "开封", "洛阳", "南阳", "信阳"); function updateCity(i) &#123; //获取select元素 var city = document.getElementById("city"); city.length = 0; for(j in cities[i]) &#123; //创建option元素 var op = document.createElement("option"); //创建文本节点 var tn = document.createTextNode(cities[i][j]); //将文本节点插入创建的option元素 op.appendChild(tn); //将创建的option元素插入city变量，即select元素 city.appendChild(op); &#125; &#125;&lt;/script&gt;]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编程三大利器及四步走战略]]></title>
    <url>%2F2018%2F11%2F06%2F%E7%BC%96%E7%A8%8B%E4%B8%89%E5%A4%A7%E5%88%A9%E5%99%A8%E5%8F%8A%E5%9B%9B%E6%AD%A5%E8%B5%B0%E6%88%98%E7%95%A5%2F</url>
    <content type="text"><![CDATA[编程三大利器Google 互联网时代，不学编程，搜索也应是必备技能。知之为知之，不知Google知 Google + Wikipedia + English = Almost Everything 科学上网，请自行百度蓝灯之类，或者可访问getlantern Stack OverflowGoogle编程问题，遇见的一直都是他。所以有新闻吐槽到，「计算机编程铁律」将会被正式命名为「Google 一下，然后 Stack Overflow」 Stack Overflow（堆栈溢出）是一个面向程序员的问答网站，2015 年时每天有 760 万的访问量，是当时世界上访问量第 57 位的网站。对在编程中遇到困难的人来说，Stack Overflow 就是庇护所。无论新手还是老手，都把 Stack Overflow 作为一个主要的资源网站。不确定如何解决一个难题？把这个问题放在 Stack Overflow 上。一般来讲，半个小时之内这个问题就会被其他的用户解决（免费）。但切记，如果你不想让你的问题被草草地浏览，请把你的问题写清晰明了。（引自Stack Overflow 与全民编程时代） Github 截止到2015年，GitHub已经有超过九百万注册用户和2110万代码库。事实上已经成为了世界上最大的代码存放网站和开源社区。GitHub除了托管代码功能之外，它也提供了一些协同开发的功能，包括允许追踪其他用户、组织、软件库的动态，对软件代码的改动和bug提出评论等。GitHub也提供了图表功能，用于概观显示开发者们怎样在代码库上工作以及软件的开发活跃程度。（引自维基百科GitHub） 编程四步走 有问题Google一下 打开Stack Overflow找代码 复制&amp;粘贴代码 运行代码123如果代码不能运行： 返回第2步否则：返回第1步 FAQ Q：如果找不到代码咋办？ A：不可能，继续找。(引自漫画：如何编程？四步走，So easy！)]]></content>
      <categories>
        <category>Guide</category>
      </categories>
      <tags>
        <tag>Google</tag>
        <tag>Stack Overflow</tag>
        <tag>Github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux下安装Python包]]></title>
    <url>%2F2018%2F11%2F05%2FLinux%E4%B8%8B%E5%AE%89%E8%A3%85Python%E5%8C%85%2F</url>
    <content type="text"><![CDATA[安装指南：Python官方安装指南(英文)和ubuntu一些基本软件安装方法(中文) 1. pip安装python标准库中的包123456# 如果提示没有权限，安装命令前加sudopip install 'SomeProject' # 安装最新版本的包pip install 'SomeProject==1.4' # 安装特定版本的包pip install -U setuptools # 安装安装包时会用到的工具setuptools 2. apt-get安装方式12345678910111213sudo apt-get install 安装包名称sudo apt-get install python-jinja2sudo apt-get install python2.7-mysqldbsudo apt-get install python-pip# 完整步骤（下载、解压、更新、安装）wget url # 根据链接url下载文件targetunzip target # 解压文件sudo apt-get update # 更新软件信息库sudo apt-get install target #以编译方式安装target文件 3. deb类型安装包的安装方式 deb 是 debian 系 Linux 的包管理方式, ubuntu 是属于 debian 系的 Linux 发行版，默认支持这种软件安装方式，当下载到一个deb 格式的软件后，在终端输入如下一行命令就能安装:1sudo dpkg -i deb安装包名称加后缀 4. 安装tar.gz或tgz软件 方法1 12341. 下载压缩包2. 解压压缩包3. cd到解压后的文件目录下，执行sudo Python setup.py install 方法2 1234567891011121314# 以python3.5.3安装为例首先下载安装包#解压安装包，并出现Python-3.5.3.tgz目录tar -xzvf Python-3.5.3.tgz cd Python-3.5.3.tgz./configuremake # 如果报错请求被拒绝，则使用sudo重新运行make install]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Guide</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS快速入门]]></title>
    <url>%2F2018%2F11%2F04%2FCSS%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[层叠样式表（Cascading Style Sheets），样式定义如何显示html元素，多个样式可以叠加显示，样式通常保存在样式表中，即css文件。 将CSS添加到HTML中，解决了内容与表现分离的问题，更好的修饰HTML内容的样式，丰富页面，渲染显示效果，更好的规划页面布局。而且，外部CSS便于维护，极大提高工作效率。 CSS基本语法CSS 基本语法由两个主要部分构成：选择器和声明。代码示例如下： 如果值为多个单词，则要给值加双引号 多个声明之间使用分号(;)隔开 css对大小写不敏感，如果涉及到与html文档一起使用时，class与id名称对大小写敏感 123456789p&#123; text-align:center; font-family:arial; color:black;&#125;/*p 为元素选择器&#123;&#125; 中内容为样式的声明*/ 导入CSS的方式内联样式表内联样式，是在相关的标签内使用样式（style）属性。style 属性可以包含任何 CSS 属性，代码示例如下:12345678910111213&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8" /&gt; &lt;title&gt;Hello&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;!--内联样式表--&gt; &lt;p style="font-family: '黑体';color: yellowgreen;"&gt; CSS即层叠样式表（Cascading Style Sheets）&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 提示：慎用内联样式表，它将html的内容与表现混在一起，没有发挥层叠样式表的优势。一般情况下，只有在单个标签上只应用一次样式时才会使用，这种方式使用的仅仅是标签的一个样式属性。 内部样式表内部样式表，是使用style标签在html文档的head中来定义样式表。内部样式表只适应用于单个页面。代码示例如下：123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8" /&gt; &lt;title&gt;Hello&lt;/title&gt; &lt;!--内部样式表--&gt; &lt;style type="text/css"&gt; p&#123; font-family: "微软雅黑"; color: red; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;CSS即层叠样式表（Cascading Style Sheets）&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 外部样式表如果想要在多个页面使用同一层叠样式表，外部样式表是最合适的，可以在html页面上使用link标签来导入外部样式表。代码示例如下：12345678910111213&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8" /&gt; &lt;title&gt;Hello&lt;/title&gt; &lt;!--外部样式表--&gt; &lt;link rel="stylesheet" href="css/p.css" / &lt;/head&gt; &lt;body&gt; &lt;p&gt;CSS即层叠样式表（Cascading Style Sheets）&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 浏览器会从层叠样式表文件中读取样式，并对页面上的html进行渲染。外部样式表以css为后缀。外部样式表代码示例如下:123456p&#123; align-content: center; font-family: "楷体"; font-size: large; color: darkgreen;&#125; @import导入@import导入，也是外部导入，不推荐使用。代码示例如下：123456789101112131415&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8" /&gt; &lt;title&gt;Hello&lt;/title&gt; &lt;!--@import导入--&gt; &lt;style type="text/css"&gt; @import url("css/p.css"); &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;CSS即层叠样式表（Cascading Style Sheets）&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 不同样式表的优先级问题： 内联样式表 &gt; 内部样式表 &gt; 外部样式表 CSS选择器CSS选择器，主要是用于选择需要添加样式的html元素，用于精准定位到具体的想要添加样式的某个或某些元素.常用选择器有：id选择器、class选择器、元素选择器、属性选择器。 id选择器Id选择器使用#引入，它引用的是id属性中的值。代码示例如下：12345678910&lt;head&gt; &lt;style type="text/css"&gt; #p &#123; color: blue ; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;p id="p"&gt;hello world&lt;/p&gt;&lt;/body&gt; class选择器类选择器使用时，需要在类名前加一个点号(.)。代码示例如下：12345678910&lt;head&gt; &lt;style type="text/css"&gt; .c &#123; color: blue ; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;p class="c"&gt;hello world&lt;/p&gt;&lt;/body&gt; 元素选择器这是最常见的选择器，简单说，文档中的元素就是选择器。代码示例如下： 12345678910&lt;head&gt; &lt;style type="text/css"&gt; p&#123; color: blue ; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;hello world&lt;/p&gt;&lt;/body&gt; 属性选择器如果需要选择有某个属性的元素，而不论属性是什么，可以使用属性选择器。代码示例如下：12345678910&lt;head&gt; &lt;style type="text/css"&gt; a[href] &#123; color: red ; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;a href="http://zsx-cup.top"&gt;Xu'Blog&lt;/a&gt;&lt;br /&gt;&lt;/body&gt; CSS属性所谓属性就像java类中定义的一些属性，用来描述一些具体的特性。 字体css字体属性定义文本的字体系列，大小，加粗，风格(如斜体)和变形(如小型大写字母)。常用属性: font:简写属性，所有针对字体的属性可设置在一个声明中。 font-family: 字体系列 font-size: 字体尺寸 font-style: 字体风格 文本CSS 文本属性可定义文本的外观。通过文本属性，可以改变文本颜色、字符间距、对齐方式、装饰文本、文本缩进等。常用属性： color: 文本颜色 text-align: 对齐方式 letter-spacing: 字符间隔 word-spacing: 字间隔 背景CSS 允许应用纯色，或使用图像作为背景。CSS 在这方面的能力远远在 HTML 之上。常用属性: background:简写属性，背景属性设置可在一个声明中 background-color: 背景颜色 background-image: 背景图片 background-position: 背景图片的起始位置 background-repeat: 背景图片是否及如何重复。 尺寸CSS 尺寸属性允许控制元素的高度和宽度。常用属性: width: 元素宽度 height: 元素高度 列表CSS 列表属性允许放置、改变列表项标志，或者将图像作为列表项标志。 常用属性: list-style: 简写属性。所有用于列表的属性可设置在一个声明中。 list-style-image: 列表项标志的图象 list-style-position: 列表项标志的位置 list-style-type: 列表项标志的类型。 表格CSS 表格属性可极大改善表格外观。常用属性: border-collapse: 是否把表格边框合并为单一的边框。 border-spacing: 分隔单元格边框的距离 caption-side: 表格标题的位置 轮廓轮廓（outline）是绘制于元素周围的一条线，位于边框边缘的外围，可起到突出元素的作用。CSS轮廓属性规定元素轮廓的样式、颜色和宽度。常用属性: outline: 简写属性。可在一个声明中设置所有的轮廓属性 outline-color: 轮廓颜色 outline-style: 轮廓样式 outline-width: 轮廓宽度 定位CSS 定位 (Positioning) 属性允许对元素进行定位。定位的基本思想很简单，它允许你定义元素框相对于其正常位置应该出现的位置，或者相对于父元素、另一个元素甚至浏览器窗口本身的位置。CSS 有三种基本的定位机制：普通流、浮动和绝对定位。常用属性: position: 把元素放置到一个静态的、相对的、绝对的、或固定的位置中。 top: 定位元素的上外边距边界与其包含块上边界之间的偏移量 right: 定位元素右外边距边界与其包含块右边界之间的偏移 left: 定位元素左外边距边界与其包含块左边界之间的偏移 bottom: 定位元素下外边距边界与其包含块下边界之间的偏移。 分类CSS 分类属性允许你控制如何显示元素，设置图像显示于另一元素中的何处，相对于其正常位置来定位元素，使用绝对值来定位元素，以及元素的可见度。常用属性： clear: 一个元素的侧面是否允许其它的浮动元素 float: 元素的浮动方向 cursor: 当指向某元素之上时显示的指针类型 display: 是否及如何显示元素 visibility: 元素是否可见或不可见。]]></content>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML快速入门]]></title>
    <url>%2F2018%2F11%2F01%2FHTML%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[超文本标记语言（Hyper Text Markup Language），超越普通文本，以标签记号描述网页的非编程语言。HTML文件被浏览器加载读取，以网页的形式展示。 HTML文件格式1. html 文件都是以.html 或者.htm 结尾的，推荐使用.html。 2. html 文件由头部&lt;head&gt;&lt;/head&gt;和主体&lt;body&gt;&lt;/body&gt;两部分组成 3. html 标签都是成对出现的，如&lt;html&gt;&lt;/html&gt;，&lt;head&gt;&lt;/head&gt;&gt;，&lt;body&gt;&lt;/body&gt; 4. html 标签忽略大小写，推荐使用小写。 HTML基本标签文件标签1. html标签。整个文件都处于&lt;html&gt;标签中，&lt;!DOCTYPE HTML&gt;用以声明文件类型是 HTML 文件，让浏览器识别并处理该文件。 2. head标签。在HTML文件有两部分&lt;head&gt;与&lt;body&gt;，&lt;head&gt;用于加载网页的部分重要信息，它的内容不会被显示。 3. title标签。&lt;title&gt;只能出现于&lt;head&gt;中，它代表的是网页标题。 4. body标签。&lt;body&gt;中的内容是网页的主体部分，会被显示。 HTML元素和属性 HTML元素: 指的是从开始标签到结束标签的所有代码，包含其中所有的子标签及其内容。 123&lt;body&gt; //body元素包含p标签元素&lt;p&gt;p标签元素&lt;/p&gt; //这行就是一个p标签元素&lt;/body&gt; HTML属性：每个标签元素可以拥有属性。属性提供了有关 HTML 元素的更多的信息。属性总是以名称-值成对出现，比如：name=”value”。作用是使整个元素具有特定的特性 。 1&lt;body bgcolor="yellow"&gt; //是整个背景颜色变成黄色 排版标签1. 注释。在html中注释是 &lt;!--注释 --&gt; 2. p标签。&lt;p&gt;标签是段落标签，可以将html文档分割为若干段落。浏览器会自动在段落前后添加空行。 常用属性: align:用于设定对齐方式 可选值 left right center 默认值是left. 3. br标签。&lt;br&gt;标签是换行标签。因为浏览器会自动的忽略空白与换行，因此&lt;br&gt;标签较常用。 4. hr标签。&lt;hr&gt;标签会生成水平线。 常用属性: align:设置水平线对齐方式 可选值 left right center size:设置水平线厚度 以像素为单位。默认为2 width:设置水平线长度.可以是绝对值或相对值。默认为100% color:设置水平线颜色.默认为黑色 5. 关于html中数值单位。html的数值默认单位为像素(px)，在有些位置可以使用百分比。 块标签1. div标签。用于在文档中设定一个块区域。 2. span标签。用于在行内设定一个块区域。 3. Font 字体&lt;font&gt;标签用于规定文本的字体(face)，大小(size)，颜色(color)。 4. h1-h6标题。&lt;h1&gt;-&lt;h6&gt;标签用于定义标题，&lt;h1&gt;最大标题，&lt;h6&gt;最小标题 列表标签1. &lt;ul&gt;标签表示的是一个无序列表。 常用属性: type:项目符号类型,可取值 disc,square,circle.默认值为disc 2. &lt;li&gt;标签表示的是一个列表项。 常用属性: type: 只适用于无序列表，用于设定项目符号，默认值为disc value: 只适用于有序列表，用于设定列表的项目数字 3. &lt;ol&gt;表示的是一个有序列表。 常用属性: type:这个属性规定列表中使用的标记类型。可取值1、A、a、I、i。 value:这个属性规定列表的起始值 图片标签&lt;img&gt;是一个图片标签，用于在页面上引入图片 常用属性： 边框：border 宽度：width 高度：height 居中显示：align 引用图片路径：src 绝对路径与相对路径： 绝对路径： 带有盘符的相对路径： 如果是同级目录： 直接写文件名称或者./文件名称 如果是上一级目录： ../文件名称(如果是多层，对应多个../) 如果是下一级目录： 目录名称/文件名称 链接标签&lt;a&gt;标签用于定义超连接，从一个页面链接到另一个页面。 常用属性: href:用于设定链接的资源 name:用于设定锚的名称 target:用于设定在何处打开链接页面。 链接资源 内部资源： 图片、HTML等；引用时采用相对于本资源的相对路径； 外网资源： 如图床的图片、视频网站的视频等；引用时采用绝对路径。 表格标签1. &lt;table&gt;标签用于定义表格 常用属性: 边框：border 宽度：width 高度：height 背景颜色：bgcolor 边框与边框的间距：cellspacing 边框与内容的间距：cellpadding 居中显示：align 2. &lt;tr&gt;标签用于定义表格的行,包含一个或多个th或td元素。 常用属性: align:用于设定表格中行的内容对齐方式。 bgcolor:用于设定表格中行的背景颜色。 3. &lt;td&gt;标签用于定义表格单元，文本一般显示为正常字体且左对齐。 常用属性: align:用于设定单元格内容的对齐方式。 bgcolor:用于设定单元格背景颜色。 height:用于设定单元格的高度。 width:用于设定单元格的宽度。 colspan:用于设定列合并，合并相邻列 rowspan:用于设定行合并，合并相邻行 4. &lt;caption&gt;用于定义表格标题 &lt;caption&gt;标签必须紧随&lt;table&gt;标签之后， 一个表格只能有一个标题，且标题通常在表格之上居中显示。 5. &lt;th&gt;标签用于定义表格的表头，文本通常居中加粗显示。 html表格中有两种类型的单元格： 表头单元格th:包含表头信息。 标准单元格td:包含数据。 HTML表单标签form标签&lt;form&gt;标签代表一个表单，用于向服务器传输数据。 &lt;form&gt;标签包含&lt;input&gt;、&lt;textarea&gt;、&lt;select&gt;等。 &lt;form&gt;常用属性: name: 定义表单的名称 action: 向何处发送表单数据 method: 表单提交方式，POST或GET。 POST与GET方式区别: get方式只能少量数据，数据会在地址栏上显示，安全性差。 post可以携带大数据，数据不会在地址栏上显示，更加安全。 input标签&lt;input&gt; 标签用于页面交互。根据不同的 type 属性值，输入字段拥有很多种形式。输入字段可以是文本字段、密码、单选框、复选框、按钮等。 &lt;input&gt;标签type属性值包含： 1. text &lt;input type=”text”&gt; 定义单行的输入字段，用户可在其中输入文本。默认宽度为 20 个字符。 其它常用属性: name:定义标签名称 value:定义标签值 size:定义输入字段的长度 maxlength:定义可输入最大字符个数 2. password &lt;input type=”password”&gt; 定义密码字段。该字段中的字符被掩码。 其它常用属性: name:定义标签名称 value:定义标签值 size:定义输入字段的长度 maxlength:定义可输入最大字符个数 3. radio &lt;input type=”radio”&gt; 定义单选按钮。 其它常用属性: name:定义标签名称。对于单选按钮，多radio的name值必一样。 value:定义标签值 checked:定义该标签默认被选中。 4. checkbox &lt;input type=”checkbox”&gt; 定义复选框。 其它常用属性: name:定义标签名称，一组的checkbox的name值应该是一样的。 value:定义标签值 checked:定义该标签默认被选中。 5. button &lt;input type=”button”&gt; 定义可点击按钮（多数情况下，用于通过JS启动脚本） 其它常用属性: name:定义标签名称 value:按钮显示名称 6. hidden &lt;input type=”hidden”&gt; 定义隐藏的输入字段。 其它常用属性: name:定义标签名称 value:定义标签值 7. file &lt;input type=”file”&gt; 定义输入字段和&quot;浏览&quot;按钮，供文件上传。 其它常用属性: name:定义标签名称 8 submit &lt;input type=”submit”&gt; 定义提交按钮，把表单数据发送到服务器。 其它常用属性: name:定义标签名称 value:按钮显示名称 9. reset &lt;input type=”reset”&gt; 定义重置按钮，清除表单中的所有数据。 其它常用属性: name:定义标签名称 value:按钮显示名称 10. image &lt;input type=”image”&gt; 定义图像形式的提交按钮。 这个标签主要是用了替换submit按钮，因为默认产生的提交按钮并不漂亮，这个标签允许你采用指定的图片做为提交按钮。 其它常用属性: name:定义标签名称 src:定义作为提交按钮显示的图像的url alt:定义作用图像的替代文本。 select标签&lt;select&gt; 用于定义一个下拉列表 常用属性: name:定义下拉列表的名称 size:定义下拉列表中可见选项的数目 multiple:定义可选择多个选项 option标签&lt;option&gt; 用于定义下拉列表中的选项，位于&lt;select&gt;标签内部 常用属性: value:定义送往服务器的选项值 selected:定义选项为选中状态。 textarea标签&lt;textarea&gt;标签用于定义多行文本输入控件(多行文本框，文本域) 常用属性: name:定义多行文本框名称 cols:定义多行文本框可见宽度 rows:定义多行文本框可见行数 wrap:规定多行文本框中文字如何换行。 其它标签与特殊字符meta标签&lt;meta&gt; 元素可提供有关页面的元信息（meta-information），比如针对搜索引擎和更新频度的描述和关键词。 &lt;meta&gt; 标签位于文档的头部，不包含任何内容。&lt;meta&gt; 标签的属性定义了与文档相关联的名称/值对。 常用属性： content: 定义与http-equiv或name属性相关的元信息 http-equiv: 把content属性关联到HTTP头部 name: 把content属性关联到一个名称。 link标签&lt;link&gt; 标签定义文档与外部资源的关系。 &lt;link&gt; 标签最常见的用途是链接样式表，会在css中介绍。 &lt;link&gt;只能存在于 head 部分，不过它可出现任何次数。 常用属性: type:定义被链接的文档的MIME类型 href:定义被链接的文档的URL rel:定义当前文档与被链接文档之间的关系。 特殊字符原码 |显示| 描述 --- |--- | --- &amp;nbsp;|空格| 不断行的空白符 &amp;lt; | &lt; | 小于号 &amp;gt; | &gt; | 大于号 &amp;reg; | ® | 已注册 &amp;copy;| © | 版权 代码示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"/&gt; &lt;title&gt;HTML&lt;/title&gt; &lt;/head&gt; &lt;body bgcolor="gold"&gt; &lt;!--title--&gt; &lt;h1 align="center"&gt;HTML入门&lt;/h1&gt; &lt;h2 &gt;title&lt;/h2&gt; &lt;!--paragraph--&gt; &lt;p align="center"&gt; hello world! &lt;br /&gt; winter is coming! &lt;/p&gt; &lt;!--div--&gt; &lt;div id="div1" style="" align="right" width=20px height=20px&gt; 我的地盘我做主 &lt;br /&gt; &lt;!--font--&gt; &lt;font size="9", color="red"&gt;font&lt;/font&gt; &lt;/div&gt; &lt;!--image--&gt; &lt;img src="img/HBuilder.png" width="20px" height="20px" alt="不小出错咯"/&gt; &lt;br /&gt; &lt;!--link--&gt; &lt;a href="http://zsx-cup.top"&gt;Xu'Blog&lt;/a&gt;&lt;br /&gt; &lt;a href="img/HBuilder.png"&gt;picture&lt;/a&gt;&lt;br /&gt; &lt;a href="index.html"&gt;html&lt;/a&gt; &lt;br /&gt; &lt;!--table--&gt; &lt;table align="center" border="1px"&gt; &lt;tr&gt; &lt;th&gt;name&lt;/th&gt; &lt;th&gt;sex&lt;/th&gt; &lt;th&gt;age&lt;/th&gt; &lt;th&gt;height&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th&gt;mike&lt;/th&gt; &lt;th&gt;man&lt;/th&gt; &lt;th&gt;16&lt;/th&gt; &lt;th&gt;170&lt;/th&gt; &lt;/tr&gt; &lt;/table&gt; &lt;!--list--&gt; &lt;ol type="A" start=""&gt; &lt;li&gt;javase&lt;/li&gt; &lt;li&gt;javaweb&lt;/li&gt; &lt;li&gt;javame&lt;/li&gt; &lt;/ol&gt; &lt;ul type="circle"&gt; &lt;li&gt;html&lt;/li&gt; &lt;li&gt;css&lt;/li&gt; &lt;li&gt;js&lt;/li&gt; &lt;/ul&gt; &lt;!--水平线--&gt; &lt;hr color="red" size="2px" width="100%" /&gt; &lt;!--居中，将列表显示为一行--&gt; &lt;center&gt; &lt;ul type="square"&gt; &lt;li style="display: inline;"&gt;&lt;a href="http://zsx-cup.top"&gt;blog&lt;/a&gt;&lt;/li&gt; &lt;li style="display: inline;"&gt;&lt;a href="http://zsx-cup.top"&gt;blog&lt;/a&gt;&lt;/li&gt; &lt;li style="display: inline;"&gt;&lt;a href="http://zsx-cup.top"&gt;blog&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/center&gt; &lt;hr color="red" size="2px" width="100%" /&gt; &lt;!--form--&gt; &lt;h1&gt;form&lt;/h1&gt; &lt;form&gt; e-mail: &lt;input type="email" name="email"/&gt;&lt;br /&gt; username: &lt;input type="text" name="username"/&gt;&lt;br /&gt; password: &lt;input type="password" name="pwd"/&gt;&lt;br /&gt; gender: &lt;input type="radio" name="sex" value="man"/&gt; man &lt;input type="radio" name="sex" value="woman"/&gt; woman &lt;br /&gt; hobby: &lt;input type="checkbox" name="hobby" value="eat"/&gt; eat &lt;input type="checkbox" name="hobby" value="drink"/&gt; drink &lt;input type="checkbox" name="hobby" value="play"/&gt; play &lt;br /&gt; upload avator: &lt;input type="file" name="avator" /&gt; &lt;br /&gt; birth place: &lt;select name="address"&gt; &lt;option value="China"&gt;China&lt;/option&gt; &lt;option value="America"&gt;America&lt;/option&gt; &lt;option value="Canada"&gt;Canada&lt;/option&gt; &lt;option value="Brazil"&gt;Brazil&lt;/option&gt; &lt;/select&gt; &lt;select name="city"&gt; &lt;option value="bj"&gt;Beijing&lt;/option&gt; &lt;option value="ny"&gt;New York&lt;/option&gt; &lt;option value="vc"&gt;Vancouve&lt;/option&gt; &lt;option value="nj"&gt;Nanjing&lt;/option&gt; &lt;/select&gt; &lt;br /&gt; tips: &lt;br /&gt; &lt;textarea rows="3" cols="30"&gt;&lt;/textarea&gt; &lt;br /&gt; &lt;br /&gt; &lt;button type="submit" name="submit" value="sign up"&gt;sign up&lt;/button&gt; &lt;button type="submit" name="submit" value="sign in"&gt;sign in&lt;/button&gt; &lt;button type="reset" name="reset" value="reset"&gt;reset&lt;/button&gt; &lt;/form&gt; &lt;!--框架标签--&gt; &lt;frameset rows="15%,*"&gt; &lt;frame src="head.html" /&gt; &lt;frameset cols="15%,*"&gt; &lt;frame src="left.html" /&gt; &lt;frame src="index.html" name="index" /&gt; &lt;/frameset&gt; &lt;/frameset&gt; &lt;!--盒子模式--&gt; &lt;div style=" margin-top: 50px; padding: 50px; width: 400px; height: 400px; background-color: #006400;"&gt; &lt;div style="width: 200px; height: 200px; background-color: red;"&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux命令及双系统安装配置]]></title>
    <url>%2F2018%2F11%2F01%2FLinux%E5%91%BD%E4%BB%A4%E5%8F%8A%E5%8F%8C%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[linux基本命令 Ubuntu16.04 跟工作目录相关命令 cd 返回根目录 cd + dirpath 更改工作目录至dirpath cd .. 返回上一级目录 pwd 返回当前工作目录 ls 查看当前目录下的文件 ls -l 查看当前目录下的文件的详细信息 rm 删除文件 rmdir 删除文件夹 rm -rf 强制性删除非空目录 复制文件或目录: cp -r 文件或目录名称 指定目录 开启与关闭真正终端 Ctrl + Alt + T 打开虚拟终端 ctrl + alt + f6 开启真正的终端 ctrl + alt + f7 关闭真正的终端 超级管理员 sudo 即super do 超级管理员 sudo -i 直接进入超级管理员模式 su + username 退出超级管理员模式 nano+filename 在当前文件下新建文件，nano是ubuntu默认的编辑器 1234567$ cd /tmp/ $ nano hello.py # 在tmp/ 目录下创建文件hello.py$ print('hello world') # 向文件内写入一行代码$ ctrl + x # 退出文件$ y # 回复y保存所做的改变$ python hello.py # 运行py文件，并输出结果'hello world' 文件权限：r w x 12345$ cd /tmp/ $ ls -l # 查看文件详细信息-rw------- 1 zsx zsx 0 6月 9 20:34 config-err-pVx0cf-rw-rw-r-- 1 zsx zsx 20 6月 9 20:37 hello.pydrwx------ 3 root root 4096 6月 9 20:33 systemd-private r read 读的权限 w write 写的权限 x 执行的权限 r w x的值分别为4 2 1 rwx=7 r-w=6 r-x=5 w-x=3 以上述的hello.py文件为例说明文件权限及更改方法： 最前边的-代表文件，如果是d则代表是文件夹 最前边的rw 表示该文件或文件所属的用户对该文件的操作权限 中间的rw 表示该文件或文件所属的用户组对该文件的操作权限 最后边的r 表示其他用户或用户组对该文件的操作权限 以值的形式表示上述文件操作权限则是664-更改文件操作权限的命令是chmod123$ chmod 764 hello.py # 增加该文件所述用户对文件的执行权限$ ls -l-rwxrw-r-- 1 zsx zsx 20 6月 9 20:37 hello.py rm remove删除文件 tail -n filename 查看文件内容 1$ tail -10 test.py man 查看帮助 12$ man tail # 查看tail命令的帮助文档$ tail --help # 查看tail命令的帮助文档 从ubuntu终端进入Python和scrapy shell，再退回到终端的快捷键都是：Ctrl + D。 从终端中以窗口形式打开一个文件夹：nautilus dirname LINUX中常用操作命令 LINUX中常用操作命令 10 Basic Linux Commands That Every Linux Ubuntu Unity 桌面快捷键切换窗口技巧： 不同程序之间切换：alt + tab 同一程序不同窗口之间切换：alt + `（tab键上方按键） 长按Super键（Win键）显示键盘快捷键 Ubuntu双系统安装及配置 Ubuntu16.04.2 安装和卸载ubuntu双系统： Win7 U盘安装Ubuntu16.04 双系统详细教程 开始ubuntu安装，重启电脑，按F12而非F2并选择USB KEY启动。 启动器栏转换到桌面底部，只需要在终端如下代码，按下回车即可： 12# 更改代码最后一个表示位置的单词，即可更改启动器位置$ gsettings set com.canonical.Unity.Launcher launcher-position Bottom 双系统下卸载Ubuntu系统 安装软件 蓝色字体表示超链接，链接到软件安装页面 lantern：蓝灯，科学上网，使用谷歌浏览器登录账户同步信息。 chrome：谷歌浏览器，腾讯软件中心下载源，打开蓝灯下载安装登录账户同步信息。 sublime text 3：文本编辑器，可能需要购买许可证 Atom：免费文本编辑器，输入带特效。安装插件代码：1$ apm install &lt;package_name&gt; atom常用插件及快捷键输入关键词搜索，如python，markdown 执行代码：atom-runner，快捷键Alt + R 自动补全代码：autocomplete python，快捷键Ctrl + Alt + G 输入带特效：activate-power-mode 定义跳转：python-tools 自动缩进：python-indent 语法检查：linter-flake8 和 linter-python markdown: markdown-writer，markdown-preview-plus(预览快捷键ctrl-shift-M), language-markdown(语法)]]></content>
      <categories>
        <category>System</category>
      </categories>
      <tags>
        <tag>Guide</tag>
        <tag>Linux</tag>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Sublime Text 3 快捷键汇总]]></title>
    <url>%2F2018%2F10%2F31%2FSublime-Text-3-%E5%BF%AB%E6%8D%B7%E9%94%AE%E6%B1%87%E6%80%BB%2F</url>
    <content type="text"><![CDATA[本文摘录自Sublime Text 3 快捷键总结（拿走），Sublime Text 3 常用快捷键大概分为四类： 选择 编辑 搜索 显示 选择类Ctrl+D 选中光标所占的文本，继续操作则会选中下一个相同的文本。 Alt+F3 选中文本按下快捷键，即可一次性选择全部的相同文本进行同时编辑。举个栗子：快速选中并更改所有相同的变量名、函数名等。 Ctrl+L 选中整行，继续操作则继续选择下一行，效果和 Shift+↓ 效果一样。 Ctrl+Shift+L 先选中多行，再按下快捷键，会在每行行尾插入光标，即可同时编辑这些行。 Ctrl+Shift+M 选择括号内的内容（继续选择父括号）。举个栗子：快速选中删除函数中的代码，重写函数体代码或重写括号内里的内容。 Ctrl+M 光标移动至括号内结束或开始的位置。 Ctrl+Enter 在下一行插入新行。举个栗子：即使光标不在行尾，也能快速向下插入一行。 Ctrl+Shift+Enter 在上一行插入新行。举个栗子：即使光标不在行首，也能快速向上插入一行。 Ctrl+Shift+[ 选中代码，按下快捷键，折叠代码。 Ctrl+Shift+] 选中代码，按下快捷键，展开代码。 Ctrl+K+0 展开所有折叠代码。 Ctrl+← 向左单位性地移动光标，快速移动光标。 Ctrl+→ 向右单位性地移动光标，快速移动光标。 shift+↑ 向上选中多行。 shift+↓ 向下选中多行。 Shift+← 向左选中文本。 Shift+→ 向右选中文本。 Ctrl+Shift+← 向左单位性地选中文本。 Ctrl+Shift+→ 向右单位性地选中文本。 Ctrl+Shift+↑ 将光标所在行和上一行代码互换（将光标所在行插入到上一行之前）。 Ctrl+Shift+↓ 将光标所在行和下一行代码互换（将光标所在行插入到下一行之后）。 Ctrl+Alt+↑ 向上添加多行光标，可同时编辑多行。 Ctrl+Alt+↓ 向下添加多行光标，可同时编辑多行。 编辑类Ctrl+J 合并选中的多行代码为一行。举个栗子：将多行格式的CSS属性合并为一行。 Ctrl+Shift+D 复制光标所在整行，插入到下一行。 Tab 向右缩进。 Shift+Tab 向左缩进。 Ctrl+K+K 从光标处开始删除代码至行尾。 Ctrl+Shift+K 删除整行。 Ctrl+/ 注释单行。 Ctrl+Shift+/ 注释多行。 Ctrl+K+U 转换大写。 Ctrl+K+L 转换小写。 Ctrl+Z 撤销。 Ctrl+Y 恢复撤销。 Ctrl+U 软撤销，感觉和 Ctrl+Z 一样。 Ctrl+F2 设置书签 Ctrl+T 左右字母互换。 F6 单词检测拼写 搜索类Ctrl+F 打开底部搜索框，查找关键字。 Ctrl+shift+F 在文件夹内查找，与普通编辑器不同的地方是sublime允许添加多个文件夹进行查找，略高端，未研究。 Ctrl+P 打开搜索框。举个栗子：1、输入当前项目中的文件名，快速搜索文件，2、输入@和关键字，查找文件中函数名，3、输入：和数字，跳转到文件中该行代码，4、输入#和关键字，查找变量名。 Ctrl+G 打开搜索框，自动带：，输入数字跳转到该行代码。举个栗子：在页面代码比较长的文件中快速定位。 Ctrl+R 打开搜索框，自动带@，输入关键字，查找文件中的函数名。举个栗子：在函数较多的页面快速查找某个函数。 Ctrl+： 打开搜索框，自动带#，输入关键字，查找文件中的变量名、属性名等。 Ctrl+Shift+P 打开命令框。场景栗子：打开命名框，输入关键字，调用sublime text或插件的功能，例如使用package安装插件。 Esc 退出光标多行选择，退出搜索框，命令框等。 显示类Ctrl+Tab 按文件浏览过的顺序，切换当前窗口的标签页。 Ctrl+PageDown 向左切换当前窗口的标签页。 Ctrl+PageUp 向右切换当前窗口的标签页。 Alt+Shift+1 窗口分屏，恢复默认1屏（非小键盘的数字） Alt+Shift+2 左右分屏-2列 Alt+Shift+3 左右分屏-3列 Alt+Shift+4 左右分屏-4列 Alt+Shift+5 等分4屏 Alt+Shift+8 垂直分屏-2屏 Alt+Shift+9 垂直分屏-3屏 Ctrl+K+B 开启/关闭侧边栏。 F11 全屏模式 Shift+F11 免打扰模式]]></content>
      <categories>
        <category>Guide</category>
      </categories>
      <tags>
        <tag>Sublime</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用DOS命令]]></title>
    <url>%2F2018%2F10%2F31%2F%E5%B8%B8%E7%94%A8DOS%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[本文汇总一些常用的DOS命令，更加全面的DOS命令详见：DOS命令 1234567891011121314151617181920212223242526272829cd // 显示或更改当前目录cd / // 返回根目录cd .. // 返回上一级目录dir // 显示当前目录下的文件信息md // 新建文件夹rd // 删除文件start // 新建窗口查看文件或文件夹type // 显示文件内容ren // 文件重命名del // 删除文件cls // 清屏ctrl + shift + T // 打开命令行net start 服务名称 // 启动某服务net stop 服务名称 // 关闭某服务命令行右击“标记”选定内容，点击enter键即可复制命令行右击“粘贴”把剪切板上内容粘贴到提示符下命令 /? // 查看命令的帮助文档echo 文本内容 &gt; 文件路径 //新建文件并写入内容，示例：echo 百度一下 &gt; c:baidu.txtpydoc &lt;name&gt; // 直接查看python模块函数的帮助文档，而不需要进入python。]]></content>
      <categories>
        <category>System</category>
      </categories>
      <tags>
        <tag>Wins</tag>
        <tag>DOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用Wins技巧]]></title>
    <url>%2F2018%2F10%2F31%2F%E5%B8%B8%E7%94%A8Wins%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[虫部落：一个神奇的部落，纯粹的搜索经验、技术交流和分享平台，同时为虫友提供众多方便好用的搜索引擎。 本文整理的这些常用Windows技巧均来自于虫部落：你知道Windows上有哪些奇技淫巧吗？（Windows技巧大全） 微软官网：Windows 中的快捷键及MS Word 在 Windows 上的快捷键 Win键相关的常用快捷键 Win + E 打开计算机 Win + D 返回桌面 Win + F 打开系统搜索 Win+数字键（0~9） 快速启动锁定在任务栏中的前10个对应的程序 Win+Home 最小化当前窗口以外的其他所有程序，节约系统资源。 Win+Tab 3D动画挺炫 “Win+方向键” “Win+↑” 最大化 “Win+↓” 最小化 “Win+←” 窗口占左半边屏幕 “Win+→” 窗口占左半边屏幕 Ctrl和Shift键相关的常用快捷键 ctrl + shift + N 新建文件夹 Ctrl + Shift + Esc 任务管理器 Ctrl + Shift + T 立即重启刚刚关闭的页面 CTRL + Z 撤销上一步操作，还可以快速恢复被删除的文件（彻底删除文件无法恢复） 快速复制复制文件或文件夹磁盘路径：按住Shift键，右键点击文件或文件夹，选择“复制为路径”即可。 F系列功能键相关的常用快捷键 F5在记事本程序中一键快速插入当前日期和时间 F11全屏显示网页，一个有意思的网站：航班追踪。 F2批量重命名文件：同时选中多个文件或文件夹，按F2键，重命名其中一个文件或文件夹，其他的都会被重命名，在文件名末尾加上递增的数字。 2345好压 也可以右键批量修改文件名 前后任意添加/删除/替换 其他技巧 取消电脑开机时的倒计时 右键计算机“属性” 打开“高级系统设置”在启动和故障恢复那里点击“设置” 把“显示操作系统列表的时间”前面的钩钩去掉]]></content>
      <categories>
        <category>System</category>
      </categories>
      <tags>
        <tag>Guide</tag>
        <tag>Wins</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[My Queen]]></title>
    <url>%2F2018%2F10%2F29%2FMy-Queen%2F</url>
    <content type="text"><![CDATA[This Is My Queen!]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>Image</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo配置Next主题搭建炫酷博客主页]]></title>
    <url>%2F2018%2F10%2F29%2FHexo%E9%85%8D%E7%BD%AENext%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E7%82%AB%E9%85%B7%E5%8D%9A%E5%AE%A2%E4%B8%BB%E9%A1%B5%2F</url>
    <content type="text"><![CDATA[更换NexT主题如果觉得Hexo默认的主题不够炫酷，可以参照NexT官方使用文档，将您的博客主题更换为比较流行的NexT主题，从而打造炫酷博客主页。 需要注意的几点 Hexo插件安装 字数统计：wordcount 访客数、访问量统计：busuanzi 搜索功能：Algolia Search 搜索引擎优化：SEO 博文中插入图片、音乐 更新博客 Hexo插件安装Hexo插件是功能实现的前提。想要博客实现某个功能，在Hexo和NexT的配置文件中配制完成后，如果该功能并没有实现，首先要确保安装了相应的插件，简单的方法就重新安装一遍。Hexo默认安装了一些插件，但不没有涵盖所有内置功能，可在Hexo官方文档查询所需插件详细信息：Hexo插件，插件安装命令如下：1$ npm install hexo-plugin-name --save //hexo-plugin-name为Hexo插件名称 字数统计：wordcount1$ npm install hexo-wordcount --save //安装字数统计插件 更改主题配置文件之前，确保安装字数统计插件hexo-wordcount。 访客数、访问量统计：busuanzi1234&lt;script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"&gt;&lt;/script&gt;//若使用busuanzi插件统计站点访客数和访问量，需在必须下面文件中添加上面一行代码方可实现。themes/next/layout/_partials/footer.swig 搜索：Algolia Search根据NexT官方文档： Algolia 提示进行配置，一步步操作到“更新Index”时，按照官方给出命令运行后报错，查找得知官方给出的说明有误，正确命令为：12//Search-Only API key为 Algolia网站上获取的相应API key$ export HEXO_ALGOLIA_INDEXING_KEY=Search-Only API key 搜索引擎优化：SEO 搭建一个网站之后，如果没有做一些相关的搜索引擎优化SEO，那么我们的网站是很难获取来自搜索引擎的流量的，用户很难在搜索引擎上搜索到我们网站的内容，所以接下来我们要为Hexo网站做一些简单的搜索优化。 生成sitemapSitemap用于通知搜索引擎网站上有哪些可供抓取的网页，以便搜索引擎可以更加智能地抓取网站。 执行以下命令，安装插件hexo-generator-sitemap，用于生成sitemap：1$ npm install hexo-generator-sitemap --save 在站点配置文件 _config.yml中添加如下字段：12sitemap:path: sitemap.xml 然后执行如下命令，可查看在网站根目录下public文件夹中生成 sitemap.xml。1$ hexo g 开启百度自动推送在主题配置文件 _config.yml中，将baidu_push设置为true 1baidu_push: true 使用各大搜索引擎站长工具在搜索引擎搜索框输入site:your.domain可以查看域名是否被该搜索引擎收录。如未收录，可使用该搜索引擎的站长工具提交博客网址。 博文中插入图片 把博客根目录下_config.yml 中的post_asset_folder设置为true 下载安装一个可以上传本地图片的插件hexo-asset-image，安装命令如下：1$ npm install hexo-asset-image --save 博文中插入音乐以网易云音乐为例说明，直接在网页版网易云音乐查找喜欢的音乐，可获取如下的代码，直接贴到文档相应位置即可。1&lt;iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&amp;id=536264928&amp;auto=1&amp;height=66"&gt;&lt;/iframe&gt; 更新博客在博客源文件所在的根目录即_config.yml所在根目录，鼠标邮件点击选中’Git Bash Here’，并在命令行中输入一下代码：1$ hexo clean &amp;&amp; hexo g &amp;&amp; hexo d 参考资料 NexT官方使用文档 使用hexo+github搭建个人博客(进阶篇)]]></content>
      <categories>
        <category>Blog</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>NexT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo+Git一个小时快速搭建个人博客]]></title>
    <url>%2F2018%2F10%2F27%2FHexo-Git%E4%B8%80%E4%B8%AA%E5%B0%8F%E6%97%B6%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[搭建本地环境：Hexo框架Hexo为何物 Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用Markdown解析文章，并瞬间利用靓丽的主题生成静态网页。其中，Markdown是一个用于将普通文本转换为HTML的工具，它以易于阅读和编写的纯文本格式进行编写，然后将其转换为的HTML（或XHTML）。 Hexo安装本文是基于Windows7系统安装，如果是其他系统可参见Hexo官方文档。 Hexo安装的前提是电脑预安装Node.js和Git。如果你的电脑已安装Node.js和Git，直接跳到第三步开始安装Hexo；如果未安装则需要先按照前两步提示进行安装，下载安装非常快。 Node.js下载安装，默认安装即可。 Git下载安装，Git官网下载速度非常慢，建议在腾讯软件中心下载Git，默认安装即可。用作将本地的内容提交到GitHub仓库，后续会介绍如何操作。 利用 npm 命令安装Hexo。在任意位置右击鼠标，选择Git Bash输入以下命令即可安装。耗时稍长，安装顺利的话只需要几分钟，如果在安装过程中遇到问题，可重新安装。其中，npm 是 JavaScript 世界的包管理工具,并且是 Node.js 平台的默认包管理工具。1$ npm install -g hexo-cli 成功安装Node.js、Git和Hexo后，可用以下命令查看相应版本，结果如下图：123456789101112131415161718192021222324252627$ node -v //查看node版本v8.12.0$ npm -v //查看npm版本6.4.1$ git --version //查看git版本git version 2.19.1.windows.1$ hexo --version //查看hexo版本hexo: 3.8.0hexo-cli: 1.1.0os: Windows_NT 6.1.7601 win32 x64http_parser: 2.8.0node: 8.12.0v8: 6.2.414.66uv: 1.19.2zlib: 1.2.11ares: 1.10.1-DEVmodules: 57nghttp2: 1.32.0napi: 3openssl: 1.0.2picu: 60.1unicode: 10.0cldr: 32.0tz: 2017c 建站安装 Hexo 完成后，请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。了解目录结构及相关信息可参看Hexo官方文档，稍后配置Hexo时会涉及到。123$ hexo init &lt;folder&gt;$ cd &lt;folder&gt;$ npm install 至此博客本地环境已经搭建完毕，并附上Hexo常用命令。下面进行测试一下，发布一篇名为”Test”的博文，结果展示如下图：123$ hexo new "Test" //新建一篇文章，new后面跟的是标题，最好用双引号括起来，特别是标题中有空格$ hexo g //生成静态文件，g是generate的简写$ hexo s //启动服务器。默认情况下，访问网址为： http://localhost:4000/。 搭建GitHub环境 Github注册 新建仓库（new repository）。注意Owner与repository的前半部分必须一致，比如 开启GitHub Pages。进入刚才新建的仓库，点击Settings并将页面拉到底，即可看见GitHub Pages，该主页托管了上述建立的仓库，主页地址如下图所示，即为刚才新建的仓库地址。 关联Hexo与GitHub Pages初次运行 Git 前的配置 初始化Git，创建一个空的Git仓库，或者重新初始化存在的仓库: 1$ git init 设置你的用户名称与邮件地址： 12$ git config --global user.name "John Doe" //GitHub注册用户名$ git config --global user.email johndoe@example.com //GitHub注册邮箱 如果使用了 –global 选项，那么该命令只需要运行一次，因为之后无论你在该系统上做任何事情， Git 都会使用那些信息。 当你想针对特定项目使用不同的用户名称与邮件地址时，可以在那个项目目录下运行没有 –global 选项的命令来配置。 使用SSH连接到GitHub 该部分参考Github帮助文档：Connecting to GitHub with SSH。 查看存在的SSH公/私钥。通常私钥保存在文件id_rsa，私钥保存在文件id_rsa.pub。 1$ ls -al ~/.ssh 生成SSH公/私钥 1234$ ssh-keygen -t rsa -b 4096 -C "your_email@example.com" //替换邮箱为注册邮箱$ Enter a file in which to save the key (/c/Users/you/.ssh/id_rsa): //提示输入公/私钥保存路径，直接回车即可$ Enter passphrase (empty for no passphrase): //输入密码，可以留空，直接回车即可$ Enter same passphrase again: //再次输入密码，可以留空，直接回车即可 将秘钥添加到SSH代理 1234$ eval $(ssh-agent -s) //首先确保SSH代理在运行Agent pid 59566 //显示进程id$ ssh-add ~/.ssh/id_rsa //将秘钥添加到SSH代理 将公钥添加到Github账户 1$ clip &lt; ~/.ssh/id_rsa.pub //复制刚才生成的公钥，如果公钥保存路径不是默认路径则该命令无效 然后点击Github页面右上角的头像，在弹出栏中点击Settings，并在新页面左边栏中点击SSH and GPG keys，在弹出页面点击New SSH key，并将复制的公钥贴过去，title会根据邮箱自动生成。 测试SSH连接12$ ssh -T git@github.com //测试代码，出现下一行提示表示连接成功Hi username! You've successfully authenticated, but GitHub does not provide shell access. 将网站部署到服务器 安装 hexo-deployer-git: 1$ npm install hexo-deployer-git --save 配置Deployment。 1234deploy: type: git repo:git@github.com:githubname/githubname.github.io.git branch: master 找到根目录中_config.yml中Deployment，按照以下代码格式，将其中的githubname更换为你的Github注册用户名即可。 将博客发布到Github123$ hexo clean //清除缓存文件 (db.json) 和已生成的静态文件 (public)。$ hexo generate // 生成静态文件$ hexo deploy // 部署网站 这样就实现了Hexo本地环境与Github的关联，即可通过 http://githubname.github.io 访问你部署在Github上的博客了，如下图所示。 绑定域名 购买域名。阿里云，腾讯云等都有，最便宜的9块钱 域名解析设置。需要设置的参数，如下表所示，其他参数默认即可。 记录类型 主机记录 记录值 CNAME @ githubname.github.io A www IPV4地址1 记录类型选择CNAME，则记录值填写githubname.github.io（GitHub Pages 对应域名）。 记录类型选择A，则记录值填写IPV4地址，通过ping上述GitHub Pages 域名获取IPV4地址，即下表的185.199.108.153，每次ping获取得到的IPV4地址可能都不相同，所以可以不采用这种方式。 主机记录填写@，则直接解析主域名，前边没有www，如aliyun.com，无论你在浏览器地址栏输入的网址是否加www。 主机记录填写www，则解析后的域名含有www，如www.aliyun.com。12$ ping zhaoshengxu.github.io //ping操作正在 Ping zhaoshengxu.github.io [185.199.108.153] 具有 32 字节的数据: //返回结果第1行 在博客根目录下的source文件夹中新建名为CNAME的无后缀文件，并将购买的域名写入（不加www），如下图所示。 将购买的个性化域名绑定到Github Pages。将个性化域名填入Github Pages页面的Custom domain中并保存，上翻Github Pages页面即可看到，该页面已经和你的个性化域名绑定成功。 测试输入个性化域名访问你的博客首页。 恭喜完成博客的初期搭建，起航吧！ 参考资料 Hexo官方文档 Github帮助文档：Connecting to GitHub with SSH HEXO+Git+Github+域名搭建个人博客 hexo+github搭建个人博客(超详细教程)]]></content>
      <categories>
        <category>Blog</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Git</tag>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[玩转Sci-Hub]]></title>
    <url>%2F2018%2F10%2F24%2F%E7%8E%A9%E8%BD%ACSci-Hub%2F</url>
    <content type="text"><![CDATA[挣扎许久，终于下定决心给看看英文文献，可是搜了一篇又一篇SCI文献，学校图书馆都没有购买，怎么破？假如你也遇到如此尬境，可以尝试一下SCI免费下载神器：Sci-Hub，如不可用，可尝试以下网址，或前往维基百科查看最新可用网址Sci-hub(维基百科) Sci-Hub可用网址(2018.10.24测试可用) sci-hub.tw 80.82.77.83 80.82.77.84 首先需要说明的是： Sci-Hub只支持精确匹配，不支持模糊匹配。这就意味着，搜索结果只有两种：返回目标文献或搜索结果为空。而不会像度娘或谷歌那样支持模糊匹配，返回多个搜索结果。这就要求查找文献之前，必须要提前知道目标查找文献的下列信息之一： 文献标题(String) 文献地址(URL) 文献DOI(数字对象唯一标识符)： 文献PMID(PubMed唯一标识码，生命科学或医学领域) 以下面这篇文献为例，进行介绍： Kubiak W. Completion time variance minimization on a single machine is difficult [J]. Operations Research Letters, 1993, 14(1):49-59. 使用文献标题搜索Sci-Hub搜索框键入文章标题： Completion time variance minimization on a single machine is difficult 返回结果如下图，即没有搜索到我想要的文献。不过，别急着放弃，再尝试使用文献地址(URL)、DOI、PMID进行搜索。 使用文献地址或DOI搜索首先，用度娘查找文献地址、DOI等信息： 在度娘输入文献标题搜索，并在搜索页面依次进入：百度学术-&gt;爱思唯尔(Elsevier)，即可抵达如下页面 页面最下方即为文献地址：https://doi.org/10.1016/0167-6377(93)90019-D(及文献DOI：10.1016/0167-6377(93)90019-D) 文献在百度学术通常有多个文献来源，通常任意文献来源进入之后都可以找到文献DOI，如下图所示： 然后，在Sci-Hub搜索框输入文献地址(URL)或DOI等信息，开始搜索，返回结果页如下，成功返回我想要的文献。 最后，点击右上角的下载箭头，下载文献即可。 可能涉及科学上网Sci-Hub网站涉及版权问题，某些网址可能无法使用，如遇此情况，可访问sci-hub维基百科词条查看可用网址。 如需科学上网，出门左转访问getlantern(蓝灯)下载安装即可使用。]]></content>
      <categories>
        <category>Research</category>
      </categories>
      <tags>
        <tag>Sci-Hub</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo+Git搭建博客初具模样]]></title>
    <url>%2F2018%2F10%2F21%2FHexo-Git%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E5%88%9D%E5%85%B7%E6%A8%A1%E6%A0%B7%2F</url>
    <content type="text"><![CDATA[利用Hexo+Git+GitHub搭建个人博客，博客已经初具模样：]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>Image</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F10%2F17%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>Blog</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>
